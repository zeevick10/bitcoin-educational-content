---
name: Privasi pada Bitcoin
goal: Memahami dan menguasai prinsip perlindungan privasi saat menggunakan Bitcoin
objectives:
  - Mendefinisikan konsep teoretis yang diperlukan untuk memahami taruhan perlindungan privasi
  - Mengetahui cara mengidentifikasi dan mengurangi risiko yang terkait dengan kehilangan privasi pengguna pada Bitcoin
  - Menggunakan metode dan alat untuk melindungi privasi Anda pada Bitcoin
  - Memahami metode analisis rantai dan mengembangkan strategi pertahanan
---
# Lindungi Privasi Anda pada Bitcoin

Di dunia di mana privasi transaksi keuangan secara bertahap menjadi kemewahan, memahami dan menguasai prinsip perlindungan privasi dalam penggunaan Bitcoin Anda adalah esensial. Pelatihan ini memberi Anda semua kunci, baik teoritis maupun praktis, untuk mencapai hal ini secara mandiri.

Hari ini, pada Bitcoin, ada perusahaan yang mengkhususkan diri dalam analisis rantai. Inti bisnis mereka adalah tepatnya untuk mengganggu ranah pribadi Anda, dalam rangka mengkompromikan kerahasiaan transaksi Anda. Faktanya, "hak atas privasi" pada Bitcoin tidak ada. Oleh karena itu, terserah Anda, pengguna, untuk menegaskan hak alami Anda dan melindungi kerahasiaan transaksi Anda, karena tidak ada orang lain yang akan melakukannya untuk Anda.

Pelatihan ini disajikan sebagai perjalanan yang lengkap dan generalis. Setiap konsep teknis dijelaskan secara rinci dan didukung oleh diagram penjelas. Tujuannya adalah untuk membuat pengetahuan dapat diakses oleh semua orang. BTC204 oleh karena itu dapat diakses untuk pengguna pemula dan menengah. Pelatihan ini juga menawarkan nilai tambah kepada bitcoiner yang paling berpengalaman, karena kami menyelami beberapa konsep teknis yang sering tidak diketahui.

Bergabunglah dengan kami untuk mengubah penggunaan Bitcoin Anda dan menjadi pengguna yang terinformasi, mampu memahami isu seputar kerahasiaan dan melindungi privasi Anda.

+++

# Pendahuluan
<partId>e17474a8-8899-4bdb-a7f8-bc52ddb01440</partId>

## Pengantar Pelatihan
<chapterId>08ba1933-f393-4fb5-8279-777d874caedb</chapterId>

Di dunia di mana privasi transaksi keuangan secara bertahap menjadi kemewahan, memahami dan menguasai prinsip perlindungan privasi dalam penggunaan Bitcoin Anda adalah esensial. Pelatihan ini memberi Anda semua kunci, baik teoritis maupun praktis, untuk mencapai hal ini secara mandiri.
Hari ini, dalam ekosistem Bitcoin, ada perusahaan yang mengkhususkan diri dalam analisis rantai. Inti bisnis mereka adalah tepatnya untuk mengganggu ranah pribadi Anda, mengkompromikan kerahasiaan transaksi Anda. Dalam kenyataannya, "hak atas privasi" pada Bitcoin tidak ada. Oleh karena itu, terserah Anda, pengguna, untuk menegaskan hak alami Anda dan melindungi kerahasiaan transaksi Anda, karena tidak ada orang lain yang akan melakukannya untuk Anda.

Bitcoin tidak hanya ada untuk "Number Go Up" dan pelestarian nilai tabungan. Karena karakteristik unik dan sejarahnya, itu terutama adalah alat dari ekonomi bawah tanah. Berkat penemuan luar biasa ini, Anda dapat bebas mengelola uang Anda, menghabiskannya, dan mengakumulasikannya, tanpa ada yang dapat mencegah Anda.

Bitcoin menawarkan pelarian damai dari kuk negara, memungkinkan Anda untuk sepenuhnya menikmati hak alami Anda, yang tidak dapat ditantang oleh hukum yang telah ditetapkan. Berkat penemuan Satoshi Nakamoto, Anda memiliki kekuatan untuk menegakkan penghormatan terhadap properti pribadi Anda dan mendapatkan kembali kebebasan untuk berkontrak.

Namun, Bitcoin secara default tidak anonim, yang dapat menimbulkan risiko bagi individu yang terlibat dalam ekonomi bawah tanah, terutama di wilayah di bawah rezim despotik. Tapi ini bukan satu-satunya bahaya. Mengingat bitcoin adalah aset berharga dan tidak dapat disensor, itu dapat menarik perhatian pencuri. Dengan demikian, melindungi privasi Anda juga menjadi masalah keamanan: itu dapat membantu Anda mencegah serangan siber dan serangan fisik.
Seperti yang akan kita lihat, meskipun protokol menawarkan perlindungan privasi intrinsik tertentu, sangat penting untuk menggunakan alat tambahan untuk mengoptimalkan dan mempertahankan privasi ini.
Pelatihan ini dirancang sebagai kursus komprehensif dan generalis untuk memahami taruhan privasi pada Bitcoin. Setiap konsep teknis dibahas secara detail dan didukung oleh diagram penjelas. Tujuannya adalah untuk membuat pengetahuan dapat diakses oleh semua orang, bahkan untuk pengguna pemula dan menengah. Untuk para bitcoiner yang lebih berpengalaman, kami juga membahas konsep-konsep yang sangat teknis dan terkadang kurang dikenal sepanjang pelatihan ini untuk memperdalam pemahaman tentang setiap topik.

Tujuan dari pelatihan ini bukan untuk membuat Anda sepenuhnya anonim dalam penggunaan Bitcoin Anda, tetapi lebih kepada menyediakan Anda dengan alat-alat esensial untuk mengetahui bagaimana melindungi privasi Anda sesuai dengan tujuan pribadi Anda. Anda akan memiliki kebebasan untuk memilih dari konsep dan alat yang disajikan untuk mengembangkan strategi Anda sendiri, disesuaikan dengan tujuan dan kebutuhan spesifik Anda.

### Bagian 1: Definisi dan Konsep Kunci
Untuk memulai, kita akan bersama-sama mengulas prinsip-prinsip fundamental yang mengatur operasi Bitcoin, agar kemudian dapat dengan tenang mendekati konsep-konsep terkait privasi. Sangat penting untuk menguasai beberapa konsep dasar, seperti UTXOs, alamat penerima, atau skrip, sebelum dapat sepenuhnya memahami konsep-konsep yang akan kita bahas di bagian selanjutnya. Kami juga akan memperkenalkan model umum privasi Bitcoin, seperti yang dibayangkan oleh Satoshi Nakamoto, yang akan memungkinkan kita untuk memahami taruhan dan risiko yang terkait.
![BTC204](assets/en/11/1.webp)

### Bagian 2: Memahami Analisis Rantai dan Cara Melindungi Diri dari Itu

Di bagian kedua, kita mempelajari teknik yang digunakan oleh perusahaan analisis rantai untuk melacak aktivitas Anda di Bitcoin. Memahami metode ini sangat penting untuk meningkatkan perlindungan privasi Anda. Bagian ini bertujuan untuk memeriksa strategi penyerang untuk lebih memahami risiko dan meletakkan dasar untuk teknik yang akan kita pelajari di bagian selanjutnya. Kita akan menganalisis pola transaksi, heuristik internal dan eksternal, serta interpretasi yang masuk akal dari pola-pola ini. Selain komponen teoretis, kita akan belajar menggunakan block explorer untuk melakukan analisis rantai, melalui contoh dan latihan praktis.

![BTC204](assets/notext/11/2.webp)

### Bagian 3: Menguasai Praktik Terbaik untuk Melindungi Privasi Anda

Di bagian ketiga pelatihan kita, kita sampai pada inti masalah: praktek! Tujuannya adalah untuk menguasai semua praktik terbaik esensial yang harus menjadi refleks alami bagi setiap pengguna Bitcoin. Kita akan membahas penggunaan alamat baru, pelabelan, konsolidasi, penggunaan node penuh, serta metode KYC dan akuisisi. Tujuannya adalah untuk memberi Anda gambaran komprehensif tentang jebakan yang harus dihindari untuk menetapkan dasar yang kokoh dalam pencarian kita untuk perlindungan privasi. Untuk beberapa praktik ini, Anda akan diarahkan ke tutorial spesifik untuk mengimplementasikannya.

![BTC204](assets/en/11/3.webp)

### Bagian 4: Memahami Transaksi Coinjoin

Bagaimana kita bisa berbicara tentang privasi pada Bitcoin tanpa membahas coinjoins? Di bagian 4, Anda akan menemukan semua yang perlu Anda ketahui tentang metode pencampuran ini. Anda akan belajar apa itu coinjoin, sejarah dan tujuannya, serta berbagai jenis coinjoin yang ada. Akhirnya, untuk pengguna yang lebih berpengalaman, kita akan menemukan apa itu anonsets dan entropi, dan bagaimana menghitung indikator-indikator ini.

![BTC204](assets/en/11/4.webp)

### Bagian 5: Memahami Taruhan dari Teknik Privasi Lanjutan Lainnya
Pada bagian kelima, kami akan memberikan gambaran umum tentang semua teknik lain yang ada untuk melindungi privasi Anda di Bitcoin, selain dari coinjoin. Selama bertahun-tahun, para pengembang telah menunjukkan kreativitas yang luar biasa dalam merancang alat yang didedikasikan untuk privasi. Kami akan mengkaji semua metode ini, seperti payjoin, transaksi kolaboratif, Coin Swap, dan Atomic Swap, dengan menjelaskan operasi, tujuan, dan potensi kelemahan mereka.
Kami juga akan membahas privasi pada tingkat jaringan node dan penyebaran transaksi. Kami juga akan membahas berbagai protokol yang telah diusulkan selama bertahun-tahun untuk meningkatkan privasi pengguna di Bitcoin, termasuk protokol alamat statis.

![BTC204](assets/notext/11/5.webp)

# Definisi dan Konsep Kunci
<partId>b9bbbde3-34c0-4851-83e8-e2ffb029cf31</partId>

## Model UTXO Bitcoin
<chapterId>8d6b50c5-bf74-44f4-922b-25204991cb75</chapterId>

Bitcoin pada dasarnya adalah mata uang, tetapi apakah Anda tahu secara konkret bagaimana BTC direpresentasikan dalam protokol?

### UTXO Bitcoin: Apa Itu?

Dalam protokol Bitcoin, pengelolaan unit moneter berputar di sekitar model UTXO, singkatan dari "_Unspent Transaction Output_".

Model ini sangat berbeda dari sistem perbankan tradisional, yang mengandalkan mekanisme akun dan saldo untuk melacak aliran keuangan. Memang, dalam sistem perbankan, saldo individu dipertahankan dalam akun yang terikat pada identitas. Misalnya, ketika Anda membeli baguette dari seorang tukang roti, bank Anda hanya mendebit jumlah pembelian dari akun Anda, sehingga mengurangi saldo Anda, sementara akun tukang roti dikredit dengan jumlah yang sama, meningkatkan saldonya. Dalam sistem ini, tidak ada konsep tautan antara uang yang masuk ke akun Anda dan uang yang keluar darinya, selain dari catatan transaksi.

![BTC204](assets/en/21/1.webp)
Di Bitcoin, hal-hal bekerja secara berbeda. Konsep akun tidak ada, dan unit moneter tidak dikelola melalui saldo tetapi melalui UTXO. UTXO mewakili jumlah bitcoin tertentu yang belum dibelanjakan, sehingga membentuk "potongan bitcoin," yang bisa besar atau kecil. Misalnya, sebuah UTXO bisa bernilai `500 BTC` atau hanya `700 SATS`.
**> Pengingat:** Satoshi, sering disingkat sebagai sat, adalah unit terkecil dari Bitcoin, sebanding dengan sen dalam mata uang fiat.

```plaintext
1 BTC = 100,000,000 SATS
```

Secara teoritis, sebuah UTXO dapat mewakili nilai apa pun dalam bitcoin, mulai dari satu sat hingga maksimum teoritis sekitar 21 juta BTC. Namun, secara logis tidak mungkin untuk memiliki semua 21 juta bitcoin, dan ada ambang ekonomi lebih rendah yang disebut "debu," di bawahnya sebuah UTXO dianggap secara ekonomi tidak layak untuk dibelanjakan.

**> Tahukah Anda?** UTXO terbesar yang pernah dibuat di Bitcoin bernilai `500,000 BTC`. Itu dibuat oleh platform MtGox selama operasi konsolidasi pada November 2011: [29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf](https://mempool.space/fr/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)

### UTXO dan Kondisi Pengeluaran
UTXO adalah instrumen pertukaran pada Bitcoin. Setiap transaksi menghasilkan konsumsi UTXO sebagai input dan penciptaan UTXO baru sebagai output. Ketika sebuah transaksi dilakukan, UTXO yang digunakan sebagai input dianggap "terpakai," dan UTXO baru dihasilkan dan dialokasikan kepada penerima yang ditunjukkan dalam output transaksi. Dengan demikian, UTXO sederhananya mewakili output transaksi yang belum terpakai, dan oleh karena itu sejumlah bitcoin yang dimiliki oleh pengguna pada waktu tertentu.
![BTC204](assets/en/21/2.webp)
Semua UTXO diamankan oleh skrip yang mendefinisikan kondisi di bawah mana mereka dapat dihabiskan. Untuk mengonsumsi UTXO, pengguna harus menunjukkan kepada jaringan bahwa mereka memenuhi kondisi yang ditetapkan oleh skrip yang mengamankan UTXO tersebut. Umumnya, UTXO dilindungi oleh kunci publik (atau alamat penerima yang mewakili kunci publik ini). Untuk menghabiskan UTXO yang terkait dengan kunci publik ini, pengguna harus membuktikan bahwa mereka memegang kunci privat yang sesuai dengan menyediakan tanda tangan digital yang dibuat dengan kunci ini. Inilah sebabnya mengapa dikatakan bahwa dompet Bitcoin Anda sebenarnya tidak mengandung bitcoin, tetapi sebaliknya, ia menyimpan kunci privat Anda, yang pada gilirannya memberi Anda akses ke UTXO Anda dan, dengan perluasan, ke bitcoin yang mereka wakili.
![BTC204](assets/en/21/3.webp)

Mengingat konsep akun absen di Bitcoin, saldo dompet sederhananya sesuai dengan jumlah nilai semua UTXO yang dapat dihabiskan. Sebagai contoh, jika dompet Bitcoin Anda dapat menghabiskan 4 UTXO berikut:

```plaintext
- 2 BTC
- 8 BTC
- 5 BTC
- 2 BTC
```

Saldo total dompet Anda akan menjadi `17 BTC`.

![BTC204](assets/en/21/4.webp)

## Struktur transaksi Bitcoin
<chapterId>29d3aaab-de2e-4746-ab40-c9748898850c</chapterId>

### Input dan output dari sebuah transaksi

Transaksi Bitcoin adalah operasi yang dicatat di blockchain yang memungkinkan transfer kepemilikan bitcoin dari satu orang ke orang lain. Lebih spesifik lagi, karena kita berada pada model UTXO dan tidak ada akun, transaksi memenuhi kondisi pengeluaran yang mengamankan satu atau lebih UTXO, mengonsumsinya, dan secara setara menciptakan UTXO baru yang diberkahi dengan kondisi pengeluaran baru. Singkatnya, sebuah transaksi memindahkan bitcoin dari skrip yang puas ke skrip baru yang dimaksudkan untuk mengamankannya.

![BTC204](assets/en/22/1.webp)

Setiap transaksi Bitcoin dibuat dari satu atau lebih input dan satu atau lebih output. Input adalah UTXO yang dikonsumsi oleh transaksi untuk menghasilkan output. Output adalah UTXO baru yang akan dapat digunakan sebagai input untuk transaksi masa depan.

![BTC204](assets/en/22/2.webp)

**> Tahukah Anda?** Secara teoritis, sebuah transaksi bitcoin bisa memiliki jumlah input dan output yang tak terbatas. Hanya ukuran maksimum blok yang membatasi jumlah ini.
Setiap input dalam transaksi Bitcoin merujuk pada UTXO sebelumnya yang belum terpakai (Unspent Transaction Output). Untuk menggunakan UTXO sebagai input, pemegangnya harus menunjukkan bahwa mereka adalah pemilik sah dengan memvalidasi skrip yang terkait dengannya, yaitu, dengan memenuhi kondisi pengeluaran yang diberlakukan. Umumnya, ini melibatkan penyediaan tanda tangan digital yang diproduksi dengan kunci privat yang sesuai dengan kunci publik yang awalnya mengamankan UTXO tersebut. Skrip kemudian memverifikasi bahwa tanda tangan cocok dengan kunci publik yang digunakan saat menerima dana.
![BTC204](assets/en/22/3.webp)
Di sisi lain, setiap output menentukan jumlah bitcoin yang akan ditransfer, serta penerima. Yang terakhir ini didefinisikan oleh skrip baru yang, umumnya, mengunci UTXO yang baru dibuat dengan alamat penerima atau kunci publik baru.
Agar sebuah transaksi dianggap valid menurut aturan konsensus, total dari output harus kurang dari atau sama dengan total dari input. Dengan kata lain, jumlah UTXO baru yang dihasilkan oleh transaksi tidak boleh melebihi jumlah UTXO yang dikonsumsi sebagai input. Prinsip ini logis: jika Anda hanya memiliki jumlah `500,000 SATS`, Anda tidak dapat melakukan pembelian sebesar `700,000 SATS`.

### Perubahan dan Konsolidasi dalam Transaksi Bitcoin

Aksi dari transaksi Bitcoin pada UTXO dapat dibandingkan dengan meleburkan koin emas. Memang, sebuah UTXO tidak dapat dibagi, tetapi hanya dapat digabungkan. Ini berarti bahwa pengguna tidak dapat dengan mudah membagi UTXO yang mewakili jumlah bitcoin tertentu menjadi beberapa UTXO yang lebih kecil. Mereka harus mengkonsumsinya sepenuhnya dalam sebuah transaksi untuk menciptakan satu atau lebih UTXO baru dengan nilai-nilai sembarang di output, yang harus kurang dari atau sama dengan nilai awal.

Mekanisme ini serupa dengan koin emas. Bayangkan Anda memiliki koin 2 ons dan Anda ingin melakukan pembayaran 1 ons, dengan asumsi penjual tidak dapat memberi Anda kembalian. Anda perlu melebur koin Anda dan mencetak 2 koin baru masing-masing 1 ons.
Di Bitcoin, operasinya serupa. Mari kita bayangkan bahwa Alice memiliki UTXO sebesar `10,000 SATS` dan dia ingin membeli sebuah baguette seharga `4,000 SATS`. Alice akan melakukan transaksi dengan input 1 UTXO sebesar `10,000 SATS` yang akan dia konsumsi sepenuhnya, dan di output, dia akan menciptakan 2 UTXO dengan nilai `4,000 SATS` dan `6,000 SATS`. UTXO sebesar `4,000 SATS` akan dikirim ke tukang roti sebagai pembayaran untuk baguette, sementara UTXO sebesar `6,000 SATS` akan kembali ke Alice sebagai kembalian. UTXO yang kembali ke pengirim awal transaksi ini disebut "kembalian" dalam jargon Bitcoin.
![BTC204](assets/en/22/4.webp)

Sekarang bayangkan bahwa Alice tidak memiliki satu UTXO sebesar `10,000 SATS`, tetapi dua UTXO masing-masing sebesar `3,000 SATS`. Dalam situasi ini, tidak ada satupun UTXO individu yang cukup untuk menutupi `4,000 SATS` untuk baguette. Oleh karena itu, Alice harus menggunakan kedua UTXO sebesar `3,000 SATS` sebagai input untuk transaksinya secara bersamaan. Dengan cara ini, total jumlah input akan mencapai `6,000 SATS`, memungkinkan dia untuk menutupi pembayaran sebesar `4,000 SATS` ke tukang roti. Metode ini, yang melibatkan pengelompokan beberapa UTXO dalam input sebuah transaksi, sering disebut dengan istilah "konsolidasi".
![BTC204](assets/en/22/5.webp)

### Biaya Transaksi
Secara intuitif, seseorang mungkin berpikir bahwa biaya transaksi juga merupakan keluaran dari sebuah transaksi. Namun, pada kenyataannya, hal ini tidak demikian. Biaya dari sebuah transaksi merupakan perbedaan antara total dari input dan total dari output. Ini berarti bahwa, setelah menggunakan sebagian nilai dari input untuk menutupi output yang diinginkan dalam sebuah transaksi, sejumlah sum dari input tetap tidak terpakai. Sisa sum ini merupakan biaya transaksi.
```plaintext
Biaya = total input - total output
```

Mari kita kembali ke contoh Alice yang memiliki UTXO sebesar `10,000 SATS` dan ingin membeli sebuah baguette seharga `4,000 SATS`. Alice membuat sebuah transaksi dengan UTXO-nya sebesar `10,000 SATS` sebagai input. Kemudian dia menghasilkan sebuah output sebesar `4,000 SATS` yang ditujukan untuk pembayaran baguette kepada tukang roti. Untuk mendorong penambang agar memasukkan transaksinya ke dalam blok, Alice mengalokasikan `200 SATS` sebagai biaya. Dengan demikian, dia menciptakan output kedua, kembalian, yang akan kembali kepadanya, sejumlah `5,800 SATS`.

![BTC204](assets/en/22/6.webp)

Dengan menerapkan rumus biaya, kita memang melihat bahwa masih tersisa `200 SATS` untuk para penambang:
```plaintext
Biaya = total input - total output
Pengeluaran = 10,000 - (4,000 + 5,800)
Pengeluaran = 10,000 - 9,800
Pengeluaran = 200
```

Ketika seorang penambang berhasil memvalidasi sebuah blok, mereka diizinkan untuk mengumpulkan biaya-biaya ini untuk semua transaksi yang termasuk dalam blok mereka, melalui apa yang disebut transaksi "coinbase".

### Pembuatan UTXO pada Bitcoin

Jika Anda telah mengikuti paragraf sebelumnya dengan seksama, Anda sekarang tahu bahwa UTXO hanya dapat diciptakan dengan mengonsumsi UTXO lain yang sudah ada. Dengan demikian, koin pada Bitcoin membentuk rantai yang berkelanjutan. Namun, Anda mungkin bertanya-tanya bagaimana UTXO pertama dalam rantai ini muncul. Ini menimbulkan masalah serupa dengan ayam dan telur: darimana UTXO asli ini berasal?

Jawabannya terletak pada **transaksi coinbase**.

Coinbase adalah jenis transaksi Bitcoin yang spesifik, unik untuk setiap blok dan selalu yang pertama di dalamnya. Ini memungkinkan penambang yang menemukan bukti kerja yang valid untuk menerima hadiah blok mereka. Hadiah ini terdiri dari dua elemen: **subsidi blok** dan **biaya transaksi** yang telah kita bahas di bagian sebelumnya.

Fitur unik dari transaksi coinbase adalah bahwa ini adalah satu-satunya yang dapat menciptakan bitcoin dari ketiadaan, tanpa perlu mengonsumsi input untuk menghasilkan outputnya. Bitcoin yang baru diciptakan ini dapat disebut sebagai "UTXO asli".

![BTC204](assets/en/22/7.webp)

Bitcoin dari subsidi blok adalah BTC baru yang diciptakan dari ketiadaan, mengikuti jadwal penerbitan yang telah ditetapkan dalam aturan konsensus. Subsidi blok dibagi dua setiap 210,000 blok, yang kira-kira setiap empat tahun, dalam proses yang disebut "halving". Awalnya, 50 bitcoin diciptakan dengan setiap subsidi, tetapi jumlah ini telah berangsur-angsur berkurang; saat ini, jumlahnya adalah 3.125 bitcoin per blok.
Untuk bagian yang berkaitan dengan biaya transaksi, meskipun ini juga mewakili BTC yang baru diciptakan, mereka tidak boleh melebihi perbedaan antara total input dan output dari semua transaksi dalam sebuah blok. Seperti yang kita lihat sebelumnya, biaya ini mewakili bagian dari input yang tidak digunakan dalam output transaksi. Bagian ini secara teknis "hilang" selama transaksi, dan penambang memiliki hak untuk menciptakan kembali nilai ini dalam bentuk satu atau lebih UTXO baru. Ini, oleh karena itu, merupakan transfer nilai dari pengirim transaksi ke penambang yang menambahkannya ke blockchain.
**> Tahukah Anda?** Bitcoin yang dihasilkan oleh transaksi coinbase tunduk pada periode matang selama 100 blok di mana mereka tidak dapat dihabiskan oleh penambang. Aturan ini dimaksudkan untuk menghindari komplikasi terkait penggunaan bitcoin yang baru diciptakan pada rantai yang kemudian bisa menjadi usang.

### Implikasi dari Model UTXO

Pertama-tama, model UTXO secara langsung mempengaruhi biaya transaksi pada Bitcoin. Mengingat kapasitas setiap blok terbatas, penambang lebih memilih transaksi yang menawarkan biaya terbaik relatif terhadap ruang yang akan mereka tempati dalam blok. Memang, semakin banyak UTXO yang termasuk sebagai input dan output dalam sebuah transaksi, semakin berat transaksi tersebut, dan oleh karena itu, memerlukan biaya yang lebih tinggi. Ini adalah salah satu alasan mengapa seringkali ada upaya untuk mengurangi jumlah UTXO dalam dompet kita, yang juga dapat mempengaruhi privasi, topik yang akan kita gali secara detail dalam bagian ketiga dari pelatihan ini.

Selanjutnya, seperti yang disebutkan dalam bagian sebelumnya, koin pada Bitcoin pada dasarnya adalah rantai UTXO. Setiap transaksi dengan demikian menciptakan tautan antara UTXO masa lalu dan UTXO masa depan. UTXO oleh karena itu memungkinkan untuk pelacakan eksplisit jalur bitcoin dari penciptaannya hingga pengeluaran saat ini. Transparansi ini dapat dilihat secara positif, karena memungkinkan setiap pengguna untuk memastikan keaslian bitcoin yang diterima. Namun, juga pada prinsip pelacakan dan auditabilitas ini analisis rantai beristirahat, sebuah praktik yang bertujuan untuk mengkompromikan privasi Anda. Kami akan mempelajari praktik ini secara mendalam dalam bagian kedua dari pelatihan.

## Model Privasi Bitcoin
<chapterId>769d8963-3ed5-4094-b21d-9203c7d9e465</chapterId>

### Mata Uang: Keaslian, Integritas, dan Pengeluaran Ganda

Salah satu fungsi mata uang adalah untuk menyelesaikan masalah kebetulan ganda dari keinginan. Dalam sistem yang berbasis barter, melakukan pertukaran memerlukan tidak hanya menemukan individu yang menawarkan barang yang memenuhi kebutuhan saya, tetapi juga menyediakan mereka dengan barang bernilai setara yang memuaskan kebutuhan mereka sendiri. Menemukan keseimbangan ini terbukti menjadi kompleks.

![BTC204](assets/notext/23/1.webp)

Itulah mengapa kita beralih ke mata uang, yang memungkinkan untuk transfer nilai baik dalam ruang dan waktu.

![BTC204](assets/notext/23/2.webp)

Agar mata uang dapat menyelesaikan masalah ini, sangat penting bahwa pihak yang menyediakan barang atau jasa yakin akan kemampuan mereka untuk menghabiskan jumlah tersebut nanti. Dengan demikian, setiap individu rasional yang ingin menerima sepotong mata uang, baik digital maupun fisik, akan memastikan bahwa itu memenuhi dua kriteria fundamental:
- **Koin harus utuh dan asli;**
- **dan itu tidak boleh dihabiskan dua kali.**
Saat menggunakan mata uang fisik, karakteristik pertama adalah yang paling kompleks untuk ditegaskan. Sepanjang berbagai periode dalam sejarah, integritas koin logam seringkali dikompromikan oleh praktik seperti pemotongan atau pengeboran. Misalnya, selama zaman Romawi kuno, umum untuk warga negara mengikis tepi koin emas untuk mengumpulkan sedikit logam berharga, sambil tetap menyimpannya untuk transaksi masa depan. Nilai intrinsik koin tersebut berkurang, tetapi nilai nominalnya tetap sama. Inilah sebabnya mengapa kemudian dibuat alur pada tepi koin.

Keaslian juga merupakan karakteristik yang sulit untuk diverifikasi dengan media moneter fisik. Saat ini, teknik untuk memerangi pemalsuan semakin kompleks, memaksa pedagang untuk berinvestasi dalam sistem verifikasi yang mahal.

Di sisi lain, karena sifatnya, pengeluaran ganda bukanlah masalah untuk mata uang fisik. Jika saya memberi Anda uang kertas €10, itu secara tak terbalikkan meninggalkan kepemilikan saya untuk masuk ke milik Anda, secara alami mengecualikan kemungkinan menghabiskan unit moneter yang sama beberapa kali. Singkatnya, saya tidak akan dapat menghabiskan uang kertas €10 itu lagi.

![BTC204](assets/notext/23/3.webp)

Untuk mata uang digital, kesulitannya berbeda. Memastikan keaslian dan integritas koin seringkali lebih sederhana. Seperti yang kita lihat di bagian sebelumnya, model UTXO Bitcoin memungkinkan pelacakan koin kembali ke asalnya, dengan demikian memverifikasi bahwa memang diciptakan sesuai dengan aturan konsensus oleh penambang.

Namun, memastikan tidak adanya pengeluaran ganda lebih kompleks, karena barang digital pada dasarnya adalah informasi. Tidak seperti barang fisik, informasi tidak terbagi selama pertukaran tetapi berkembang biak dengan berlipat ganda. Misalnya, jika saya mengirimkan dokumen kepada Anda melalui email, maka dokumen tersebut menjadi duplikat. Di pihak Anda, Anda tidak dapat memverifikasi dengan pasti bahwa saya telah menghapus dokumen asli.

![BTC204](assets/notext/23/4.webp)

### Mencegah Pengeluaran Ganda pada Bitcoin

Satu-satunya cara untuk menghindari duplikasi barang digital adalah dengan mengetahui semua pertukaran dalam sistem. Dengan cara ini, seseorang dapat mengetahui siapa yang memiliki apa dan memperbarui kepemilikan semua orang berdasarkan transaksi yang dilakukan. Inilah yang dilakukan, misalnya, dengan uang giro dalam sistem perbankan. Ketika Anda membayar €10 kepada pedagang dengan kartu kredit, bank mencatat pertukaran ini dan memperbarui buku besar.
Di Bitcoin, pencegahan pengeluaran ganda dicapai dengan cara yang sama. Tujuannya adalah untuk mengonfirmasi ketiadaan transaksi yang telah menghabiskan koin yang bersangkutan. Jika koin-koin ini belum pernah digunakan, maka kita dapat yakin bahwa tidak akan terjadi pengeluaran ganda. Prinsip ini dijelaskan oleh Satoshi Nakamoto dalam White Paper dengan frase terkenal ini:

**"*Satu-satunya cara untuk mengonfirmasi ketiadaan transaksi adalah dengan mengetahui semua transaksi.*"**

Namun, tidak seperti model perbankan, tidak ada keinginan untuk harus mempercayai entitas pusat pada Bitcoin. Perlu bagi semua pengguna untuk dapat mengonfirmasi ketiadaan pengeluaran ganda ini, tanpa mengandalkan pihak ketiga. Dengan demikian, semua orang harus mengetahui semua transaksi Bitcoin. Inilah sebabnya mengapa transaksi Bitcoin disiarkan secara publik di semua node jaringan dan dicatat secara jelas di blockchain.

Tepatnya penyebaran informasi publik ini yang mempersulit perlindungan privasi di Bitcoin. Dalam sistem perbankan tradisional, secara teori, hanya lembaga keuangan yang mengetahui transaksi yang dilakukan. Di sisi lain, di Bitcoin, semua pengguna diberitahu tentang semua transaksi, melalui node masing-masing.

### Model privasi: sistem perbankan vs Bitcoin
Dalam sistem tradisional, rekening bank Anda terhubung dengan identitas Anda. Bankir dapat mengetahui rekening bank mana yang milik klien mana, dan transaksi apa saja yang terkait dengannya. Namun, aliran informasi ini terputus antara bank dan domain publik. Dengan kata lain, tidak mungkin untuk mengetahui saldo dan transaksi dari rekening bank yang milik orang lain. Hanya bank yang memiliki akses ke informasi ini.

Sebagai contoh, bankir Anda tahu bahwa Anda membeli baguette setiap pagi di toko roti lingkungan, tetapi tetangga Anda tidak mengetahui transaksi ini. Dengan demikian, aliran informasi dapat diakses oleh pihak-pihak yang bersangkutan, terutama bank, tetapi tetap tidak dapat diakses oleh pihak luar.

Karena kendala penyebaran publik transaksi yang kita lihat di bagian sebelumnya, model privasi Bitcoin tidak dapat mengikuti model sistem perbankan. Dalam kasus Bitcoin, karena aliran informasi tidak dapat diputus antara transaksi dan domain publik, **model privasi bergantung pada pemisahan antara identitas pengguna dan transaksi** itu sendiri.

Sebagai contoh, jika Anda membeli baguette dari tukang roti dengan membayar dalam BTC, tetangga Anda, yang memiliki full node mereka sendiri, dapat melihat transaksi Anda berlangsung, sama seperti mereka dapat melihat semua transaksi lain dalam sistem. Namun, jika prinsip-prinsip privasi dihormati, mereka seharusnya tidak dapat menghubungkan transaksi spesifik ini dengan identitas Anda.
![BTC204](assets/en/23/9.webp)

Namun, karena transaksi Bitcoin dibuat publik, masih menjadi mungkin untuk menetapkan tautan antara mereka untuk menarik informasi tentang pihak-pihak yang terlibat. Kegiatan ini bahkan merupakan spesialisasi tersendiri yang disebut "analisis rantai". Di bagian selanjutnya dari pelatihan, saya mengundang Anda untuk menjelajahi dasar-dasar analisis rantai untuk memahami bagaimana bitcoin Anda dilacak dan untuk mengetahui cara lebih baik melindungi diri dari hal itu.

# Memahami Analisis Rantai dan Cara Melindungi Diri
<partId>4739371e-9fef-45b0-bcaa-b7a4df6b4470</partId>

## Apa itu Analisis Rantai pada Bitcoin?
<chapterId>7d198ba6-4af2-4f24-86cb-3c79cb25627e</chapterId>

### Definisi dan Operasi

Analisis rantai adalah praktik yang mencakup semua metode yang digunakan untuk melacak aliran bitcoin di blockchain. Umumnya, analisis rantai bergantung pada pengamatan karakteristik dalam sampel transaksi sebelumnya. Kemudian melibatkan identifikasi karakteristik yang sama dalam transaksi yang ingin dianalisis, dan menarik interpretasi yang masuk akal. Metode pemecahan masalah dari pendekatan praktis, untuk menemukan solusi yang cukup baik, inilah yang disebut "heuristik".

Untuk menyederhanakan, analisis rantai dilakukan dalam tiga langkah utama:
1. **Mengamati blockchain;**
2. **Mengidentifikasi karakteristik yang diketahui;**
3. **Menarik hipotesis.**

![BTC204](assets/en/31/1.webp)

Analisis rantai dapat dilakukan oleh siapa saja. Cukup dengan memiliki akses ke informasi publik blockchain melalui full node untuk mengamati pergerakan transaksi dan membuat hipotesis. Ada juga alat gratis yang memfasilitasi analisis ini, seperti situs web [OXT.me](https://oxt.me/) yang akan kita jelajahi secara detail di dua bab terakhir bagian ini. Namun, risiko utama terhadap privasi berasal dari perusahaan yang berspesialisasi dalam analisis rantai. Perusahaan-perusahaan ini telah membawa analisis rantai ke skala industri dan menjual layanan mereka ke institusi keuangan atau pemerintah. Di antara perusahaan-perusahaan ini, Chainalysis mungkin adalah yang paling terkenal.

### Tujuan Analisis Rantai
Salah satu tujuan dari analisis rantai adalah untuk mengelompokkan berbagai aktivitas pada Bitcoin guna menentukan keunikan pengguna yang melakukannya. Selanjutnya, akan dimungkinkan untuk mencoba menghubungkan kumpulan aktivitas ini dengan identitas nyata.

Ingatlah bab sebelumnya. Saya menjelaskan mengapa model privasi Bitcoin awalnya bergantung pada pemisahan identitas pengguna dari transaksi mereka. Oleh karena itu, akan tergoda untuk berpikir bahwa analisis rantai tidak perlu, karena meskipun seseorang berhasil mengelompokkan aktivitas onchain, mereka tidak dapat dikaitkan dengan identitas nyata.

Secara teoritis, pernyataan ini akurat. Di bagian pertama pelatihan ini, kita melihat bahwa pasangan kunci kriptografi digunakan untuk menetapkan kondisi pada UTXO. Pada dasarnya, pasangan kunci ini tidak mengungkapkan informasi apa pun tentang identitas pemegangnya. Jadi, meskipun seseorang berhasil mengelompokkan aktivitas yang terkait dengan pasangan kunci yang berbeda, ini tidak memberi tahu kita apa pun tentang entitas di balik aktivitas tersebut.

Namun, realitas praktis jauh lebih kompleks. Ada banyak perilaku yang berisiko menghubungkan identitas nyata dengan aktivitas onchain. Dalam analisis, ini disebut sebagai titik masuk, dan ada banyak di antaranya.

Yang paling umum, tentu saja, adalah KYC (*Know Your Customer*). Jika Anda menarik bitcoin Anda dari platform yang diatur ke salah satu alamat penerima pribadi Anda, maka beberapa orang dapat menghubungkan identitas Anda dengan alamat ini. Lebih luas, titik masuk dapat berupa bentuk interaksi apa pun antara kehidupan nyata Anda dan transaksi Bitcoin. Misalnya, jika Anda mempublikasikan alamat penerima di jejaring sosial Anda, ini bisa menjadi titik masuk untuk analisis. Jika Anda melakukan pembayaran dalam bitcoin kepada tukang roti Anda, mereka dapat mengaitkan wajah Anda (yang merupakan bagian dari identitas Anda) dengan alamat Bitcoin.

Titik masuk ini hampir tidak terhindarkan dalam penggunaan Bitcoin. Meskipun seseorang dapat berusaha membatasi lingkupnya, mereka akan tetap ada. Itulah mengapa sangat penting untuk menggabungkan metode yang bertujuan untuk menjaga privasi Anda. Meskipun mempertahankan pemisahan antara identitas nyata Anda dan transaksi Anda adalah pendekatan yang menarik, itu tetap tidak cukup hari ini. Memang, jika semua aktivitas onchain Anda dapat dikelompokkan, maka titik masuk yang paling kecil kemungkinan akan membahayakan satu-satunya lapisan privasi yang telah Anda bangun.

### Membela Diri Terhadap Analisis Rantai
Dengan demikian, juga perlu untuk dapat menghadapi analisis blockchain dalam penggunaan Bitcoin kita. Dengan cara ini, kita dapat meminimalkan agregasi aktivitas kita dan membatasi dampak titik masuk pada privasi kita.

Memang, untuk lebih baik melawan analisis blockchain, pendekatan apa yang lebih baik selain mempelajari metode yang digunakan dalam analisis blockchain? Jika Anda ingin tahu cara meningkatkan privasi Anda pada Bitcoin, Anda harus memahami metode-metode ini. Ini akan memungkinkan Anda untuk lebih memahami teknik seperti [coinjoin](https://planb.network/fr/tutorials/privacy/coinjoin-samourai-wallet) atau [payjoin](https://planb.network/fr/tutorials/privacy/payjoin) (teknik yang akan kita pelajari di bagian terakhir pelatihan), dan untuk mengurangi kesalahan yang mungkin Anda buat.
Dalam hal ini, kita dapat membuat analogi dengan kriptografi dan kriptoanalisis. Seorang kriptografer yang baik pertama-tama adalah seorang kriptoanalis yang baik. Untuk membayangkan algoritma enkripsi baru, seseorang harus tahu serangan apa yang akan dihadapinya, dan juga mempelajari mengapa algoritma sebelumnya dapat dipecahkan. Prinsip yang sama berlaku untuk privasi pada Bitcoin. Memahami metode analisis blockchain adalah kunci untuk melindungi diri dari hal itu. Itulah mengapa saya mengusulkan sebuah bagian lengkap tentang analisis blockchain dalam pelatihan ini.

### Metode Analisis Blockchain

Penting untuk dipahami bahwa analisis blockchain bukanlah ilmu pasti. Ini bergantung pada heuristik yang berasal dari pengamatan sebelumnya atau interpretasi logis. Aturan-aturan ini memungkinkan hasil yang cukup dapat diandalkan, namun tidak pernah dengan presisi absolut. Dengan kata lain, **analisis blockchain selalu melibatkan dimensi probabilitas dalam kesimpulan yang dikeluarkan**. Misalnya, mungkin dapat diperkirakan dengan lebih atau kurang kepastian bahwa dua alamat milik entitas yang sama, namun kepastian total selalu di luar jangkauan.

Seluruh tujuan analisis blockchain terletak tepatnya dalam agregasi berbagai heuristik untuk meminimalkan risiko kesalahan. Ini, dalam suatu cara, adalah akumulasi bukti yang memungkinkan kita mendekati realitas lebih dekat.

Heuristik terkenal ini dapat dikelompokkan ke dalam kategori yang berbeda yang akan kita rinci bersama:
- **Pola Transaksi (atau model transaksi);**
- **Heuristik internal terhadap transaksi;**
- **Heuristik eksternal terhadap transaksi.**

### Satoshi Nakamoto dan Analisis Blockchain
Perlu dicatat bahwa dua heuristik pertama untuk analisis rantai ditemukan oleh Satoshi Nakamoto sendiri. Dia membahasnya dalam bagian 10 dari Bitcoin White Paper. Ini adalah:
- Heuristik Kepemilikan Input Bersama (CIOH);
- dan penggunaan ulang alamat.

![BTC204](assets/notext/31/6.webp)

Sumber: S. Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System", https://bitcoin.org/bitcoin.pdf, 2009.

Dalam bab-bab berikutnya, kita akan menjelajahi apa yang terdiri dari ini, tetapi sudah menarik untuk dicatat bahwa dua heuristik ini masih mempertahankan kedudukan terkemuka dalam analisis rantai saat ini.

## Pola Transaksi
<chapterId>d365a101-2d37-46a5-bfb9-3c51e37bf96b</chapterId>

Pola transaksi hanyalah sebuah model atau struktur keseluruhan dari transaksi tipikal yang dapat ditemukan di blockchain, yang interpretasinya kemungkinan diketahui. Saat mempelajari pola, kita akan fokus pada satu transaksi yang akan kita analisis secara tingkat tinggi.

Dengan kata lain, kita hanya akan melihat jumlah UTXO dalam input dan jumlah UTXO dalam output, tanpa menghabiskan waktu pada detail yang lebih spesifik atau lingkungan transaksi. Dari model yang diamati, kita akan dapat menginterpretasikan sifat dari transaksi. Kemudian kita akan mencari karakteristik dalam strukturnya dan mendapatkan sebuah interpretasi.

![BTC204](assets/en/32/01.webp)

Dalam bagian ini, kita akan bersama-sama menemukan model transaksi utama yang dapat ditemui dalam analisis rantai, dan untuk setiap model, saya akan memberikan interpretasi yang kemungkinan dari struktur ini, bersama dengan contoh konkret.

### Pengiriman Sederhana (atau Pembayaran Sederhana)

Kita mulai dengan pola yang sangat luas, karena ini adalah yang muncul dalam sebagian besar pembayaran bitcoin. Model pembayaran sederhana ditandai dengan konsumsi satu atau lebih UTXO dalam input dan produksi 2 UTXO dalam output. Model ini akan terlihat seperti ini:

![BTC204](assets/en/32/02.webp)
Ketika kita melihat struktur transaksi ini di blockchain, kita sudah dapat menarik sebuah interpretasi. Seperti namanya, model ini menunjukkan bahwa kita berada dalam kehadiran transaksi pengiriman atau pembayaran. Pengguna telah menggunakan UTXO milik mereka sendiri dalam input untuk memenuhi output sebuah UTXO pembayaran dan sebuah UTXO kembalian (uang dikembalikan ke pengguna yang sama).
Oleh karena itu, kita tahu bahwa pengguna yang diamati kemungkinan besar tidak lagi memiliki salah satu dari dua UTXO di output (yang pembayaran), tetapi mereka masih memiliki UTXO lainnya (yang kembalian).
Saat ini, mustahil bagi kita untuk menentukan output mana yang mewakili UTXO mana, karena ini bukan tujuan dari studi pola. Kita akan mencapai ini dengan mengandalkan heuristik yang akan kita pelajari di bagian selanjutnya. Pada tahap ini, tujuan kita terbatas pada mengidentifikasi sifat dari transaksi yang bersangkutan, yang dalam hal ini, adalah pengiriman sederhana.

Sebagai contoh, berikut ini adalah transaksi Bitcoin yang mengadopsi pola pengiriman sederhana:

```plaintext
b6cc79f45fd2d7669ff94db5cb14c45f1f879ea0ba4c6e3d16ad53a18c34b769
```

![BTC204](assets/en/32/03.webp)

Sumber: [Mempool.space](https://mempool.space/fr/tx/b6cc79f45fd2d7669ff94db5cb14c45f1f879ea0ba4c6e3d16ad53a18c34b769)

Setelah contoh pertama ini, Anda seharusnya memiliki pemahaman yang lebih baik tentang apa artinya mempelajari "model transaksi". Kita memeriksa sebuah transaksi hanya dengan fokus pada strukturnya, tanpa memperhitungkan lingkungannya atau detail spesifik dari transaksi tersebut. Kita mengamatinya hanya secara global pada langkah pertama ini.

Sekarang Anda mengerti apa itu pola, mari kita lanjutkan ke model-model lain yang ada.

### Sweeping

Model kedua ini ditandai dengan konsumsi satu UTXO sebagai input dan produksi satu UTXO sebagai output.

![BTC204](assets/en/32/04.webp)

Interpretasi dari model ini adalah bahwa kita berada dalam kehadiran transfer diri. Pengguna telah mentransfer bitcoinnya kepada dirinya sendiri, ke alamat lain yang dimilikinya. Karena tidak ada perubahan dalam transaksi, sangat tidak mungkin kita berada dalam kehadiran pembayaran. Memang, ketika pembayaran dilakukan, hampir mustahil bagi pembayar untuk memiliki UTXO yang tepat sesuai dengan jumlah yang dibutuhkan oleh penjual, ditambah biaya transaksi. Umumnya, pembayar oleh karena itu dipaksa untuk menghasilkan output kembalian.

Kemudian kita tahu bahwa pengguna yang diamati kemungkinan masih memiliki UTXO ini. Dalam konteks analisis rantai, jika kita tahu bahwa UTXO yang digunakan sebagai input dalam transaksi milik Alice, kita dapat berasumsi bahwa UTXO di output juga miliknya. Yang akan menjadi menarik nantinya adalah menemukan heuristik internal untuk transaksi yang dapat memperkuat asumsi ini (kita akan mempelajari heuristik ini di bab 3.3).

Sebagai contoh, berikut ini adalah transaksi Bitcoin yang mengadopsi pola sweeping:

```plaintext
35f1072a0fda5ae106efb4fda871ab40e1f8023c6c47f396441ad4b995ea693d
```

![BTC204](assets/en/32/05.webp)
Sumber: [Mempool.space](https://mempool.space/fr/tx/35f1072a0fda5ae106efb4fda871ab40e1f8023c6c47f396441ad4b995ea693d)Namun, jenis pola ini juga dapat mengungkapkan transfer diri ke akun platform pertukaran mata uang kripto. Ini akan menjadi studi alamat yang dikenal dan konteks transaksi yang akan memungkinkan kita untuk mengetahui apakah ini adalah pembersihan ke dompet penyimpanan sendiri atau penarikan ke platform. Memang, alamat platform pertukaran sering kali mudah diidentifikasi.

Mari kita kembali ke contoh Alice: jika pembersihan mengarah ke alamat yang dikenal dari platform (seperti Binance, misalnya), ini dapat berarti bahwa bitcoin dipindahkan keluar dari kepemilikan langsung Alice, mungkin dengan niat untuk menjualnya atau menyimpannya di platform ini. Di sisi lain, jika alamat tujuan tidak dikenal, wajar untuk mengasumsikan bahwa itu hanyalah dompet lain yang masih milik Alice. Namun, jenis studi ini lebih masuk ke dalam kategori heuristik dan bukan studi pola.

### Konsolidasi

Model ini ditandai dengan konsumsi beberapa UTXO sebagai input dan produksi satu UTXO sebagai output.

![BTC204](assets/en/32/06.webp)

Interpretasi dari model ini adalah bahwa kita berada dalam kehadiran konsolidasi. Ini adalah praktik umum di antara pengguna Bitcoin, bertujuan untuk menggabungkan beberapa UTXO dalam antisipasi kemungkinan peningkatan biaya transaksi. Dengan melakukan operasi ini selama periode ketika biaya rendah, dimungkinkan untuk menghemat biaya di masa depan. Kita akan membahas lebih lanjut tentang praktik ini di bab 4.3.

Kita dapat menyimpulkan bahwa pengguna di balik model transaksi ini kemungkinan besar memiliki semua UTXO dalam input dan masih memiliki UTXO dalam output. Ini pasti sebuah transfer diri.

Sama seperti pembersihan, jenis pola ini juga dapat mengungkapkan transfer diri ke akun platform pertukaran. Ini akan menjadi studi alamat yang dikenal dan konteks transaksi yang akan memungkinkan kita untuk mengetahui apakah ini konsolidasi ke dompet penyimpanan sendiri atau penarikan ke platform.

Sebagai contoh, berikut adalah transaksi Bitcoin yang mengadopsi pola konsolidasi:

```plaintext
77c16914211e237a9bd51a7ce0b1a7368631caed515fe51b081d220590589e94
```

![BTC204](assets/en/32/07.webp)

Sumber: [Mempool.space](https://mempool.space/fr/tx/77c16914211e237a9bd51a7ce0b1a7368631caed515fe51b081d220590589e94)
Dalam konteks analisis rantai, model ini dapat mengungkapkan banyak informasi. Misalnya, jika kita tahu bahwa salah satu input milik Alice, kita dapat mengasumsikan bahwa semua input lain dan output dari transaksi ini miliknya juga. Asumsi ini kemudian akan memungkinkan kita untuk melacak kembali melalui rantai transaksi sebelumnya untuk menemukan dan menganalisis transaksi lain yang kemungkinan terkait dengan Alice.
![BTC204](assets/en/32/08.webp)

### Pengeluaran Berkelompok

Model ini ditandai dengan konsumsi beberapa UTXO sebagai input (seringkali hanya satu) dan produksi banyak UTXO sebagai output.

![BTC204](assets/en/32/09.webp)
Interpretasi dari model ini adalah bahwa kita berada dalam kehadiran pengeluaran yang dikelompokkan. Ini adalah praktik yang kemungkinan besar mengungkapkan aktivitas ekonomi yang signifikan, seperti platform pertukaran, misalnya. Pengeluaran yang dikelompokkan memungkinkan entitas-entitas ini untuk menghemat biaya dengan mengkonsolidasikan pengeluaran mereka ke dalam satu transaksi.
Kita dapat menyimpulkan dari model ini bahwa input UTXO berasal dari sebuah perusahaan dengan aktivitas ekonomi yang signifikan dan bahwa output UTXO akan tersebar. Banyak di antaranya akan menjadi milik klien perusahaan yang telah menarik bitcoin dari platform. Lainnya mungkin menuju ke perusahaan mitra. Akhirnya, pasti akan ada satu atau lebih pertukaran yang kembali ke perusahaan penerbit.

Sebagai contoh, berikut ini adalah transaksi Bitcoin yang mengadopsi pola pengeluaran yang dikelompokkan (kemungkinan, ini adalah transaksi yang dikeluarkan oleh platform Bybit):

```plaintext
8a7288758b6e5d550897beedd13c70bcbaba8709af01a7dbcc1f574b89176b43
```

![BTC204](assets/en/32/10.webp)

Sumber: [Mempool.space](https://mempool.space/fr/tx/8a7288758b6e5d550897beedd13c70bcbaba8709af01a7dbcc1f574b89176b43)

### Transaksi Spesifik Protokol

Di antara pola transaksi, kita juga dapat mengidentifikasi model yang mengungkapkan penggunaan protokol spesifik. Sebagai contoh, Whirlpool coinjoins (yang akan kita bahas di bagian 5) akan memiliki struktur yang mudah diidentifikasi yang memungkinkan mereka untuk dibedakan dari transaksi tradisional lainnya.

![BTC204](assets/en/32/11.webp)

Analisis dari pola ini menyarankan bahwa kita kemungkinan berada dalam kehadiran transaksi kolaboratif. Juga mungkin untuk mengamati coinjoin. Jika hipotesis terakhir ini terbukti akurat, maka jumlah output dapat memberi kita perkiraan kasar tentang jumlah peserta dalam coinjoin.

Sebagai contoh, berikut ini adalah transaksi Bitcoin yang mengadopsi pola tipe transaksi kolaboratif coinjoin:

```plaintext
00601af905bede31086d9b1b79ee8399bd60c97e9c5bba197bdebeee028b9bea
```

![BTC204](assets/en/32/12.webp)

Sumber: [Mempool.space](https://mempool.space/fr/tx/00601af905bede31086d9b1b79ee8399bd60c97e9c5bba197bdebeee028b9bea)

Ada banyak protokol lain yang memiliki struktur spesifik mereka sendiri. Dengan demikian, kita bisa membedakan transaksi tipe Wabisabi, transaksi Stamps, atau bahkan Runes, misalnya.

Berkat pola transaksi ini, kita sudah dapat menafsirkan sejumlah informasi tentang transaksi tertentu. Namun, struktur transaksi bukanlah satu-satunya sumber informasi untuk analisis. Kita juga dapat mempelajari detailnya. Detail-detail ini, internal untuk sebuah transaksi, adalah apa yang saya suka sebut sebagai "heuristik internal," dan kita akan mempelajarinya di bab berikutnya.

## Heuristik Internal
<chapterId>c54b5abe-872f-40f4-a0d0-c59faff228ba</chapterId>

Heuristik internal adalah karakteristik spesifik yang diidentifikasi dalam sebuah transaksi itu sendiri, tanpa perlu memeriksa lingkungannya, yang memungkinkan kita untuk membuat deduksi. Tidak seperti pola yang berfokus pada struktur keseluruhan transaksi pada tingkat tinggi, heuristik internal didasarkan pada kumpulan data yang dapat diekstrak. Ini meliputi:
- Jumlah UTXO yang berbeda, baik yang masuk maupun yang keluar;
- Semua hal yang berkaitan dengan skrip: alamat penerima, versioning, locktimes...

Secara umum, jenis heuristik ini akan memungkinkan kita untuk mengidentifikasi perubahan dalam transaksi tertentu. Dengan melakukan ini, kita kemudian dapat melanjutkan untuk melacak entitas melalui beberapa transaksi yang berbeda. Memang, jika kita mengidentifikasi UTXO yang dimiliki oleh pengguna yang ingin kita ikuti, sangat penting untuk menentukan, ketika mereka melakukan transaksi, output mana yang ditransfer ke pengguna lain dan output mana yang mewakili perubahan, sehingga tetap dalam kepemilikan mereka.

![BTC204](assets/en/33/01.webp)

Sekali lagi, saya ingatkan bahwa heuristik ini tidak sepenuhnya akurat. Diambil secara individu, mereka hanya memungkinkan kita untuk mengidentifikasi skenario yang masuk akal. Adalah akumulasi dari beberapa heuristik yang membantu mengurangi ketidakpastian, tanpa pernah sepenuhnya menghilangkannya.

### Kesamaan Internal

Heuristik ini melibatkan studi tentang kesamaan antara input dan output dari transaksi yang sama. Jika kita mengamati karakteristik yang sama pada input dan hanya pada salah satu output dari transaksi, maka kemungkinan output tersebut merupakan perubahan.

Karakteristik yang paling jelas adalah penggunaan kembali alamat penerima dalam transaksi yang sama.

![BTC204](assets/en/33/02.webp)
Heuristik ini meninggalkan sedikit ruang untuk keraguan. Kecuali kunci pribadi seseorang telah diretas, alamat penerima yang sama tidak dapat dihindari mengungkapkan aktivitas pengguna tunggal. Interpretasi yang mengikuti adalah bahwa perubahan dari transaksi adalah output dengan alamat yang sama seperti input. Ini memungkinkan untuk pelacakan terus menerus individu berdasarkan perubahan ini.
Sebagai contoh, berikut ini adalah transaksi di mana heuristik ini dapat diterapkan dengan wajar:

```plaintext
54364146665bfc453a55eae4bfb8fdf7c721d02cb96aadc480c8b16bdeb8d6d0
```

![BTC204](assets/notext/33/03.webp)

Sumber: [Mempool.space](https://mempool.space/tx/54364146665bfc453a55eae4bfb8fdf7c721d02cb96aadc480c8b16bdeb8d6d0)

Kesamaan antara input dan output tidak berhenti pada penggunaan kembali alamat. Kesamaan dalam penggunaan skrip dapat memungkinkan penerapan heuristik. Sebagai contoh, kadang-kadang versi yang sama antara input dan salah satu output dari transaksi dapat diamati.

![BTC204](assets/en/33/04.webp)

Dalam diagram ini, kita dapat melihat bahwa input No. 0 membuka skrip P2WPKH (SegWit V0 yang dimulai dengan `bc1q`). Output No. 0 menggunakan jenis skrip yang sama. Namun, output No. 1 menggunakan skrip P2TR (SegWit V1 yang dimulai dengan `bc1p`). Interpretasi dari karakteristik ini adalah kemungkinan bahwa alamat dengan versioning yang sama sebagai input adalah alamat perubahan. Oleh karena itu, masih akan dimiliki oleh pengguna yang sama.

Berikut ini adalah transaksi di mana heuristik ini dapat diterapkan dengan wajar:

```plaintext
db07516288771ce5d0a06b275962ec4af1b74500739f168e5800cbcb0e9dd578
```

![BTC204](assets/notext/33/05.webp)

Sumber: [Mempool.space](https://mempool.space/tx/db07516288771ce5d0a06b275962ec4af1b74500739f168e5800cbcb0e9dd578)
Dalam kasus ini, kita dapat melihat bahwa input No. 0 dan output No. 1 menggunakan skrip P2WPKH (SegWit V0), sementara output No. 0 menggunakan jenis skrip yang berbeda, P2PKH (Legacy). Pada awal tahun 2010-an, heuristik ini berdasarkan versi skrip relatif sedikit berguna karena keterbatasan jenis skrip yang tersedia. Namun, seiring waktu dan dengan pembaruan berturut-turut pada Bitcoin, berbagai jenis skrip telah diperkenalkan. Heuristik ini menjadi semakin relevan karena, dengan beragamnya jenis skrip, pengguna dibagi menjadi kelompok-kelompok yang lebih kecil, sehingga meningkatkan peluang penerapan heuristik penggunaan versi internal ini. Untuk alasan ini, hanya dari perspektif privasi, disarankan untuk memilih jenis skrip yang paling umum. Sebagai contoh, saat saya menulis baris ini, skrip Taproot (`bc1p`) kurang sering digunakan daripada skrip SegWit V0 (`bc1q`). Meskipun yang pertama menawarkan manfaat ekonomi dan privasi dalam konteks tertentu, untuk penggunaan tanda tangan tunggal yang lebih tradisional, mungkin bijaksana untuk tetap menggunakan standar lama untuk alasan privasi, sampai standar baru lebih luas diadopsi.

### Pembayaran Nomor Bulat

Heuristik internal lain yang dapat membantu kita mengidentifikasi perubahan adalah pembayaran nomor bulat. Umumnya, ketika dihadapkan pada pola pembayaran sederhana (1 input dan 2 output), jika salah satu output menghabiskan jumlah bulat, maka itu mewakili pembayaran.

![BTC204](assets/en/33/06.webp)

Dengan eliminasi, jika satu output mewakili pembayaran, output lainnya mewakili kembalian. Oleh karena itu, dapat disimpulkan bahwa kemungkinan pengguna yang memasukkan transaksi masih memiliki output yang diidentifikasi sebagai kembalian.

Perlu dicatat bahwa heuristik ini tidak selalu dapat diterapkan, karena mayoritas pembayaran masih dilakukan dalam unit mata uang fiat. Memang, ketika seorang pedagang di Prancis menerima bitcoin, umumnya, mereka tidak menampilkan harga stabil dalam sats. Mereka lebih memilih konversi antara harga dalam euro dan jumlah bitcoin yang harus dibayar. Oleh karena itu, seharusnya tidak ada jumlah bulat dalam output transaksi.

Namun demikian, seorang analis dapat mencoba melakukan konversi ini dengan mempertimbangkan nilai tukar yang berlaku saat transaksi disiarkan di jaringan. Mari kita ambil contoh transaksi dengan input `97,552 sats` dan dua output, satu `31,085 sats` dan yang lainnya `64,152 sats`. Sekilas, transaksi ini tampak tidak melibatkan jumlah bulat. Namun, dengan menerapkan nilai tukar €64,339 pada saat transaksi, kita mendapatkan konversi dalam euro sebagai berikut:
- Input sebesar €62.76;
- Output sebesar €20;
- Output sebesar €41.27.
Setelah dikonversi ke mata uang fiat, transaksi ini memungkinkan penerapan heuristik pembayaran jumlah bulat. Output sebesar €20 kemungkinan ditujukan untuk seorang pedagang, atau setidaknya berganti kepemilikan. Dengan deduksi, output sebesar €41.27 kemungkinan tetap dalam kepemilikan pengguna asli.
![BTC204](assets/en/33/07.webp)

Jika suatu hari, Bitcoin menjadi satuan akun yang disukai dalam transaksi kita, heuristik ini bisa menjadi lebih berguna untuk analisis.

Sebagai contoh, berikut adalah transaksi di mana heuristik ini kemungkinan dapat diterapkan:

```plaintext
2bcb42fab7fba17ac1b176060e7d7d7730a7b807d470815f5034d52e96d2828a
```

![BTC204](assets/notext/33/08.webp)
Sumber: [Mempool.space](https://mempool.space/tx/2bcb42fab7fba17ac1b176060e7d7d7730a7b807d470815f5034d52e96d2828a)
### Output Terbesar

Ketika celah yang cukup besar terlihat antara dua output transaksi dalam model pembayaran sederhana, dapat diperkirakan bahwa output yang lebih besar kemungkinan adalah kembalian.

![BTC204](assets/en/33/09.webp)

Heuristik output terbesar ini mungkin adalah yang paling tidak tepat dari semuanya. Jika diidentifikasi sendirian, ia cukup lemah. Namun, karakteristik ini dapat digabungkan dengan heuristik lain untuk mengurangi ketidakpastian interpretasi kita.

Misalnya, jika kita memeriksa sebuah transaksi yang menampilkan output dengan jumlah bulat dan output lain dengan jumlah yang lebih besar, penerapan bersama heuristik pembayaran bulat dan yang menyangkut output terbesar memungkinkan kita untuk mengurangi tingkat ketidakpastian kita.

Misalnya, berikut ini adalah transaksi di mana heuristik ini kemungkinan dapat diterapkan:

```plaintext
b79d8f8e4756d34bbb26c659ab88314c220834c7a8b781c047a3916b56d14dcf
```

![BTC204](assets/notext/33/10.webp)

Sumber: [Mempool.space](https://mempool.space/tx/b79d8f8e4756d34bbb26c659ab88314c220834c7a8b781c047a3916b56d14dcf)

## Heuristik Eksternal
<chapterId>4a170e3b-200d-431a-8285-18a23ff617ba</chapterId>

Studi tentang heuristik eksternal melibatkan analisis kesamaan, pola, dan karakteristik dari elemen-elemen tertentu yang tidak inheren pada transaksi itu sendiri. Dengan kata lain, jika sebelumnya kita membatasi diri pada mengeksploitasi elemen intrinsik transaksi dengan heuristik internal, sekarang kita memperluas bidang analisis kita ke lingkungan transaksi berkat heuristik eksternal.

### Penggunaan Ulang Alamat

Ini adalah salah satu heuristik yang paling dikenal di antara para penggemar Bitcoin. Penggunaan ulang alamat memungkinkan untuk menetapkan kaitan antara transaksi yang berbeda dan UTXO yang berbeda. Hal ini diamati ketika sebuah alamat penerima Bitcoin digunakan beberapa kali.

Dengan demikian, dimungkinkan untuk mengeksploitasi penggunaan ulang alamat dalam transaksi yang sama sebagai heuristik internal untuk mengidentifikasi kembalian (seperti yang kita lihat di bab sebelumnya). Namun, penggunaan ulang alamat juga dapat berfungsi sebagai heuristik eksternal untuk mengenali keunikan entitas di balik beberapa transaksi.

Interpretasi dari penggunaan ulang alamat adalah bahwa semua UTXO yang terkunci pada alamat ini milik (atau telah dimiliki) oleh entitas yang sama. Heuristik ini meninggalkan sedikit ruang untuk ketidakpastian. Ketika dimungkinkan untuk mengidentifikasinya, interpretasi yang mengikuti sangat mungkin sesuai dengan kenyataan. Dengan demikian, hal ini memungkinkan pengelompokan aktivitas onchain yang berbeda.

![BTC204](assets/en/34/01.webp)

Seperti dijelaskan dalam pengantar bagian 3 ini, heuristik ini ditemukan oleh Satoshi Nakamoto sendiri. Dalam White Paper, ia secara khusus menyebutkan solusi bagi pengguna untuk menghindarinya, yaitu dengan menggunakan alamat baru untuk setiap transaksi baru:

"_Sebagai firewall tambahan, sepasang kunci baru bisa digunakan untuk setiap transaksi untuk menjaga mereka agar tidak dikaitkan dengan pemilik yang sama._"

![BTC204](assets/notext/34/02.webp)

Sumber: S. Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System", https://bitcoin.org/bitcoin.pdf, 2009.

Misalnya, berikut ini adalah alamat yang digunakan kembali di beberapa transaksi:

```plaintext
```
bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0
```

![BTC204](assets/notext/34/03.webp)

Sumber: [Mempool.space](https://mempool.space/address/bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0)

### Kesamaan Skrip dan Sidik Jari Dompet

Di luar penggunaan ulang alamat, terdapat berbagai heuristik lain yang memungkinkan pengaitan aksi ke dompet yang sama atau ke kluster alamat.
Pertama dan terutama, seorang analis dapat diuntungkan dari kesamaan dalam penggunaan skrip. Sebagai contoh, skrip minoritas tertentu seperti multisig dapat lebih mudah diidentifikasi daripada skrip SegWit V0. Semakin besar kelompok yang kita sembunyikan di dalamnya, semakin sulit kita untuk ditemukan. Inilah mengapa, dalam protokol Coinjoin yang baik, semua peserta menggunakan jenis skrip yang sama persis.
Lebih luas lagi, seorang analis juga dapat fokus pada sidik jari karakteristik dari sebuah dompet. Ini adalah proses spesifik yang terkait dengan penggunaan yang mungkin ingin diidentifikasi dengan tujuan mengeksploitasinya sebagai heuristik pelacakan. Dengan kata lain, jika seseorang mengamati akumulasi karakteristik internal yang sama pada transaksi yang diatributkan ke entitas yang dilacak, seseorang dapat mencoba mengidentifikasi karakteristik yang sama pada transaksi lain.

Sebagai contoh, dapat diidentifikasi bahwa pengguna yang dilacak secara sistematis mengirimkan kembalian mereka ke alamat P2TR (`bc1p…`). Jika proses ini berulang, itu dapat digunakan sebagai heuristik untuk kelanjutan analisis kita. Sidik jari lain juga dapat digunakan, seperti urutan UTXO, penempatan kembalian di output, penandaan RBF (Replace-by-Fee), atau bahkan, nomor versi, bidang `nSequence`, dan bidang `nLockTime`.

![BTC204](assets/en/34/04.webp)

Seperti yang [@LaurentMT](https://twitter.com/LaurentMT) jelaskan dalam [Space Kek #19](https://podcasters.spotify.com/pod/show/decouvrebitcoin/episodes/SpaceKek-19---Analyse-de-chane--anonsets-et-entropie-e1vfuji) (podcast berbahasa Prancis), utilitas sidik jari dompet dalam analisis rantai meningkat secara signifikan seiring waktu. Memang, jumlah jenis skrip yang bertambah dan penyebaran fitur baru yang semakin bertahap oleh perangkat lunak dompet menonjolkan perbedaan. Bahkan, bisa terjadi seseorang dapat mengidentifikasi dengan akurasi perangkat lunak yang digunakan oleh entitas yang dilacak. Oleh karena itu, penting untuk memahami bahwa studi sidik jari dompet terbukti sangat relevan untuk transaksi terkini, lebih dari pada transaksi yang dimulai pada awal tahun 2010-an.

Untuk merangkum, sidik jari dapat berupa praktik spesifik, yang dilakukan secara otomatis oleh dompet atau secara manual oleh pengguna, yang dapat ditemukan pada transaksi lain untuk membantu kita dalam analisis kita.

### Heuristik Kepemilikan Input Bersama (CIOH)

CIOH, untuk "Common Input Ownership Heuristic" dalam bahasa Inggris, adalah heuristik yang menyatakan bahwa ketika sebuah transaksi mencakup beberapa input, input-input tersebut kemungkinan besar berasal dari satu entitas yang sama. Akibatnya, kepemilikannya bersama.
Untuk menerapkan Heuristik Kepemilikan Input Bersama (Common Input Ownership Heuristic - CIOH), kita pertama-tama mengamati sebuah transaksi yang memiliki banyak input. Ini bisa sedikitnya 2 input atau sebanyak 30 input. Setelah karakteristik ini teridentifikasi, kita periksa apakah transaksi tersebut tidak masuk ke dalam model transaksi yang dikenal. Misalnya, jika memiliki 5 input dengan jumlah yang kurang lebih sama dan 5 output dengan jumlah yang persis sama, kita tahu itu adalah struktur dari coinjoin. Oleh karena itu, kita tidak dapat menerapkan CIOH.

Namun, jika transaksi tersebut tidak masuk ke dalam model transaksi kolaboratif yang dikenal, maka kita dapat menyimpulkan bahwa semua input kemungkinan besar berasal dari entitas yang sama. Ini bisa sangat berguna untuk memperluas kluster yang dikenal atau untuk melanjutkan pelacakan.

CIOH ditemukan oleh Satoshi Nakamoto. Dia membahasnya di bagian 10 dari White Paper:

"_[...] tautan itu tak terhindarkan dengan transaksi multi-input, yang secara pasti mengungkapkan bahwa input-inputnya dimiliki oleh pemilik yang sama. Risikonya adalah jika pemilik kunci terungkap, tautan dapat mengungkapkan transaksi lain yang dimiliki oleh pemilik yang sama._"

Sangat menarik untuk dicatat bahwa Satoshi Nakamoto, bahkan sebelum peluncuran resmi Bitcoin, telah mengidentifikasi dua kerentanan utama dalam hal privasi bagi pengguna, yaitu CIOH dan penggunaan ulang alamat. Wawasan seperti itu cukup luar biasa, karena kedua heuristik ini tetap, bahkan hari ini, yang paling berguna dalam analisis rantai.

Untuk memberi Anda contoh, berikut ini adalah transaksi di mana kita kemungkinan dapat menerapkan CIOH:

```plaintext
20618e63b6eed056263fa52a2282c8897ab2ee71604c7faccfe748e1a202d712
```

Sumber: [Mempool.space](https://mempool.space/tx/20618e63b6eed056263fa52a2282c8897ab2ee71604c7faccfe748e1a202d712)

### Data Offchain

Jelas, analisis rantai tidak terbatas secara eksklusif pada data onchain. Data dari analisis sebelumnya atau yang tersedia di internet juga dapat digunakan untuk menyempurnakan analisis.
Misalnya, jika diamati bahwa transaksi yang dilacak secara sistematis disiarkan dari node Bitcoin yang sama dan alamat IP-nya dapat diidentifikasi, mungkin dimungkinkan untuk menemukan transaksi lain dari entitas yang sama, selain menentukan sebagian identitas pengirim. Meskipun praktik ini tidak mudah dicapai, karena memerlukan operasi banyak node, dimungkinkan bahwa beberapa perusahaan yang mengkhususkan diri dalam analisis rantai menerapkannya.

Analis juga memiliki opsi untuk mengandalkan analisis yang sebelumnya dibuat open-source, atau pada analisis sebelumnya mereka sendiri. Mungkin seseorang menemukan output yang mengarah ke kluster alamat yang telah diidentifikasi sebelumnya. Terkadang, juga dimungkinkan untuk mengandalkan output yang mengarah ke platform pertukaran, alamat perusahaan-perusahaan ini umumnya dikenal.

Dengan cara yang sama, seseorang dapat melakukan analisis dengan eliminasi. Misalnya, jika selama analisis transaksi dengan dua output, salah satunya terkait dengan kluster alamat yang sudah dikenal tetapi berbeda dari entitas yang dilacak, maka dapat diinterpretasikan bahwa output lainnya kemungkinan besar mewakili kembalian.

Analisis rantai juga mencakup bagian OSINT (*Open Source Intelligence*) yang sedikit lebih umum dengan pencarian internet. Inilah sebabnya mengapa disarankan agar tidak mempublikasikan alamat penerima langsung di media sosial atau di situs web, baik di bawah pseudonim atau tidak.

![BTC204](assets/notext/34/10.webp)

### Model Temporal
Jarang dipikirkan, tetapi beberapa perilaku manusia dapat dikenali secara on-chain. Yang paling berguna dalam analisis mungkin adalah pola tidur Anda! Ya, ketika Anda sedang tidur, Anda kemungkinan besar tidak melakukan transaksi Bitcoin. Karena Anda umumnya tidur pada jam-jam yang sama, umum untuk menggunakan analisis temporal dalam analisis rantai. Ini hanya melibatkan katalogisasi jam di mana transaksi entitas tertentu disiarkan ke jaringan Bitcoin. Menganalisis pola temporal ini memungkinkan kita untuk menyimpulkan banyak informasi.

Pertama-tama, analisis temporal terkadang memungkinkan identifikasi sifat dari entitas yang dilacak. Jika diamati bahwa transaksi disiarkan secara konsisten selama 24 jam, maka ini akan mengungkapkan aktivitas ekonomi yang kuat. Entitas di balik transaksi ini kemungkinan adalah sebuah perusahaan, berpotensi internasional, dan mungkin dengan prosedur otomatis secara internal.

Sebagai contoh, [saya telah mengenali model ini beberapa bulan yang lalu](https://twitter.com/Loic_Pandul/status/1701127409712452072) dengan menganalisis [transaksi yang secara keliru mengalokasikan 19 bitcoin dalam biaya](https://mempool.space/tx/d5392d474b4c436e1c9d1f4ff4be5f5f9bb0eb2e26b61d2781751474b7e870fd). Analisis temporal sederhana telah memungkinkan saya untuk menghipotesiskan bahwa kita berurusan dengan layanan otomatis, dan oleh karena itu kemungkinan besar entitas besar seperti platform pertukaran.

Memang, beberapa hari kemudian, ditemukan bahwa dana tersebut milik PayPal, melalui platform pertukaran Paxos.

Sebaliknya, jika kita melihat bahwa pola temporal lebih tersebar selama 16 jam yang sangat spesifik, maka kita dapat memperkirakan bahwa kita berurusan dengan pengguna individu, atau mungkin bisnis lokal tergantung pada volume yang diperdagangkan.

Di luar sifat entitas yang diamati, pola temporal juga dapat memberi kita lokasi perkiraan pengguna berkat zona waktu. Kita dapat dengan demikian menghubungkan transaksi lain, dan menggunakan timestamp dari ini sebagai heuristik tambahan yang dapat ditambahkan ke analisis kita.

Sebagai contoh, pada alamat yang digunakan kembali yang saya bicarakan sebelumnya, kita dapat mengamati bahwa transaksi, baik masuk atau keluar, terkonsentrasi selama interval 13 jam.

```plaintext
bc1qqtmeu0eyvem9a85l3sghuhral8tk0ar7m4a0a0
```

![BTC204](assets/notext/34/11.webp)

Sumber: OXT.me

Interval ini kemungkinan besar sesuai dengan Eropa, Afrika, atau Timur Tengah. Kita dapat oleh karena itu menyimpulkan bahwa pengguna di balik transaksi ini tinggal di sana.

Dalam register yang berbeda, ini juga analisis temporal dari jenis ini yang memungkinkan hipotesis bahwa Satoshi Nakamoto tidak beroperasi dari Jepang, tetapi memang dari Amerika Serikat: [*Zona Waktu Satoshi Nakamoto*](https://medium.com/@insearchofsatoshi/the-time-zones-of-satoshi-nakamoto-aa40f035178f)

## Aplikasi Praktis dengan Block Explorer
<chapterId>6493cf2f-225c-405f-9375-c4304f1087ed</chapterId>

Dalam bab final ini, kita akan menerapkan secara konkret konsep-konsep yang telah kita pelajari sejauh ini. Saya akan mempersembahkan Anda dengan contoh transaksi Bitcoin nyata, dan Anda perlu mengekstrak informasi yang saya minta.
Idealnya, untuk latihan ini, penggunaan alat analisis rantai profesional akan lebih disukai. Namun, sejak penangkapan pembuat Samourai Wallet, satu-satunya alat analisis gratis OXT.me tidak lagi tersedia. Oleh karena itu, kita akan memilih penjelajah blok klasik untuk latihan ini. Saya merekomendasikan menggunakan [Mempool.space](https://mempool.space/) karena banyak fiturnya dan berbagai alat analisis rantai, tetapi Anda juga bisa memilih penjelajah lain seperti [Bitcoin Explorer](https://bitcoinexplorer.org/). Untuk memulai, saya akan memperkenalkan latihan-latihannya. Gunakan penjelajah blok Anda untuk menyelesaikannya dan tuliskan jawaban Anda di selembar kertas. Kemudian, di akhir bab ini, saya akan menyediakan jawaban sehingga Anda dapat memeriksa dan memperbaiki hasil Anda.

*Transaksi yang dipilih untuk latihan ini dipilih semata-mata karena karakteristiknya dalam cara yang agak acak. Bab ini dimaksudkan semata-mata untuk tujuan pendidikan dan informatif. Saya ingin menjelaskan bahwa saya tidak mendukung atau mendorong penggunaan alat ini untuk tujuan jahat. Tujuannya adalah untuk mengajarkan Anda cara melindungi diri dari analisis rantai, bukan untuk melakukan analisis untuk mengungkapkan informasi pribadi orang lain.*

### Latihan 1

ID Transaksi untuk dianalisis:

```plaintext
3769d3b124e47ef4ffb5b52d11df64b0a3f0b82bb10fd6b98c0fd5111789bef7
```

Apa nama model dari transaksi ini dan apa interpretasi yang masuk akal yang dapat ditarik dengan hanya memeriksa modelnya, yaitu, struktur transaksi?

### Latihan 2

ID Transaksi untuk dianalisis:

```plaintext
baa228f6859ca63e6b8eea24ffad7e871713749d693ebd85343859173b8d5c20
```

Apa nama model dari transaksi ini dan apa interpretasi yang masuk akal yang dapat ditarik dengan hanya memeriksa modelnya, yaitu, struktur transaksi?

### Latihan 3

ID Transaksi untuk dianalisis:

```plaintext
3a9eb9ccc3517cc25d1860924c66109262a4b68f4ed2d847f079b084da0cd32b
```

Apa model dari transaksi ini?

Setelah mengidentifikasi modelnya, menggunakan heuristik internal dari transaksi, output mana yang kemungkinan besar mewakili perubahan?

### Latihan 4

ID Transaksi untuk dianalisis:

```plaintext
35f0b31c05503ebfdf7311df47f68a048e992e5cf4c97ec34aa2833cc0122a12
```

Apa model dari transaksi ini?
Setelah mengidentifikasi modelnya, menggunakan heuristik internal transaksi, output mana yang kemungkinan besar mewakili perubahan?

### Latihan 5

Bayangkan Loïc memposting salah satu alamat penerima Bitcoinnya di jejaring sosial Twitter:

![BTC204](assets/notext/35/1.webp)

```plaintext
bc1qja0hycrv7g9ww00jcqanhfpqmzx7luqalum3vu
```

Menggunakan **hanya heuristik penggunaan alamat ulang**, transaksi Bitcoin mana yang dapat kita kaitkan dengan identitas Loïc?

*Jelas, saya bukan pemilik sebenarnya dari alamat penerima ini dan saya tidak mempostingnya di jejaring sosial. Ini adalah alamat yang saya pilih secara acak dari blockchain.*

### Latihan 6

Menyusul Latihan 5, berkat heuristik penggunaan alamat ulang, Anda dapat mengidentifikasi beberapa transaksi Bitcoin di mana Loïc tampaknya terlibat. Biasanya, di antara transaksi yang teridentifikasi, Anda seharusnya telah menemukan ini:

```plaintext
Transaksi ini merupakan transaksi pertama yang mengirimkan dana ke alamat Loïc. Menurut Anda, dari mana bitcoin yang diterima oleh Loïc melalui transaksi ini berasal?

### Latihan 7

Mengikuti Latihan 5, berkat heuristik penggunaan alamat yang berulang, Anda berhasil mengidentifikasi beberapa transaksi Bitcoin di mana Loïc tampaknya terlibat. Sekarang Anda ingin mengetahui asal Loïc. Berdasarkan transaksi yang ditemukan, lakukan analisis temporal untuk menemukan zona waktu yang kemungkinan digunakan oleh Loïc. Dari zona waktu ini, tentukan lokasi di mana Loïc tampaknya tinggal (negara, negara bagian/wilayah, kota...).

![BTC204](assets/notext/35/2.webp)

### Latihan 8

Berikut adalah transaksi Bitcoin yang akan dipelajari:

```plaintext
bb346dae645d09d32ed6eca1391d2ee97c57e11b4c31ae4325bcffdec40afd4f
```

Dengan hanya mengamati transaksi ini, informasi apa yang bisa kita interpretasikan?

### Solusi untuk latihan

***Latihan 1:***
Model dari transaksi ini adalah pembayaran sederhana. Jika kita hanya mempelajari strukturnya, kita dapat menginterpretasikan bahwa salah satu output mewakili kembalian dan output lainnya mewakili pembayaran sebenarnya. Oleh karena itu, kita tahu bahwa pengguna yang diamati kemungkinan tidak lagi memiliki salah satu dari dua UTXO di output (yang untuk pembayaran), tetapi masih memiliki UTXO lainnya (yang untuk kembalian).

***Latihan 2:***
Model dari transaksi ini adalah pengeluaran batch. Model ini kemungkinan menunjukkan aktivitas ekonomi yang signifikan, seperti platform pertukaran, misalnya. Kita dapat menyimpulkan bahwa UTXO di input berasal dari perusahaan dengan aktivitas ekonomi yang signifikan dan bahwa UTXO di output akan tersebar. Beberapa akan dimiliki oleh klien perusahaan yang telah menarik bitcoin mereka ke dompet self-custody. Lainnya mungkin menuju ke perusahaan mitra. Akhirnya, pasti akan ada kembalian yang kembali ke perusahaan penerbit.

***Latihan 3:***

Model dari transaksi ini adalah pembayaran sederhana. Oleh karena itu, kita dapat menerapkan heuristik internal ke transaksi untuk mencoba dan mengidentifikasi kembalian.

Saya secara pribadi telah mengidentifikasi setidaknya dua heuristik internal yang mendukung hipotesis yang sama:
- Penggunaan kembali jenis skrip yang sama;
- Output terbesar.

Heuristik yang paling jelas adalah penggunaan kembali jenis skrip yang sama. Memang, output `0` adalah `P2SH`, dapat dikenali dari alamat penerima yang dimulai dengan `3`:

```plaintext
3Lcdauq6eqCWwQ3UzgNb4cu9bs88sz3mKD
```

Sementara output `1` adalah `P2WPKH`, dapat dikenali dari alamatnya yang dimulai dengan `bc1q`:

```plaintext
bc1qya6sw6sta0mfr698n9jpd3j3nrkltdtwvelywa
```

UTXO yang digunakan di input untuk transaksi ini juga menggunakan skrip `P2WPKH`:

```plaintext
bc1qyfuytw8pcvg5vx37kkgwjspg73rpt56l5mx89k
```

Dengan demikian, kita dapat berasumsi bahwa output `0` sesuai dengan pembayaran dan bahwa output `1` adalah kembalian dari transaksi, yang berarti bahwa pengguna di input masih memiliki output `1`.
Untuk mendukung atau menolak hipotesis ini, kita dapat mencari heuristik lain yang baik mengonfirmasi pemikiran kita atau menurunkan kemungkinan bahwa hipotesis kita benar.
Saya telah menemukan setidaknya satu heuristik lain. Ini adalah output terbesar. Output `0` berukuran `123,689 sats`, sementara output `1` berukuran `505,839 sats`. Oleh karena itu, ada perbedaan signifikan antara kedua output tersebut. Heuristik output terbesar menunjukkan bahwa output dengan volume terbesar kemungkinan adalah kembalian. Heuristik ini dengan demikian memperkuat hipotesis awal kita.

Kemungkinan besar pengguna yang menyediakan UTXO sebagai input masih memiliki output `1`, yang tampaknya mewakili kembalian dari transaksi tersebut.

***Latihan 4:***
Model dari transaksi ini adalah pembayaran sederhana. Oleh karena itu, kita dapat menerapkan heuristik internal pada transaksi untuk mencoba dan mengidentifikasi kembalian.
Saya secara pribadi telah mengidentifikasi setidaknya dua heuristik internal yang mendukung hipotesis yang sama:
- Penggunaan kembali jenis skrip yang sama;
- Output dari jumlah bulat.

Heuristik yang paling jelas adalah penggunaan kembali jenis skrip yang sama. Memang, output `0` adalah `P2SH`, dapat dikenali dari alamat penerima yang dimulai dengan `3`:

```plaintext
3FSH5Mnq6S5FyQoKR9Yjakk3X4KCGxeaD4
```

Sementara output `1` adalah `P2WPKH`, dapat diidentifikasi dari alamatnya yang dimulai dengan `bc1q`:

```plaintext
bc1qvdywdcfsyavt4v8uxmmrdt6meu4vgeg439n7sg
```

UTXO yang digunakan sebagai input untuk transaksi ini juga menggunakan skrip `P2WPKH`:

```plaintext
bc1qku3f2y294h3ks5eusv63dslcua2xnlzxx0k6kp
```

Dengan demikian, kita dapat berasumsi bahwa output `0` sesuai dengan pembayaran dan bahwa output `1` adalah kembalian dari transaksi, yang berarti bahwa pengguna dalam input masih memiliki output `1`.

Untuk mendukung atau menolak hipotesis ini, kita dapat mencari heuristik lain yang baik mengonfirmasi pemikiran kita atau menurunkan kemungkinan bahwa hipotesis kita benar.

Saya telah menemukan setidaknya satu heuristik lain. Ini adalah output dari jumlah bulat. Output `0` berukuran `70,000 sats`, sementara output `1` berukuran `22,962 sats`. Oleh karena itu, kita berada di hadapan output yang sempurna bulat dalam unit akun BTC. Heuristik output bulat menunjukkan bahwa UTXO dengan jumlah bulat kemungkinan adalah pembayaran, dan dengan eliminasi, yang lain mewakili kembalian. Heuristik ini dengan demikian memperkuat hipotesis awal kita.

Namun, dalam contoh ini, heuristik lain mungkin mempertanyakan hipotesis awal kita. Memang, output `0` lebih besar dari output `1`. Jika kita berdasarkan pada heuristik bahwa output terbesar umumnya adalah kembalian, kita bisa menyimpulkan bahwa output `0` adalah kembalian. Namun, kontra-hipotesis ini tampak tidak masuk akal, karena dua heuristik lainnya tampak jauh lebih meyakinkan daripada heuristik output terbesar. Akibatnya, tampaknya masuk akal untuk mempertahankan hipotesis awal kita meskipun ada kontradiksi yang tampak.
Oleh karena itu, kemungkinan besar pengguna yang menyediakan UTXO sebagai input masih memiliki output `1`, yang tampaknya mewakili kembalian dari transaksi.
***Latihan 5:***
Kita dapat melihat bahwa 8 transaksi dapat dikaitkan dengan identitas Loïc. Di antaranya, 4 melibatkan penerimaan bitcoin:

```plaintext
***Latihan 6:***
Jika kita memeriksa model transaksi ini, terlihat jelas bahwa ini adalah pengeluaran yang dikelompokkan. Memang, transaksi memiliki satu input dan 51 output, yang menunjukkan aktivitas ekonomi yang signifikan. Oleh karena itu, kita dapat menghipotesiskan bahwa Loïc telah melakukan penarikan bitcoin dari sebuah platform pertukaran.

Beberapa elemen memperkuat hipotesis ini. Pertama, jenis skrip yang digunakan untuk mengamankan UTXO pada input adalah skrip multisig P2SH 2/3, yang menunjukkan tingkat keamanan lanjutan yang khas dari platform pertukaran:

```plaintext
OP_PUSHNUM_2
OP_PUSHBYTES_33 03eae02975918af86577e1d8a257773118fd6ceaf43f1a543a4a04a410e9af4a59
OP_PUSHBYTES_33 03ba37b6c04aaf7099edc389e22eeb5eae643ce0ab89ac5afa4fb934f575f24b4e
OP_PUSHBYTES_33 03d95ef2dc0749859929f3ed4aa5668c7a95baa47133d3abec25896411321d2d2d
OP_PUSHNUM_3
OP_CHECKMULTISIG
```
Selanjutnya, alamat yang dianalisis `3PUv9tQMSDCEPSMsYSopA5wDW86pwRFbNF` digunakan kembali dalam lebih dari 220.000 transaksi yang berbeda, yang sering kali merupakan ciri khas dari platform pertukaran, umumnya tidak terlalu memperhatikan privasi mereka. Heuristik temporal yang diterapkan pada alamat ini juga menunjukkan penyebaran transaksi yang teratur hampir setiap hari selama periode 3 bulan, dengan jam kerja yang diperluas selama 24 jam, menunjukkan aktivitas berkelanjutan dari sebuah platform pertukaran.

Akhirnya, volume yang diproses oleh entitas ini sangat besar. Memang, alamat tersebut menerima dan mengirim 44 BTC selama 222.262 transaksi antara Desember 2022 dan Maret 2023. Volume signifikan ini semakin mengkonfirmasi sifat kegiatan dari sebuah platform pertukaran.

***Latihan 7:***
Dengan menganalisis waktu konfirmasi dari transaksi, waktu UTC berikut dapat dicatat:
```plaintext
05:43
20:51
18:12
17:16
04:28
23:38
07:45
21:55
```

Dengan menganalisis waktu-waktu ini, tampaknya zona waktu UTC-7 dan UTC-8 konsisten dengan rentang aktivitas manusia yang umum (antara 08:00 dan 23:00) untuk sebagian besar waktu:

```plaintext
05:43 UTC > 22:43 UTC-7
20:51 UTC > 13:51 UTC-7
18:12 UTC > 11:12 UTC-7
17:16 UTC > 10:16 UTC-7
04:28 UTC > 21:28 UTC-7
23:38 UTC > 16:38 UTC-7
07:45 UTC > 00:45 UTC-7
21:55 UTC > 14:55 UTC-7

05:43 UTC > 21:43 UTC-8
20:51 UTC > 12:51 UTC-8
18:12 UTC > 10:12 UTC-8
17:16 UTC > 09:16 UTC-8
04:28 UTC > 20:28 UTC-8
23:38 UTC > 15:38 UTC-8
07:45 UTC > 23:45 UTC-8
21:55 UTC > 13:55 UTC-8
```

![BTC204](assets/notext/35/2.webp)

Zona waktu UTC-7 sangat relevan pada musim panas, karena mencakup negara bagian dan wilayah seperti:
- California (dengan kota seperti Los Angeles, San Francisco, dan San Diego);
- Nevada (dengan Las Vegas);
- Oregon (dengan Portland);
- Washington (dengan Seattle);
- Wilayah Kanada British Columbia (dengan kota seperti Vancouver dan Victoria).

Informasi-informasi ini menyarankan bahwa Loïc bisa jadi tinggal di pantai barat Amerika Serikat atau Kanada.

***Latihan 8:***
Analisis transaksi ini mengungkapkan 5 input dan satu output, yang tampaknya menunjukkan konsolidasi. Penerapan heuristik CIOH menyarankan bahwa semua UTXO dalam input dipegang oleh satu entitas, dan bahwa UTXO dalam output juga milik entitas ini. Tampaknya pengguna memilih untuk mengkonsolidasikan beberapa UTXO yang mereka miliki menjadi satu UTXO dalam output, dengan tujuan mengkonsolidasikan koin mereka. Pendekatan ini mungkin dimotivasi oleh keinginan untuk memanfaatkan biaya transaksi rendah pada saat itu untuk mengurangi biaya di masa depan.
___

*Untuk penulisan bagian 3 ini tentang analisis rantai, saya mengandalkan sumber berikut:*
- *Seri empat artikel yang bernama: [Understanding Bitcoin Privacy with OXT](https://medium.com/oxt-research/understanding-bitcoin-privacy-with-oxt-part-1-4-8177a40a5923), diproduksi oleh Samourai Wallet pada tahun 2021;*
- *Berbagai laporan dari [OXT Research](https://medium.com/oxt-research), serta alat analisis rantai gratis mereka (yang saat ini tidak tersedia setelah penangkapan pendiri Samourai Wallet);*
- *Lebih luas, pengetahuan saya berasal dari berbagai tweet dan konten dari [@LaurentMT](https://twitter.com/LaurentMT) dan [@ErgoBTC](https://twitter.com/ErgoBTC);*
- *The [Space Kek #19](https://podcasters.spotify.com/pod/show/decouvrebitcoin/episodes/SpaceKek-19---Analyse-de-chane--anonsets-et-entropie-e1vfuji) di mana saya berpartisipasi bersama [@louneskmt](https://twitter.com/louneskmt), [@TheoPantamis](https://twitter.com/TheoPantamis), [@Sosthene___](https://twitter.com/Sosthene___), dan [@LaurentMT](https://twitter.com/LaurentMT).*
*Saya ingin mengucapkan terima kasih kepada para penulis, pengembang, dan produsernya. Terima kasih juga kepada para reviewer yang dengan teliti mengoreksi artikel yang menjadi dasar untuk bagian ke-3 ini dan memberikan saya nasihat ahli mereka:*
- *[Gilles Cadignan](https://twitter.com/gillesCadignan);*
- *[Ludovic Lars](https://viresinnumeris.fr/).*

# Menguasai Praktik Terbaik untuk Melindungi Privasi Anda
<partId>9bd04b63-f1af-4e50-9061-6bc90009df68</partId>

## Penggunaan Ulang Alamat
<chapterId>f3e97645-3df3-41bc-a4ed-d2c740113d96</chapterId>
Setelah mempelajari teknik-teknik yang dapat mengompromikan privasi Anda di Bitcoin, dalam bagian ketiga ini, kami akan sekarang melihat praktik terbaik yang harus diadopsi untuk melindungi diri Anda. Bagian ini tidak bertujuan untuk menjelajahi metode peningkatan privasi, sebuah subjek yang akan dibahas nanti, tetapi lebih kepada memahami bagaimana berinteraksi dengan benar dengan Bitcoin untuk mempertahankan privasi yang secara alami ditawarkannya, tanpa harus menggunakan teknik tambahan.
Tentu saja, untuk memulai bagian ketiga ini, kami akan berbicara tentang penggunaan ulang alamat. Fenomena ini merupakan ancaman utama terhadap privasi pengguna. Oleh karena itu, bab ini bisa dibilang yang paling penting dari seluruh pelatihan.

### Apa itu alamat penerima?

Alamat penerima Bitcoin adalah rangkaian karakter atau pengenal yang digunakan untuk menerima bitcoin dalam dompet.

Secara teknis, alamat penerima Bitcoin tidak "menerima" bitcoin dalam arti harfiah, tetapi lebih kepada mendefinisikan kondisi di bawah mana bitcoin dapat dihabiskan. Secara spesifik, ketika pembayaran dikirim kepada Anda, transaksi pengirim menciptakan UTXO baru yang ditujukan untuk Anda dalam output dari UTXO yang dikonsumsi dalam input. Pada output ini, sebuah skrip yang mendefinisikan bagaimana UTXO ini dapat dihabiskan nantinya diterapkan. Skrip ini dikenal sebagai "*ScriptPubKey*" atau "*Locking Script*". Alamat penerima Anda, lebih tepatnya payload-nya, diintegrasikan ke dalam skrip ini. Untuk menyederhanakan, skrip ini pada dasarnya menetapkan:

> "*Untuk menghabiskan UTXO baru ini, tanda tangan digital harus disediakan menggunakan kunci privat yang terkait dengan alamat penerima ini.*"

![BTC204](assets/notext/41/01.webp)

Alamat Bitcoin hadir dalam berbagai tipe tergantung pada model skrip yang digunakan. Model pertama, yang dikenal sebagai "*Legacy*," mencakup alamat `P2PKH` (*Pay-to-PubKey-Hash*) dan `P2SH` (*Pay-to-Script-Hash*). Alamat P2PKH selalu dimulai dengan `1` dan P2SH dengan `3`. Meskipun masih aman, format ini sekarang sudah usang, karena menghasilkan biaya transaksi yang lebih tinggi dan menawarkan privasi yang lebih rendah dibandingkan dengan standar baru.
Alamat SegWit V0 (`P2WPKH` dan `P2WSH`) dan Taproot / SegWit V1 (`P2TR`) mewakili format modern. Alamat SegWit dimulai dengan `bc1q` dan alamat Taproot, yang diperkenalkan pada tahun 2021, dimulai dengan `bc1p`.
Sebagai contoh, berikut ini adalah alamat penerimaan Taproot:

```text
bc1ps5gd2ys8kllz9alpmcwxqegn7kl3elrpnnlegwkm3xpq2h8da07spxwtf5
```

Cara ScriptPubKey dibangun akan bergantung pada standar yang Anda gunakan:
| Model Script    | ScriptPubKey                                                || ---------------- | ----------------------------------------------------------- |
| P2PKH           | OP_DUP OP_HASH160 `<pubKeyHash>` OP_EQUALVERIFY OP_CHECKSIG |
| P2SH            | OP_HASH160 `<scriptHash>` OP_EQUAL                          |
| P2WPKH          | 0 `<pubKeyHash>`                                            |
| P2WSH           | 0 `<witnessScriptHash>`                                     |
| P2SH - P2WPKH   | OP_HASH160 `<redeemScriptHash>` OP_EQUAL                    |
| P2SH - P2WSH    | OP_HASH160 `<redeemScriptHash>` OP_EQUAL                    |
| P2TR            | 1 `<pubKey>`                                                |

Mengenai pembuatan alamat penerimaan, ini juga bergantung pada model script yang dipilih:
- Untuk alamat `P2PKH` dan `P2WPKH`, payload, yaitu inti dari alamat, mewakili hash dari kunci publik;
- Untuk alamat `P2SH` dan `P2WSH`, payload mewakili hash dari sebuah script;
- Sedangkan untuk alamat `P2TR`, payload adalah kunci publik yang dimodifikasi. Output `P2TR` menggabungkan aspek dari _Pay-to-PubKey_ dan _Pay-to-Script_. Kunci publik yang dimodifikasi adalah hasil dari penambahan kunci publik pengeluaran klasik dengan "tweak", yang berasal dari akar Merkle dari sekumpulan script yang juga dapat digunakan untuk menghabiskan bitcoin.

![BTC204](assets/en/67/01.webp)

Alamat yang ditampilkan pada perangkat lunak dompet Anda juga mencakup HRP (*Human-Readable Part*), biasanya `bc` untuk alamat pasca-SegWit, pemisah `1`, dan nomor versi `q` untuk SegWit V0 dan `p` untuk Taproot/SegWit V1. Checksum juga ditambahkan untuk memastikan integritas dan validitas alamat selama transmisinya.

Akhirnya, alamat dimasukkan ke dalam format standar:
- Base58check untuk alamat Legacy lama;
- Bech32 untuk alamat SegWit;
- Bech32m untuk alamat Taproot.

Berikut adalah matriks penambahan untuk format bech32 dan bech32m (SegWit dan Taproot) dari basis 10:

| +   | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   |
| --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 0   | q   | p   | z   | r   | y   | 9   | x   | 8   |
| 8   | g   | f   | 2   | t   | v   | d   | w   | 0   |
| 16  | s   | 3   | j   | n   | 5   | 4   | k   | h   || 24  | c   | e   | 6   | m   | u   | a   | 7   | l   |
### Apa itu Penggunaan Ulang Alamat?

Penggunaan ulang alamat merujuk pada praktik menggunakan alamat penerima yang sama untuk memblokir beberapa UTXO yang berbeda.

Seperti yang kita lihat di bagian sebelumnya, setiap UTXO memiliki ScriptPubKey sendiri yang menguncinya dan harus dipenuhi agar UTXO dapat dikonsumsi sebagai input dalam transaksi baru. Di dalam ScriptPubKey inilah alamat penerima (payload) diintegrasikan.

Ketika ScriptPubKey yang berbeda mengandung alamat penerima yang sama, ini dikenal sebagai penggunaan ulang alamat. Dalam praktiknya, ini berarti bahwa pengguna telah memberikan alamat yang sama beberapa kali kepada pengirim untuk menerima bitcoin melalui beberapa pembayaran. Dan memang, praktik ini sangat merugikan privasi Anda.

### Mengapa Penggunaan Ulang Alamat Menjadi Masalah?

Mengingat blockchain bersifat publik, mudah untuk melihat alamat mana yang mengunci UTXO mana dan berapa banyak bitcoin. Jika alamat yang sama digunakan untuk beberapa transaksi, menjadi mungkin untuk menyimpulkan bahwa semua bitcoin yang terkait dengan alamat tersebut milik orang yang sama. Praktik ini membahayakan privasi pengguna dengan memungkinkan tautan deterministik dibuat antara transaksi yang berbeda dan melacak bitcoin di blockchain. Satoshi Nakamoto sendiri menyoroti masalah ini dalam Bitcoin White Paper:

> *Sebagai firewall tambahan, sepasang kunci baru bisa digunakan untuk setiap transaksi untuk mencegah mereka dikaitkan dengan pemilik yang sama.*

![BTC204](assets/notext/34/02.webp)

Sumber: S. Nakamoto, "Bitcoin: A Peer-to-Peer Electronic Cash System", https://bitcoin.org/bitcoin.pdf, 2009.

Tujuan yang dicari oleh Satoshi dalam pernyataan ini adalah untuk menciptakan firewall tambahan dalam kasus asosiasi antara identitas pengguna dan sepasang kunci di Bitcoin, untuk menghindari memiliki semua aktivitas mereka secara publik dikaitkan dengan identitas mereka. Hari ini, dengan berkembangnya perusahaan analisis rantai dan regulasi KYC, penggunaan alamat unik bukan lagi "firewall tambahan," tetapi praktik yang diperlukan bagi siapa saja yang ingin menjaga privasi mereka minimal.

Ketika Anda menggunakan ulang alamat, Anda membuat tautan yang hampir tidak dapat disangkal antara semua transaksi yang terkait dengan alamat tersebut. Meskipun ini tidak langsung membahayakan dana Anda, karena kriptografi pada kurva eliptik memastikan keamanan kunci pribadi Anda, ini memfasilitasi pemantauan aktivitas Anda. Memang, siapa pun dengan node dapat mengamati transaksi dan saldo alamat, sehingga sepenuhnya mengompromikan anonimitas Anda.

![BTC204](assets/en/34/01.webp)
Untuk mengilustrasikan poin ini, mari kita ambil contoh Bob, seorang pengguna yang secara rutin membeli bitcoin dalam jumlah kecil melalui DCA (Dollar Cost Averaging) dan selalu mengirimkannya ke alamat yang sama. Setelah dua tahun, alamat ini berisi jumlah bitcoin yang substansial. Jika Bob menggunakan alamat ini untuk melakukan pembayaran kepada pedagang lokal, yang terakhir bisa melihat semua dana yang terkait dan menyimpulkan kekayaan Bob. Ini bisa menyebabkan risiko keamanan pribadi, termasuk upaya pencurian atau pemerasan. Jika Bob telah menggunakan alamat baru untuk menerima setiap pembelian periodik, dia akan mengungkapkan jauh lebih sedikit informasi kepada pedagangnya.

Dalam analisis rantai, kita membedakan antara 2 jenis penggunaan ulang alamat:
- Penggunaan ulang eksternal;
- Penggunaan ulang internal dalam sebuah transaksi.

Yang pertama diamati ketika sebuah alamat digunakan ulang dalam beberapa transaksi Bitcoin yang berbeda. Inilah yang kita bahas sebelumnya: heuristik ini memungkinkan kita untuk menyimpulkan bahwa semua UTXO yang melewati alamat ini milik satu entitas.
Penggunaan ulang alamat internal diamati tidak ketika penggunaan ulang terjadi lintas banyak transaksi, tetapi ketika itu terjadi dalam transaksi yang sama. Memang, jika alamat yang sama yang digunakan untuk mengunci sebuah input digunakan sebagai output dalam sebuah transaksi, maka kita dapat menyimpulkan bahwa output ini masih milik pengguna yang sama (kembalian), dan bahwa output kedua mewakili pembayaran sebenarnya. Heuristik lain ini memungkinkan untuk pelacakan dana lintas banyak transaksi.
![BTC204](assets/en/33/02.webp)

Penggunaan ulang alamat adalah masalah besar pada Bitcoin. Menurut situs web OXT.me (saat ini tidak dapat diakses), tingkat penggunaan ulang alamat pada Bitcoin sekitar 52% pada tahun 2022:

![BTC204](assets/notext/41/02.webp)

Tingkat ini sangat besar, tetapi sebagian besar berasal dari platform pertukaran daripada pengguna individu.

### Bagaimana cara menghindari penggunaan ulang alamat?

Menghindari penggunaan ulang alamat cukup sederhana: **cukup gunakan alamat baru yang segar untuk setiap pembayaran masuk baru ke dompet Anda**.

Berkat BIP32, dompet modern kini deterministik dan hierarkis. Ini berarti bahwa pengguna dapat menghasilkan sejumlah besar alamat dari satu potongan informasi awal: seed. Dengan menyimpan potongan informasi tunggal ini, dimungkinkan untuk mengembalikan semua kunci privat dari dompet, sehingga mengakses dana yang diamankan oleh alamat yang sesuai.

![BTC204](assets/notext/41/03.webp)
Inilah mengapa, ketika Anda menekan tombol "*terima*" di perangkat lunak dompet Anda, sebuah alamat penerima yang belum digunakan ditawarkan kepada Anda setiap kali. Setelah menerima bitcoin pada alamat ini, perangkat lunak secara otomatis menyarankan yang baru.
> *PS: Baru-baru ini, beberapa perangkat lunak dompet telah mengumumkan niat mereka untuk berhenti menghasilkan alamat kosong, khawatir bahwa ini dapat dipersepsikan sebagai bentuk pencucian uang oleh otoritas. Jika perangkat lunak Anda termasuk di antara ini, saya sangat menyarankan Anda untuk segera menggantinya, karena ini tidak dapat diterima bagi pengguna.*

Jika Anda memerlukan pengenal statis untuk menerima pembayaran, seperti untuk menerima donasi, misalnya, disarankan untuk tidak menggunakan alamat Bitcoin klasik karena risiko penggunaan ulang. Lebih baik menggunakan alamat Lightning, atau untuk pengenal pembayaran onchain statis, Anda dapat memilih BIP47 atau Pembayaran Senyap. Operasi protokol-protokol ini dijelaskan secara rinci di bagian 6 dari pelatihan ini.

## Pelabelan dan Kontrol Koin
<chapterId>fbdb07cd-c025-48f2-97b0-bd1bc21c68a8</chapterId>

Seperti yang telah kita temukan dalam bagian tentang analisis rantai, ada banyak heuristik dan pola yang dapat digunakan untuk menyimpulkan informasi tentang sebuah transaksi. Sebagai pengguna, penting untuk menyadari teknik-teknik ini untuk lebih melindungi diri Anda.

Ini melibatkan pengelolaan dompet self-custody Anda yang ketat, yang mencakup mengetahui asal UTXO Anda, serta pemilihan UTXO yang bijaksana untuk dikonsumsi selama pembayaran. Pengelolaan dompet yang efektif ini bergantung pada dua fitur penting dari dompet Bitcoin yang baik: pelabelan dan kontrol koin.

Dalam bab ini, kita akan mempelajari fitur-fitur ini dan melihat bagaimana Anda dapat menggunakannya secara cerdas, tanpa menambah beban kerja yang terlalu banyak, untuk sangat mengoptimalkan privasi Anda pada Bitcoin.

### Apa itu Pelabelan?

Pelabelan adalah praktik yang melibatkan penugasan anotasi atau label ke UTXO tertentu dalam dompet Bitcoin. Anotasi ini disimpan secara lokal oleh perangkat lunak dompet dan tidak pernah ditransmisikan melalui jaringan Bitcoin. Pelabelan dengan demikian adalah alat untuk manajemen pribadi.

Sebagai contoh, jika saya memiliki UTXO dari pembelian P2P di Bisq dengan Charles, saya bisa menetapkannya label "`Non-KYC Bisq Charles`".
Memberi label merupakan praktik yang baik yang membantu mengingat asal atau tujuan yang dimaksud dari sebuah UTXO, sehingga memudahkan pengelolaan dana dan mengoptimalkan privasi. Memang, dompet Bitcoin Anda kemungkinan besar mengamankan beberapa UTXO. Jika sumber dari UTXO tersebut berbeda, Anda mungkin tidak ingin menggabungkan UTXO tersebut di masa depan, jika tidak, Anda bisa mengungkapkan kepemilikan bersama mereka. Dengan memberi label yang tepat pada semua koin Anda, Anda memastikan bahwa Anda mengingat asalnya ketika Anda perlu menggunakannya, meskipun itu hanya dalam beberapa tahun.

### Apa itu kontrol koin?

Penggunaan label yang aktif menjadi lebih menarik ketika dikombinasikan dengan opsi kontrol koin pada perangkat lunak dompet Anda.

Kontrol koin adalah fitur yang ada dalam perangkat lunak dompet Bitcoin yang baik, yang memberi Anda kemampuan untuk secara manual memilih UTXO spesifik untuk digunakan sebagai input untuk melakukan transaksi. Memang, untuk memenuhi pembayaran di output, perlu untuk mengonsumsi UTXO di input sebagai gantinya. Untuk beberapa alasan yang akan kita lihat nanti, Anda mungkin ingin memilih secara tepat koin mana yang akan dikonsumsi di input untuk memenuhi pembayaran tertentu. Inilah yang memungkinkan kontrol koin untuk Anda lakukan. Untuk memberi Anda analogi, fitur ini mirip dengan tindakan memilih koin spesifik di dompet Anda ketika Anda membayar baguette Anda.

![BTC204](assets/notext/42/01.webp)

Penggunaan perangkat lunak dompet dengan kontrol koin, dikombinasikan dengan pelabelan UTXO, memungkinkan pengguna untuk membedakan dan secara tepat memilih UTXO untuk transaksi mereka.

### Bagaimana cara memberi label pada UTXO Anda dengan tepat?

Tidak ada metode universal untuk memberi label pada UTXO yang cocok untuk semua orang. Terserah Anda untuk mendefinisikan sistem pelabelan sehingga Anda dapat dengan mudah menemukan jalan Anda di sekitar dompet Anda. Dalam hal apapun, ingatlah bahwa pelabelan yang baik adalah pelabelan yang akan Anda dapat pahami ketika Anda membutuhkannya. Jika dompet Bitcoin Anda terutama dimaksudkan untuk tabungan, mungkin label hanya akan berguna bagi Anda dalam beberapa dekade. Oleh karena itu, pastikan mereka jelas, tepat, dan komprehensif.

Penting bahwa orang-orang terdekat Anda dapat dengan mudah mengidentifikasi asal dana jika, suatu hari, mereka perlu mengakses dompet Anda. Ini bisa membantu mereka untuk alasan privasi serta untuk kebutuhan hukum, dalam hal mereka harus membenarkan asal usul dana di depan otoritas.
Aspek terpenting dari pelabelan adalah mencatat sumber UTXO. Anda hanya perlu menunjukkan bagaimana koin ini tiba di dompet Anda. Apakah itu dari pembelian di platform pertukaran? Pembayaran dari klien? Pertukaran peer-to-peer? Atau apakah itu kembalian dari pembelian? Dengan demikian, Anda bisa menentukan:
- `Penarikan Exchange.com`;
- `Pembayaran Klien David`;
- `Pembelian P2P Charles`;
- `Kembalian dari pembelian sofa`

![BTC204](assets/en/42/02.webp)

Untuk menyempurnakan pengelolaan UTXO Anda dan mematuhi strategi pemisahan dana Anda dalam dompet, Anda bisa memperkaya label Anda dengan indikator tambahan yang mencerminkan pemisahan ini. Jika dompet Anda berisi dua kategori UTXO yang tidak ingin Anda campur, Anda bisa mengintegrasikan penanda di label Anda untuk membedakan kelompok ini dengan jelas. Penanda pemisahan ini akan bergantung pada kriteria Anda sendiri, seperti perbedaan antara UTXO dari proses akuisisi yang melibatkan KYC, atau antara dana profesional dan pribadi. Mengambil contoh label yang disebutkan sebelumnya, ini bisa diterjemahkan menjadi:
- `KYC - Penarikan Exchange.com`;
- `KYC - Pembayaran Klien David`;
- `NO KYC - Pembelian P2P Charles`;
- `NO KYC - Kembalian dari pembelian sofa`

![BTC204](assets/en/42/03.webp)
Juga disarankan untuk mempertahankan pelabelan sebuah koin sepanjang transaksi. Sebagai contoh, ketika mengkonsolidasikan UTXO tanpa-KYC, pastikan untuk menandai UTXO hasil konsolidasi tidak hanya sebagai `konsolidasi`, tetapi secara spesifik sebagai `konsolidasi tanpa-KYC` untuk menjaga jejak asal koin tersebut tetap jelas.
Akhirnya, tidak wajib untuk menempatkan tanggal pada label. Kebanyakan perangkat lunak dompet sudah menampilkan tanggal transaksi, dan selalu mungkin untuk mengambil informasi ini di block explorer menggunakan TXID-nya.

### Bagaimana Cara Memilih Koin Anda dengan Tepat?

Ketika Anda melakukan transaksi, kontrol koin memungkinkan Anda untuk secara spesifik memilih UTXO mana yang akan digunakan sebagai input untuk memenuhi output pembayaran. Dua aspek yang harus dipertimbangkan dalam pilihan ini:
- Kemungkinan bagi penerima pembayaran untuk menghubungkan sebagian identitas Anda dengan UTXO yang digunakan sebagai input;
- Kemampuan pengamat eksternal untuk menetapkan hubungan antara semua UTXO yang dikonsumsi sebagai input.
Untuk mengilustrasikan poin pertama, mari kita ambil contoh konkret. Misalkan Anda membeli baguette dengan bitcoin dari tukang roti lokal Anda. Anda menggunakan satu atau lebih UTXO yang Anda miliki sebagai input untuk setidaknya menutupi harga baguette dalam output, serta biaya transaksi. Tukang roti Anda kemudian berpotensi menghubungkan wajah Anda, atau bagian lain dari identitas Anda yang mereka ketahui, dengan koin yang digunakan sebagai input. Mengetahui adanya hubungan ini, Anda mungkin lebih memilih untuk memilih UTXO tertentu daripada yang lain saat melakukan pembayaran.
![BTC204](assets/notext/42/04.webp)

Sebagai contoh, jika salah satu UTXO Anda berasal dari platform pertukaran dan Anda lebih suka tukang roti tidak mengetahui akun Anda di platform ini, Anda akan menghindari menggunakan UTXO ini untuk pembayaran. Jika Anda memiliki UTXO bernilai tinggi yang mengungkapkan jumlah bitcoin yang signifikan, Anda juga mungkin memilih untuk tidak menggunakannya agar tukang roti tidak mengetahui tentang kekayaan BTC Anda.

Pilihan UTXO untuk digunakan pada poin pertama ini oleh karena itu didasarkan pada keputusan pribadi, dipengaruhi oleh apa yang Anda bersedia untuk mengungkapkan atau tidak. Label yang Anda tetapkan pada UTXO Anda saat menerima akan membantu Anda memilih yang, setelah dibelanjakan, hanya mengekspos informasi yang Anda nyaman untuk diungkapkan kepada penerima.

Di luar informasi yang berpotensi diungkapkan kepada penerima, pilihan input juga mempengaruhi apa yang Anda ungkapkan kepada semua pengamat blockchain. Memang, dengan menggunakan beberapa UTXO sebagai input untuk transaksi Anda, Anda mengungkapkan bahwa mereka dimiliki oleh entitas yang sama, menurut Heuristik Kepemilikan Input Bersama (CIOH).

![BTC204](assets/notext/42/05.webp)

Ketika memilih koin Anda, Anda harus oleh karena itu sadar bahwa transaksi yang akan Anda siarkan akan menciptakan hubungan antara semua UTXO yang digunakan. Hubungan ini bisa menjadi masalah bagi privasi pribadi Anda, terutama jika UTXO berasal dari sumber yang berbeda.

![BTC204](assets/notext/42/06.webp)

Mari kita kembali ke contoh UTXO tanpa-KYC saya dari Bisq; Saya ingin menghindari menggabungkannya dengan UTXO dari, katakanlah, platform pertukaran yang diatur yang mengetahui identitas saya. Memang, jika saya pernah menggunakan 2 UTXO ini sebagai input dalam transaksi yang sama, platform yang diatur akan dapat menghubungkan identitas saya dengan UTXO yang saya beli di Bisq, padahal sebelumnya tidak terhubung dengan identitas saya.

![BTC204](assets/notext/42/07.webp)
Akhirnya, untuk memilih UTXO mana yang akan digunakan sebagai input untuk sebuah transaksi, hal terpenting adalah menghindari penggunaan beberapa UTXO. Kapan pun memungkinkan, pilih satu koin yang cukup besar untuk menutupi pembayaran Anda. Dengan melakukan ini, Anda sepenuhnya menghindari risiko yang terkait dengan COINJOIN. Namun, jika tidak ada UTXO individu yang cukup untuk pembayaran dan Anda harus menggunakan beberapa, pastikan mereka berasal dari sumber yang serupa untuk meminimalkan risiko tautan yang tidak diinginkan. Juga, ingat bahwa penerima mungkin mengaitkan informasi yang mereka miliki tentang Anda dengan sejarah koin yang digunakan sebagai input.

### Memahami Pemilihan Koin Otomatis

Dalam bagian sebelumnya, kami membahas tentang pemilihan UTXO secara manual untuk sebuah transaksi. Tapi apa yang terjadi ketika perangkat lunak dompet membuat seleksi ini secara otomatis? Beberapa metode ada untuk menentukan koin mana yang akan digunakan, dan seleksi UTXO adalah bidang penelitian yang nyata dalam Bitcoin. Tujuan utama dari proses otomatis ini seringkali adalah untuk meminimalkan biaya transaksi bagi pengguna.

Metode seleksi UTXO seperti FIFO (*First In First Out*) dan LIFO (*Last In First Out*) termasuk yang paling sederhana tetapi juga yang paling tidak efisien. Dengan FIFO, koin tertua di dompet digunakan terlebih dahulu. Pendekatan ini umumnya tidak efisien baik untuk meminimalkan biaya transaksi maupun untuk menjaga privasi, kecuali dalam kasus di mana timelock relatif digunakan dan harus diperbarui secara berkala. Sebaliknya, LIFO memprioritaskan penggunaan UTXO terbaru. Meskipun sederhana, kedua metode ini sering terbukti tidak efisien.

Metode yang lebih canggih adalah *Knapsack Solver*. Ini adalah metode yang digunakan dalam dompet Bitcoin Core hingga versi 0.17. Ini melibatkan pemilihan UTXO dari dompet secara iteratif dan acak, menambahkannya dalam subset, dan mempertahankan solusi yang mengurangi bobot transaksi sebanyak mungkin, untuk mengurangi biaya bagi pengguna.
*Branch-and-Bound* (BNB), sering dijuluki "algoritma Murch" sebagai referensi kepada penemunya, telah menggantikan *Knapsack Solver* di Bitcoin Core mulai dari versi 0.17. Metode yang lebih canggih ini bertujuan untuk menemukan satu set UTXO yang tepat sesuai dengan jumlah yang diperlukan untuk memenuhi output dari sebuah transaksi. Tujuan BNB adalah untuk meminimalkan jumlah kembalian serta biaya, dengan mengurangi apa yang disebut kriteria pemborosan yang memperhitungkan baik biaya langsung maupun biaya masa depan yang diharapkan untuk kembalian. Metode ini berasal dari konsep asli *Branch-and-Bound*, yang dirancang pada tahun 1960 oleh Ailsa Land dan Alison Harcourt, dan menawarkan optimasi biaya yang lebih tepat dibandingkan dengan *Knapsack Solver*.
Semua metode pemilihan UTXO otomatis ini dapat efektif dalam mengurangi biaya transaksi, tetapi seringkali tidak efisien dalam menjaga privasi pengguna. Memang, algoritma ini dapat menggabungkan beberapa UTXO menjadi input, sehingga mengungkapkan kepemilikan bersama dari UTXO tersebut karena COH. Jelas, metode-metode ini tidak dapat memperhitungkan label yang melekat pada UTXO, yang sangat penting untuk memilih koin yang akan diungkapkan kepada penerima transaksi secara sadar. Saat ini, satu-satunya solusi untuk mengoptimalkan privasi saat memilih koin adalah melakukannya secara manual.

### Tutorial tentang Pelabelan UTXO

Jika Anda ingin belajar cara melabeli UTXO Anda, kami telah membuat tutorial lengkap tentang perangkat lunak dompet Bitcoin utama yang ada:

https://planb.network/tutorials/privacy/utxo-labelling


## KYC dan Identifikasi Kunci
<chapterId>cec6b9d9-0eed-4f85-bc4e-1e9aa59ca605</chapterId>
KYC merupakan singkatan dari "Know Your Customer", yang merupakan prosedur regulasi yang diterapkan oleh beberapa perusahaan yang beroperasi di sektor Bitcoin. Prosedur ini bertujuan untuk memverifikasi dan mencatat identitas klien mereka dengan tujuan yang dinyatakan untuk memerangi pencucian uang dan pendanaan terorisme.
Secara konkret, KYC melibatkan pengumpulan berbagai data pribadi dari klien, yang dapat bervariasi menurut yurisdiksi, tetapi umumnya mencakup dokumen identitas, sebuah fotografi, dan bukti tempat tinggal. Informasi-informasi ini kemudian diverifikasi dan disimpan untuk penggunaan di masa depan.

Prosedur ini telah menjadi wajib bagi semua platform pertukaran yang diatur di sebagian besar negara Barat. Ini berarti bahwa siapa pun yang ingin menukar mata uang fiat dengan bitcoin melalui platform ini harus mematuhi persyaratan KYC.
Prosedur ini tidak tanpa risiko bagi kerahasiaan dan keamanan pengguna. Dalam bab ini, kita akan memeriksa risiko-risiko ini secara detail dan menganalisis dampak spesifik dari KYC dan proses identifikasi terhadap privasi pengguna Bitcoin.
### Memudahkan Pelacakan Onchain

Risiko pertama yang terkait dengan KYC adalah bahwa itu menyediakan titik masuk yang istimewa untuk analisis rantai. Seperti yang kita lihat di bagian sebelumnya, analis dapat mengelompokkan dan melacak aktivitas di blockchain menggunakan pola transaksi dan heuristik. Setelah mereka berhasil mengelompokkan aktivitas onchain seorang pengguna, menemukan hanya satu titik masuk di antara semua transaksi dan kunci mereka cukup untuk sepenuhnya mengkompromikan privasi mereka.

![BTC204](assets/notext/43/1.webp)

Ketika Anda menjalani KYC, Anda menyediakan titik masuk berkualitas tinggi untuk analisis rantai, karena Anda menghubungkan alamat penerimaan Anda yang digunakan saat menarik bitcoin Anda dari platform pertukaran ke identitas Anda yang lengkap dan diverifikasi. Secara teori, informasi ini hanya diketahui oleh perusahaan yang Anda berikan, tetapi, seperti yang akan kita lihat nanti, risiko kebocoran data adalah nyata. Selain itu, sekadar fakta bahwa sebuah perusahaan memiliki informasi ini bisa menjadi masalah, bahkan jika tidak membagikannya.

Jadi, jika Anda tidak mengambil langkah lain untuk membatasi pengelompokan aktivitas Anda di blockchain, siapa pun yang mengetahui titik masuk ini yaitu KYC dapat berpotensi menghubungkan seluruh aktivitas Anda di Bitcoin ke identitas Anda. Dari perspektif perusahaan ini, penggunaan Bitcoin Anda oleh karena itu kehilangan semua kerahasiaan.

![BTC204](assets/notext/43/2.webp)

Untuk mengilustrasikan ini dengan perbandingan, ini seperti jika bankir Anda dari *Bank X* memiliki akses tidak hanya ke semua transaksi Anda yang dilakukan dengan *Bank X*, tetapi juga dapat mengamati transaksi Anda dengan *Bank Y* dan semua transaksi tunai Anda.

Ingat dari bagian pertama pelatihan ini: model privasi Bitcoin, seperti yang dirancang oleh Satoshi Nakamoto, bergantung pada pemisahan antara identitas pengguna dan pasangan kunci mereka. Meskipun lapisan privasi ini tidak lagi cukup hari ini, masih bijaksana untuk membatasi degradasinya sebanyak mungkin.

### Terpapar pada Pengawasan Negara

Masalah besar kedua dengan KYC adalah bahwa itu mengungkapkan kepada negara bahwa Anda telah memiliki bitcoin pada suatu titik. Ketika Anda membeli bitcoin melalui aktor yang diatur, menjadi mungkin bagi negara untuk mengetahui tentang kepemilikan ini. Saat ini, ini mungkin tampak sepele, tetapi penting untuk diingat bahwa masa depan politik dan ekonomi negara Anda tidak ada di tangan Anda.
Pertama dan terutama, negara dapat dengan cepat mengadopsi sikap otoriter. Sejarah penuh dengan contoh di mana kebijakan telah berubah secara tiba-tiba. Hari ini, di Eropa, para penggemar Bitcoin dapat menulis artikel tentang Bitcoin, berpartisipasi dalam konferensi, dan mengelola dompet mereka dalam penyimpanan sendiri. Tapi siapa yang bisa mengatakan apa yang akan terjadi besok? Jika Bitcoin tiba-tiba menjadi musuh umum nomor satu, dikaitkan dengan itu dalam catatan negara bisa menjadi masalah.
Selanjutnya, di tengah krisis ekonomi yang parah, negara bisa mempertimbangkan untuk menyita bitcoin yang dimiliki oleh warganya. Mungkin besok, para Bitcoiner akan dilihat sebagai orang yang mengambil keuntungan dari krisis dan akan dikenakan pajak berlebihan karena keuntungan modal mereka di hadapan depresiasi mata uang fiat.

Anda mungkin berpikir ini bukan masalah karena bitcoin Anda dicampur, dan oleh karena itu tidak dapat dilacak. Namun, pelacakan bukanlah masalah di sini. Masalah sebenarnya adalah bahwa negara tahu Anda telah memiliki bitcoin. Informasi sederhana ini bisa cukup untuk menuduh Anda atau menuntut sebuah laporan. Anda bisa mencoba mengklaim bahwa Anda telah menghabiskan bitcoin Anda, tetapi ini harus tercermin dalam laporan pajak Anda, dan Anda akan tertangkap. Anda juga bisa mengatakan bahwa Anda kehilangan kunci Anda dalam sebuah kecelakaan perahu, tetapi di luar lelucon di Twitter, apakah Anda benar-benar berpikir itu akan cukup untuk membebaskan Anda?

Oleh karena itu, penting untuk mempertimbangkan risiko yang terkait dengan kenyataan bahwa negara bisa tahu Anda telah memiliki BTC, meskipun risiko ini mungkin terlihat jauh hari ini.

Masalah lain yang ditimbulkan oleh KYC dalam hal pengawasan negara adalah pelaporan wajib oleh platform yang diatur. Meskipun saya tidak familiar dengan regulasi di yurisdiksi lain, di Prancis, *Penyedia Layanan Aset Digital* (PSAN) diwajibkan untuk melaporkan kepada otoritas pengawasan keuangan setiap pergerakan dana yang mereka anggap mencurigakan.

Dengan demikian, di Prancis pada tahun 2023, 1.449 tindakan mencurigakan dilaporkan oleh PSAN. Untuk saat ini, mayoritas tindakan ini terkait dengan kriminalitas. Namun, otoritas juga meminta platform yang diatur untuk melaporkan setiap transaksi Bitcoin yang mencurigakan hanya berdasarkan strukturnya. Jika Anda melakukan transaksi kolaboratif, atau bahkan hanya transaksi yang menunjukkan pola yang agak tidak biasa, dan transaksi ini terjadi dekat dengan penarikan bitcoin Anda dari platform ini, Anda bisa menemukan diri Anda dilaporkan kepada otoritas. Bahkan dalam ketiadaan kesalahan dan dalam pelaksanaan hak Anda yang sah, pelaporan ini bisa menyebabkan peningkatan pemeriksaan dan pengawasan, ketidaknyamanan yang akan Anda hindari tanpa KYC.

### Risiko kebocoran data pribadi
Masalah lain dengan KYC terletak pada fakta bahwa ini memerlukan penyimpanan semua data pribadi Anda di server perusahaan swasta. Kejadian terbaru mengingatkan kita bahwa tidak ada yang kebal terhadap kegagalan, baik itu keuangan atau terkait IT. Pada tahun 2022, pelanggan Celsius menderita akibatnya. Menyusul kebangkrutan perusahaan, nama kreditur dan jumlah aset mereka diumumkan oleh sistem keadilan Amerika selama prosedur administratif.

Sedikit lebih dari dua tahun yang lalu, sebuah entitas keamanan siber terkemuka di domain cryptocurrency mengalami pencurian data pribadi kliennya. Meskipun insiden ini tidak langsung terkait dengan pembelian bitcoin, risiko semacam itu juga tetap ada untuk platform pertukaran. Oleh karena itu, ada risiko yang pasti terkait dengan data pribadi ini.

Memang benar bahwa kita sudah mempercayakan banyak data pribadi kita kepada perusahaan swasta. Namun, risiko di sini adalah dua kali lipat karena data ini tidak hanya memungkinkan Anda untuk diidentifikasi tetapi juga dikaitkan dengan aktivitas pada Bitcoin. Memang, ketika seorang peretas berhasil mengakses data klien dari platform pertukaran, mereka dapat dengan wajar mengasumsikan bahwa klien ini memiliki bitcoin. Risiko ini dengan demikian ditingkatkan oleh fakta bahwa bitcoin, seperti aset berharga lainnya, menarik minat pencuri.

Dalam hal terjadi pelanggaran data, dalam skenario terbaik, Anda bisa menjadi target upaya phishing yang ditargetkan. Dalam kasus terburuk, Anda bisa menemukan diri Anda di pusat ancaman fisik ke rumah Anda.
Selain risiko spesifik yang terkait dengan Bitcoin, juga perlu mempertimbangkan bahaya yang terkait dengan transmisi dokumen identitas. Memang, dalam kasus kebocoran data, seseorang dapat menjadi korban pencurian identitas. Dengan demikian, taruhannya tidak hanya terbatas pada perlindungan kerahasiaan transaksi tetapi juga menyangkut keselamatan pribadi setiap individu.

### Kesalahpahaman Umum tentang KYC

Penting untuk membongkar beberapa kesalahpahaman umum tentang KYC yang sering ditemukan di Twitter atau dalam diskusi kita di antara para pengguna bitcoin.
Pertama dan terutama, adalah salah untuk berpikir bahwa melindungi privasi untuk bitcoin yang diperoleh melalui KYC (Know Your Customer) adalah sia-sia. Alat dan metode untuk privasi pada Bitcoin bervariasi dan melayani tujuan yang berbeda. Penggunaan transaksi coinjoin pada bitcoin dari KYC, misalnya, bukanlah ide yang buruk. Tentu saja, perlu berhati-hati dengan platform pertukaran yang diatur untuk menghindari pembekuan atau pemblokiran akun seseorang, tetapi dari sudut pandang teknis yang ketat, praktik ini tidak tidak kompatibel. Coinjoin memiliki efek memutus sejarah sebuah koin, yang membantu Anda melawan beberapa risiko analisis rantai yang terkait dengan KYC. Meskipun tidak menghilangkan semua risiko, itu sudah mewakili manfaat yang signifikan.
![BTC204](assets/notext/43/3.webp)

Privasi pada Bitcoin tidak seharusnya dilihat secara biner, sebagai perbedaan antara bitcoin "anonim" dan yang lainnya tidak. Memiliki bitcoin yang diperoleh melalui KYC tidak berarti semuanya hilang; sebaliknya, penggunaan alat privasi dapat terbukti bahkan lebih bermanfaat.

Sebaliknya, memperoleh bitcoin melalui metode non-KYC tidak menjamin privasi sempurna dan tidak membebaskan seseorang dari kebutuhan untuk mengambil tindakan perlindungan lainnya. Jika Anda memegang bitcoin non-KYC tetapi menggunakan kembali alamat penerimaan beberapa kali, transaksi Anda dapat dilacak dan dikelompokkan. Hubungan terkecil dengan dunia di luar Bitcoin dapat mengompromikan satu-satunya lapisan privasi yang Anda miliki. Oleh karena itu, penting untuk mempertimbangkan semua alat dan metode yang meningkatkan privasi pada Bitcoin sebagai pelengkap. Setiap teknik mengatasi risiko spesifik dan dapat menambahkan lapisan perlindungan tambahan. Dengan demikian, memiliki bitcoin non-KYC sama sekali tidak membebaskan seseorang dari mengambil tindakan pencegahan lainnya.

### Dapatkah KYC dibatalkan?

Saya terkadang ditanya apakah mungkin untuk "kembali" setelah menyelesaikan KYC, dan seperti yang dapat Anda bayangkan dari paragraf sebelumnya, jawabannya bersifat nuansa. Untuk menghindari risiko yang terkait dengan KYC, metode paling sederhana adalah tidak menggunakannya saat memperoleh bitcoin. Kami akan mendalami topik ini lebih dalam di bab berikutnya. Namun, jika KYC sudah dilakukan dan bitcoin telah dibeli, apakah ada cara untuk mengurangi risiko yang ditimbulkan?

Mengenai risiko pelacakan transaksi Anda, penggunaan coinjoin adalah solusi. Kami akan membahas metode ini secara detail nanti dalam pelatihan, tetapi sadarilah bahwa coinjoin dapat memutus sejarah sebuah koin dan mencegah pelacakan masa lalu-sekarang dan sekarang-masa lalu. Bahkan untuk BTC yang diperoleh melalui platform yang diatur, teknik ini dapat mencegah pelacakannya.
Namun, coinjoin tidak menghilangkan risiko kedua yang terkait dengan KYC: fakta bahwa negara mengetahui kepemilikan bitcoin Anda. Memang, meskipun koin Anda tidak lagi dapat dilacak, negara, tergantung pada yurisdiksi, mungkin memiliki akses ke deklarasi Anda tentang penjualan aset kripto. Karena risiko ini bukan teknis tetapi administratif, tidak ada solusi spesifik Bitcoin untuk menghilangkannya, selain tidak memaparkan diri Anda pada KYC sejak awal. Pendekatan legal satu-satunya untuk mengurangi risiko ini adalah menjual bitcoin Anda yang diperoleh melalui platform teratur di platform teratur, dan kemudian membelinya kembali melalui cara tanpa KYC. Dengan menjual dan mendeklarasikan penjualan tersebut, administrasi seharusnya mencatat bahwa Anda tidak lagi memilikinya.

Adapun risiko kebocoran data pribadi dan dokumen identitas Anda, ini adalah bahaya yang eksternal terhadap Bitcoin, dan tidak ada solusi teknis untuk menghindarinya. Setelah data Anda terungkap, sulit untuk membalikkan operasi ini. Anda dapat mencoba menutup akun Anda di platform tersebut, tetapi ini tidak menjamin penghapusan data KYC Anda, terutama ketika verifikasi identitas diserahkan ke pihak ketiga. Memverifikasi penghapusan lengkap informasi Anda adalah mustahil. Oleh karena itu, tidak ada solusi untuk sepenuhnya mencegah risiko ini dan memastikan itu tidak lagi ada.

### Perbedaan antara KYC dan identifikasi kunci

Terkadang, beberapa bitcoiner cenderung memperluas istilah "KYC" ke setiap pertukaran BTC yang melibatkan transfer atau pembayaran kartu kredit, karena cara-cara ini juga dapat mengungkapkan asal pembayaran, sama seperti KYC. Namun, penting untuk tidak mengacaukan KYC dengan identifikasi kunci. Secara pribadi, saya harus mengakui bahwa persepsi saya tentang subjek ini telah berkembang seiring waktu.

KYC secara spesifik merujuk pada prosedur regulasi yang diterapkan oleh beberapa perusahaan untuk memverifikasi dan mencatat identitas klien mereka. Ini adalah hal biner: ketika memperoleh bitcoin Anda, entah Anda menjalani KYC, atau tidak. Namun, identifikasi kunci, yang menyangkut pengaitan aspek identitas pengguna dengan aktivitas onchain, tidak sebiner itu tetapi lebih mewakili kontinum. Memang, dalam konteks memperoleh atau mendisposisi bitcoin, identifikasi ini selalu mungkin dilakukan dalam berbagai derajat.
Misalnya, jika Anda membeli bitcoin di platform teratur di Swiss, KYC (Know Your Customer) tidak diperlukan. Namun, mungkin ada identifikasi kunci Anda karena pembelian dilakukan melalui rekening bank Anda. Inilah di mana dua risiko pertama yang terkait dengan KYC — memfasilitasi pelacakan onchain dan paparan terhadap pengawasan negara — juga dapat muncul dalam pertukaran non-KYC. Jika entitas Swiss melaporkan transaksi mencurigakan kepada otoritas di negara Anda, mereka dapat dengan mudah memeriksa rekening bank yang digunakan untuk pembelian untuk menemukan identitas Anda. Jadi, membeli tanpa KYC di platform teratur cukup tinggi dalam skala risiko untuk identifikasi kunci.

Namun, menghindari platform teratur dan memilih metode akuisisi P2P (Peer-to-Peer) tidak sepenuhnya menghilangkan risiko identifikasi kunci tetapi hanya menguranginya. Pertimbangkan contoh pembelian di Bisq atau platform P2P lainnya. Untuk menyelesaikan dengan lawan Anda, Anda mungkin akan menggunakan rekening bank Anda. Jika otoritas menanyai orang yang Anda berdagang dengannya dan meminta nama Anda, kita menemui risiko 1 dan 2 yang disebutkan sebelumnya. Risiko-risiko ini tentu jauh lebih rendah daripada selama pembelian non-KYC di platform, dan bahkan lebih berkurang daripada selama pembelian dengan KYC, tetapi masih hadir dalam tingkat yang lebih rendah.
Akhirnya, meskipun Anda memperoleh bitcoin Anda melalui pertukaran fisik dengan uang tunai, Anda tidak sepenuhnya anonim. Orang yang Anda bertransaksi dengannya telah melihat wajah Anda, yang merupakan bagian dari identitas Anda. Meskipun minimal dalam contoh ini, masih ada kemungkinan identifikasi kunci.
![BTC204](assets/notext/43/6.webp)

Kesimpulannya, selama pertukaran bitcoin untuk aset lain, baik itu pembelian dalam mata uang fiat atau penjualan untuk barang nyata, selalu ada bentuk identifikasi kunci. Tergantung pada metode pertukaran yang dipilih, identifikasi ini dapat bervariasi intensitasnya. Penting untuk tidak mengacaukan identifikasi ini dengan KYC, yang merupakan proses regulasi yang jelas terdefinisi. Namun, ada hubungan antara KYC dan spektrum identifikasi, karena KYC berada di ujung atas spektrum ini, karena secara sistematis memfasilitasi identifikasi kunci pengguna oleh otoritas.

## Metode Penjualan dan Akuisisi
<chapterId>756598af-95aa-4c77-ac48-243c7ad89530</chapterId>
Setelah membaca bab sebelumnya, Anda mungkin bertanya-tanya tentang cara membeli atau menjual bitcoin tanpa harus menjalani proses verifikasi identitas, untuk menghindari risiko yang terkait dengan KYC. Ada beberapa metode untuk melakukan pertukaran.

### Pertukaran P2P Tunai

Seperti yang telah kita lihat, metode terbaik dalam hal privasi tetaplah pertukaran P2P (peer-to-peer) dengan penyelesaian tunai. Metode ini memungkinkan Anda untuk meminimalkan jejak yang ditinggalkan dan secara signifikan mengurangi kemungkinan identifikasi kunci, baik Anda pembeli atau penjual.

![BTC204](assets/notext/44/01.webp)

Namun, praktik ini membawa risiko terhadap keamanan pribadi. Bahaya utama terletak pada fakta bahwa selama pertukaran, pihak lawan akan tahu bahwa Anda memiliki jumlah yang signifikan, baik dalam bentuk tunai atau bitcoin. Informasi ini dapat menarik perhatian individu yang bermaksud jahat. Memang, umumnya disarankan untuk tetap diskrit tentang kepemilikan bitcoin Anda. Saran ini juga dapat diterapkan pada uang tunai. Namun, selama pertukaran langsung, tidak terhindarkan untuk mengungkapkan bahwa Anda memiliki bitcoin, yang dapat membangkitkan keinginan.

![BTC204](assets/notext/44/02.webp)

Untuk membatasi risiko ini, saya menyarankan Anda untuk memprioritaskan transaksi tunai dengan individu yang dapat dipercaya, seperti anggota keluarga atau teman dekat. Sebagai alternatif, Anda juga dapat mempertimbangkan untuk melakukan pertukaran di [pertemuan Bitcoin lokal](https://btcmap.org/communities/map), setelah menghadiri beberapa kali. Ini akan memungkinkan Anda untuk mengenal peserta lain lebih baik dan tidak sendirian selama pertukaran fisik. Namun, penting untuk mengakui bahwa pertukaran P2P tunai secara inheren membawa risiko terhadap keamanan pribadi Anda yang tidak ada saat melakukan pembelian melalui platform yang diatur dan rekening bank Anda.

Selain itu, tergantung pada tempat Anda tinggal, membawa dan menyimpan jumlah uang besar dapat menimbulkan risiko, baik itu untuk bitcoin atau tunai.

Pertukaran tunai juga dapat menimbulkan risiko hukum selama pemeriksaan polisi atau lainnya. Meskipun di sebagian besar negara, tidak ada pembatasan jumlah tunai yang dapat Anda bawa, jumlah yang terlalu besar dapat menimbulkan kecurigaan. Jadi, berhati-hatilah, terutama jika Anda harus melakukan perjalanan jarak jauh, dan hindari melakukan transaksi besar sekaligus untuk tidak harus membenarkan kepemilikan jumlah yang signifikan.
Akhirnya, kerugian lain dari pembelian P2P adalah harga seringkali lebih tinggi daripada yang diamati pada platform teratur. Penjual seringkali memberlakukan markup yang berkisar dari 1% hingga terkadang lebih dari 10%. Beberapa alasan menjelaskan perbedaan harga ini. Pertama, ini adalah praktik umum di antara penjual P2P yang telah terbentuk seiring waktu. Selanjutnya, penjual memiliki biaya transaksi yang terkait dengan pengiriman dana ke pembeli. Ada juga risiko pencurian yang lebih tinggi dalam penjualan P2P dibandingkan dengan transaksi di platform, yang membenarkan kompensasi untuk risiko yang diambil. Terakhir, biaya tambahan dapat terkait dengan permintaan dan kualitas pertukaran dalam hal privasi. Sebagai pembeli, keuntungan dalam privasi memiliki harga yang tercermin dalam markup yang diterapkan oleh penjual. Beberapa pengguna bitcoin juga percaya bahwa harga BTC yang lebih tinggi yang dibeli di P2P mencerminkan nilai sebenarnya, dan berpendapat bahwa harga lebih rendah di platform teratur adalah hasil dari kompromi pada privasi data pribadi Anda.

### Pertukaran P2P melalui Platform Pencocokan

Alternatif yang kurang berisiko dalam hal keamanan pribadi adalah melakukan pertukaran P2P secara eksklusif online, melalui metode pembayaran elektronik seperti PayPal, transfer bank, atau Revolut.

Pendekatan ini membantu menghindari banyak risiko yang terkait dengan transaksi tunai. Namun, risiko bahwa pihak lawan tidak memenuhi komitmennya selama pertukaran online lebih besar. Memang, selama pertukaran fisik, jika Anda menyerahkan uang kepada penjual yang tidak mengirimkan bitcoin sebagai gantinya, Anda dapat langsung meminta pertanggungjawaban karena mereka berada di depan Anda. Secara online, di sisi lain, seringkali mustahil untuk menemukan orang yang telah mencuri dari Anda.

Untuk mengurangi risiko ini, dimungkinkan untuk menggunakan platform yang mengkhususkan diri dalam pencocokan untuk pertukaran P2P. Platform ini menggunakan mekanisme resolusi konflik untuk melindungi pengguna yang dirugikan. Umumnya, mereka menawarkan sistem escrow, di mana bitcoin ditahan sampai pembayaran mata uang fiat dikonfirmasi oleh penjual.

Dalam hal keamanan pribadi, metode pembelian ini secara signifikan lebih aman daripada pertukaran tunai fisik. Namun, seperti disebutkan sebelumnya, pertukaran P2P online meninggalkan lebih banyak jejak daripada pertukaran fisik, yang dapat merugikan privasi pada Bitcoin. Dengan menggunakan metode pembayaran fiat online seperti bank, Anda mengekspos lebih banyak informasi yang dapat memfasilitasi identifikasi kunci.

Sekali lagi, saya merekomendasikan untuk tidak melakukan pertukaran besar dalam satu transaksi di platform ini. Dengan membagi transaksi Anda, Anda menyebarkan risiko yang terkait dengan pencurian potensial oleh pihak lawan.
Sekali lagi, salah satu kelemahan pembelian P2P adalah harga seringkali lebih tinggi daripada yang terlihat di platform teratur. Penjual seringkali memberlakukan markup yang berkisar dari 1% hingga terkadang lebih dari 10%. Beberapa alasan menjelaskan perbedaan harga ini. Pertama, ini adalah praktik umum di antara penjual P2P yang telah terbentuk seiring waktu. Selanjutnya, penjual memiliki biaya transaksi yang terkait dengan pengiriman dana ke pembeli. Ada juga risiko pencurian yang meningkat dalam penjualan P2P dibandingkan dengan transaksi di platform, yang membenarkan kompensasi untuk risiko yang diambil. Akhirnya, biaya tambahan dapat terkait dengan permintaan dan kualitas pertukaran dalam hal privasi. Sebagai pembeli, keuntungan dalam privasi memiliki harga yang tercermin dalam markup yang diterapkan oleh penjual. Beberapa pengguna bitcoin juga percaya bahwa harga BTC yang lebih tinggi yang dibeli P2P mencerminkan nilai sebenarnya, dan berpendapat bahwa harga lebih rendah di platform teratur adalah hasil dari kompromi pada privasi data pribadi Anda.
![BTC204](assets/notext/44/03.webp)

Mengenai solusi, saya secara pribadi selalu menggunakan [Bisq](https://bisq.network/) dan sangat puas dengan itu. Sistem mereka sudah terbentuk dengan baik dan tampaknya dapat diandalkan. Namun, Bisq hanya tersedia di PC dan antarmukanya mungkin terlalu kompleks untuk pemula. Kelemahan lain adalah Bisq beroperasi hanya dengan transaksi onchain, yang dapat menjadi mahal selama periode biaya transaksi Bitcoin yang tinggi.

[-> Temukan tutorial kami tentang Bisq.](https://planb.network/en/tutorials/exchange/bisq)

Untuk opsi yang lebih sederhana, Anda dapat mencoba [Peach](https://peachbitcoin.com/), aplikasi seluler yang memfasilitasi koneksi antara pembeli dan penjual dengan sistem penyelesaian sengketa terintegrasi. Prosesnya lebih intuitif daripada Bisq.

[-> Temukan tutorial kami tentang Peach.](https://planb.network/en/tutorials/exchange/peach-wallet)
Opsi online lainnya adalah [HodlHodl](https://hodlhodl.com/), platform yang sudah terbentuk dengan baik yang menawarkan likuiditas yang baik, meskipun saya secara pribadi belum mencobanya.
[-> Temukan tutorial kami tentang HodlHodl.](https://planb.network/en/tutorials/exchange/hodlhodl)

Untuk solusi berbasis Lightning Network, Anda dapat mencoba [RoboSats](https://learn.robosats.com/) dan [LNP2PBot](https://lnp2pbot.com/). RoboSats dapat diakses melalui situs web dan relatif sederhana untuk digunakan. LNP2PBot lebih atipikal, karena beroperasi melalui sistem pertukaran di aplikasi perpesanan Telegram.

[-> Temukan tutorial kami tentang RoboSats.](https://planb.network/en/tutorials/exchange/robosats)
[-> Temukan tutorial kami tentang LNP2PBot.](https://planb.network/en/tutorials/exchange/lnp2pbot)

![BTC204](assets/notext/44/08.webp)

### Platform Teratur tanpa KYC

Tergantung pada negara tempat Anda tinggal, Anda mungkin memiliki akses ke platform teratur yang tidak memerlukan prosedur KYC untuk membeli atau menjual bitcoin. Di Swiss, misalnya, Anda dapat menggunakan platform seperti [Relai](https://relai.app/) dan [MtPelerin](https://www.mtpelerin.com/).

[-> Temukan tutorial kami tentang Relai.](https://planb.network/en/tutorials/exchange/relai)
Seperti yang kita lihat di bab sebelumnya, jenis platform ini menghindarkan Anda dari risiko yang terkait dengan prosedur KYC, tetapi mereka menyajikan tingkat risiko yang lebih tinggi untuk identifikasi kunci. Dalam hal privasi pada Bitcoin, platform ini oleh karena itu menawarkan perlindungan yang lebih baik daripada metode pembelian dengan KYC, tetapi mereka kurang menarik daripada pertukaran P2P.
Namun, dalam hal keamanan pribadi, menggunakan platform ini secara signifikan kurang berisiko daripada pertukaran P2P. Mereka juga seringkali lebih sederhana untuk digunakan daripada platform yang memfasilitasi pertukaran P2P.

### ATM

Opsi lain untuk membeli atau menjual bitcoin tanpa KYC adalah ATM cryptocurrency (ATM). Secara pribadi, saya belum pernah memiliki kesempatan untuk mencoba solusi ini, karena tidak ada di negara saya. Namun, metode ini bisa sangat menarik tergantung di mana Anda tinggal.

![BTC204](assets/notext/44/09.webp)
Masalah dengan ATM adalah bahwa mereka dilarang di beberapa negara atau diatur secara ketat di negara lain. Jika sebuah ATM memerlukan proses verifikasi identitas, maka itu menghadapi risiko yang sama seperti yang melekat pada platform KYC yang diatur. Namun, jika ATM memungkinkan transaksi tanpa verifikasi identitas untuk jumlah kecil, maka penggunaannya dapat menawarkan tingkat privasi yang sebanding dengan pertukaran P2P berbasis uang tunai, sambil menghindari sebagian besar risiko yang terkait dengan jenis pertukaran ini.
Kekurangan utama dari ATM terletak pada biaya tukar mereka yang seringkali tinggi, yang berkisar dari beberapa persen hingga terkadang 15% dari jumlah yang ditukar.

### Kartu Hadiah

Akhirnya, saya juga ingin memperkenalkan solusi yang berfungsi baik bagi mereka yang ingin menggunakan bitcoin mereka sehari-hari untuk pembelian daripada menjualnya untuk mata uang fiat.

Cara terbaik untuk menghabiskan BTC tentunya adalah menggunakan Bitcoin secara langsung atau Lightning Network untuk membeli barang atau jasa. Namun, di banyak negara, jumlah pedagang yang menerima bitcoin masih terbatas. Alternatif praktis kemudian adalah penggunaan kartu hadiah.

Beberapa platform yang tidak memerlukan prosedur KYC menawarkan kemungkinan untuk menukar bitcoin dengan kartu hadiah yang dapat digunakan di toko besar. Di antara platform ini, kita temukan [CoinsBee](https://www.coinsbee.com/), [The Bitcoin Company](https://thebitcoincompany.com/), dan [Bitrefill](https://www.bitrefill.com/). Platform ini sangat memudahkan penggunaan sehari-hari bitcoin Anda dengan memungkinkan Anda mengakses berbagai produk dan layanan tanpa harus melalui konversi ke mata uang fiat.

![BTC204](assets/notext/44/10.webp)

### Metode Akuisisi Lainnya

Di antara metode lain untuk memperoleh bitcoin sambil melindungi privasi Anda, tentu saja ada penambangan. Untuk mulai menambang sats, tidak perlu mengungkapkan identitas Anda; Anda hanya perlu menemukan bukti kerja yang valid dan mengirimkannya ke jaringan. Jika Anda memilih penambangan kolam, beberapa kolam memerlukan bentuk identifikasi, seperti KYC, sementara yang lain tidak.

Metode lain terdiri dari bekerja sebagai imbalan untuk bitcoin. Metode akuisisi ini bisa menarik, tetapi tingkat identifikasi yang diperlukan sangat bervariasi tergantung pada keadaannya.

*Untuk menulis bab ini, saya menggunakan kursus [BTC205](https://planb.network/fr/courses/btc205) yang dibuat oleh [@pivi___](https://x.com/pivi___) di PlanB Network (hanya tersedia dalam bahasa Prancis untuk saat ini).*

## Konsolidasi, Manajemen UTXO, dan CIOH
<chapterId>d0486c8f-332d-402b-ae2e-949416752b9c</chapterId>
Salah satu aspek paling rumit untuk dikelola ketika Anda memiliki dompet self-custody Anda sendiri adalah tanpa ragu konsolidasi. Apakah Anda harus melakukan konsolidasi? Apa tujuannya? Berapa besar UTXO yang harus Anda targetkan? Apa saja trade-off dalam hal privasi? Inilah yang akan kita coba jelajahi di bagian ini.

### Apa itu konsolidasi?

Operasi Bitcoin mirip dengan pasar lelang di mana transaksi yang menawarkan biaya terbaik lebih disukai oleh penambang. Namun, setiap blok memiliki berat maksimum, yang membatasi jumlah transaksi yang dapat dimasukkan. Karena blok diproduksi rata-rata setiap 10 menit, ruang yang tersedia di setiap blok adalah sumber daya yang langka.

Penambang, yang aktivitasnya menimbulkan biaya signifikan dalam listrik, modal, dan pemeliharaan, secara alami berusaha untuk memaksimalkan profitabilitas mereka. Mereka cenderung memilih transaksi yang menawarkan mereka biaya paling banyak relatif terhadap beratnya.

Memang, tidak semua transaksi Bitcoin memiliki berat yang sama. Transaksi dengan lebih banyak input dan output akan memiliki berat lebih. Sebagai contoh, pertimbangkan 2 transaksi:
- Transaksi A mencakup 1 input dan 1 output. Ini mengalokasikan 1,994 sats dari biaya dan beratnya adalah 141 vB;
- Transaksi B, lebih kompleks, dengan 2 input dan 2 output, mengalokasikan 2,640 sats dari biaya untuk berat 220 vB.

![BTC204](assets/notext/45/01.webp)

Dalam contoh ini, meskipun transaksi B mengusulkan total biaya yang lebih tinggi, penambang akan memilih transaksi A karena menawarkan rasio yang lebih baik antara biaya dan berat. Berikut adalah perhitungan untuk setiap transaksi, dinyatakan dalam sats per virtual byte (sat/vB):

```text
TXA: 1994 / 141 = 14 sats/vB

TXB: 2640 / 220 = 12 sats / vB
```

Ini berarti bahwa untuk setiap unit berat, transaksi A menawarkan lebih banyak biaya daripada transaksi B, meskipun yang terakhir menawarkan lebih banyak biaya dalam nilai absolut.

![BTC204](assets/notext/45/02.webp)

Oleh karena itu, selalu lebih menarik bagi pengguna untuk mengonsumsi jumlah input yang paling sedikit mungkin dalam transaksi mereka. Namun, perlu untuk mengonsumsi jumlah yang cukup untuk dapat memenuhi pembayaran di output. Dalam mengelola dompet mereka, seseorang harus memiliki UTXO yang cukup besar.

Prinsip konsolidasi adalah tepat untuk memanfaatkan periode ketika biaya rendah di Bitcoin untuk menggabungkan UTXO kecil seseorang menjadi satu yang lebih besar. Dengan demikian, ketika biaya meningkat di Bitcoin, seseorang dapat melakukan transaksi dengan minimum input, dan oleh karena itu menghabiskan lebih sedikit dalam biaya absolut. Tujuannya adalah untuk merencanakan transaksi wajib yang harus dilakukan selama periode biaya tinggi.

![BTC204](assets/en/45/03.webp)
Selain penghematan pada biaya transaksi, mengkonsolidasikan UTXO membantu menghindari penciptaan "debu." Debu merujuk pada UTXO yang nilai dalam sats sangat rendah sehingga tidak cukup untuk menutupi biaya transaksi yang diperlukan untuk menghabiskannya. Ini membuat UTXO tersebut secara ekonomi tidak rasional untuk digunakan selama biaya transaksi tetap tinggi. Dengan secara proaktif mengelompokkan UTXO Anda, Anda mencegah mereka berubah menjadi debu, memastikan bahwa semua dana Anda tetap dapat digunakan.

### Berapa ukuran minimum untuk UTXO Anda?

Terkadang, saya ditanya apa nilai minimum yang direkomendasikan untuk UTXO. Sayangnya, tidak ada jawaban universal, karena itu tergantung pada preferensi Anda dan kondisi pasar untuk biaya. Namun, berikut adalah rumus yang dapat membantu Anda menentukan ambang batas yang sesuai dengan kebutuhan Anda:

$$
\frac {P \times F}T = M
$$

Dimana:
- $P$ adalah berat transaksi;
- $F$ mewakili tarif maksimum dalam satoshi per vbyte (sats/vB) yang Anda tanggung;
- $T$ adalah persentase biaya transaksi yang Anda bersedia bayar relatif terhadap nilai total UTXO;
- $M$ adalah jumlah minimum dalam satoshi untuk setiap UTXO.

Dengan asumsi Anda berencana untuk menanggung biaya untuk transaksi SegWit standar dengan 1 input dan 2 output, dengan berat 141 vB. Jika Anda menanggung hingga 800 sats/vB, dan Anda bersedia menghabiskan hingga 12% dari nilai UTXO dalam biaya paling banyak, maka perhitungannya akan menjadi:

$$
\frac{141 \times 800}{0.12} = 940\ 000
$$

Dalam contoh ini, akan bijaksana untuk mempertahankan nilai minimum 940.000 sats untuk UTXO di dompet Anda.

### Konsolidasi dan COIH

Salah satu heuristik yang paling sering digunakan dalam analisis rantai adalah COIH (*Common Input Ownership Heuristic*), yang memungkinkan asumsi bahwa semua input dari transaksi Bitcoin milik entitas yang sama. Secara tepat, prinsip konsolidasi adalah untuk mengonsumsi beberapa UTXO sebagai input dan menciptakan satu UTXO sebagai output. Oleh karena itu, konsolidasi memungkinkan penerapan COIH.

![BTC204](assets/notext/45/04.webp)

Dalam praktiknya, ini berarti bahwa pengamat eksternal dapat menyimpulkan bahwa semua UTXO yang dikonsolidasi kemungkinan besar milik orang yang sama dan bahwa output tunggal yang dihasilkan juga milik mereka. Situasi ini dapat membahayakan privasi Anda dengan menghubungkan berbagai sejarah transaksi. Misalnya, katakanlah saya mengkonsolidasikan 3 UTXO yang diperoleh dalam P2P dengan UTXO yang diperoleh melalui platform yang memerlukan KYC:
![BTC204](assets/notext/45/05.webp)

Dengan melakukan ini, setiap entitas dengan akses ke data platform pertukaran, termasuk kemungkinan agen pemerintah, dapat mengidentifikasi bahwa saya memiliki jumlah lain dalam BTC. Sebelumnya, UTXO ini tidak langsung terkait dengan identitas saya; sekarang, mereka adalah. Selain itu, ini mengungkapkan kepada semua sumber bahwa saya memiliki sejumlah bitcoin.

Dalam mengelola UTXO, pertimbangan ekonomi, yang mendorong konsolidasi untuk mengurangi biaya, sehingga bertentangan dengan praktik privasi yang baik, yang akan merekomendasikan agar Anda tidak pernah menggabungkan UTXO Anda. Pilihan antara ekonomi dan privasi oleh karena itu tergantung pada prioritas setiap pengguna.

Jika Anda dapat menghindari konsolidasi sambil mempertahankan ukuran UTXO yang substansial, itu ideal. Untuk melakukan ini, optimalkan metode akuisisi Anda. Jika Anda membeli bitcoin Anda dalam DCA, coba jarakkan pembelian satu kali Anda sebanyak mungkin untuk mengelompokkan nilai ke dalam UTXO yang lebih sedikit. Akan lebih mudah untuk mengelola pembelian satu kali sebesar €1.000 setiap 2 bulan, daripada pembelian €120 setiap minggu. Ini meminimalkan jumlah UTXO yang dihasilkan dan menyederhanakan pengelolaan dompet Anda sambil menjaga privasi Anda.

Jika Anda menemukan diri Anda perlu mengkonsolidasikan bitcoin Anda, prioritaskan terlebih dahulu konsolidasi UTXO dari sumber yang sama. Misalnya, menggabungkan 10 UTXO dari satu platform akan mempengaruhi privasi Anda lebih sedikit daripada mencampur 5 UTXO dari platform A dengan 5 UTXO dari platform B. Jika konsolidasi dari berbagai sumber tidak terelakkan, coba pisahkan mereka menurut karakteristik mereka. Misalnya, kelompokkan UTXO yang diperoleh melalui KYC dalam satu transaksi, dan yang diperoleh dalam P2P dalam transaksi lain.
Dalam hal apapun, ingatlah bahwa setiap konsolidasi pasti akan mengakibatkan kehilangan privasi. Oleh karena itu, evaluasilah dengan hati-hati kebutuhan operasi ini dan dampak potensial terhadap privasi Anda, dengan mempertimbangkan risikonya.

## Praktik Baik Lainnya
<chapterId>b5216965-7d13-4ea1-9b7c-e292966a487b</chapterId>

Mari kita jelajahi bersama beberapa praktik baik lainnya yang dapat membantu Anda mengoptimalkan privasi Anda pada Bitcoin.

### Node Penuh
Memiliki bitcoin Anda dalam penyimpanan sendiri itu bagus, tetapi menggunakan node penuh Anda sendiri lebih baik! Berikut adalah alasan mengapa memiliki node Anda sendiri sangat penting untuk penggunaan Bitcoin yang sepenuhnya berdaulat:
- **Ketahanan terhadap Sensor**: Transaksi Anda tidak dapat diblokir oleh siapapun;
- **Kemandirian dari Pihak Ketiga**: Anda tidak lagi bergantung pada layanan eksternal untuk memverifikasi data blockchain;
- **Partisipasi Aktif**: Anda memiliki kemampuan untuk menetapkan aturan validasi Anda sendiri dan langsung berpartisipasi dalam konsensus;
- **Kontribusi terhadap Jaringan**: Dengan menjalankan node, Anda membantu memperkuat dan mendistribusikan jaringan Bitcoin;
- **Pendidikan Teknis**: Mengelola node penuh adalah cara yang sangat baik untuk memperdalam pengetahuan teknis Anda tentang Bitcoin.

Selain manfaat-manfaat ini, menggunakan node penuh juga meningkatkan privasi Anda saat menyiarkan transaksi Anda. Ketika Anda mengeluarkan transaksi, itu pertama kali dibuat dan ditandatangani melalui dompet Anda. Untuk menyiarkannya di jaringan Bitcoin, setidaknya harus diketahui oleh satu node. Dengan menggunakan node Anda sendiri, Anda secara langsung mengontrol siaran ini, dengan demikian meningkatkan privasi Anda dan membatasi risiko kebocoran data.

![BTC204](assets/notext/46/01.webp)

Jika Anda tidak memiliki node Bitcoin Anda sendiri, Anda akan dipaksa untuk menggunakan node pihak ketiga, seperti yang ditawarkan oleh penyedia perangkat lunak dompet Anda. Selain penyiaran transaksi, dompet Anda memerlukan akses ke berbagai informasi seperti transaksi yang tertunda, saldo yang terkait dengan alamat Anda, atau jumlah konfirmasi untuk transaksi Anda. Untuk mengakses semua data ini, Anda perlu melakukan query ke sebuah node.

![BTC204](assets/notext/46/02.webp)

Risiko utama ketika Anda tidak menggunakan node Bitcoin Anda sendiri adalah bahwa operator node pihak ketiga dapat mengamati aktivitas Anda di blockchain, atau bahkan membagikan informasi ini dengan entitas lain. Untuk membatasi risiko ini, solusi perantara adalah menggunakan perangkat lunak dompet yang memungkinkan Anda untuk menyamarkan koneksi Anda melalui Tor. Ini dapat mengurangi paparan data Anda. Namun, solusi optimal tetap memiliki node Bitcoin Anda sendiri dan menggunakannya untuk penyiaran transaksi Anda. Tentu saja, Anda juga perlu memastikan bahwa tidak ada informasi yang bocor dari node Anda, tetapi itu adalah topik lain yang akan kita jelajahi di bagian selanjutnya.
Di luar keuntungan yang jelas untuk privasi Anda, memiliki node penuh Anda sendiri juga memastikan kebenaran data pada blockchain, melindungi dari sensor, dan memungkinkan Anda untuk berpartisipasi aktif dalam tata kelola Bitcoin. Dengan menggunakan node Anda sendiri, Anda memberikan bobot ekonomi Anda ke rantai pilihan Anda, yang penting selama konflik dalam komunitas, seperti selama Perang Ukuran Blok dari 2015 hingga 2017, misalnya. Dalam kejadian fork, menggunakan node pihak ketiga dapat membawa Anda untuk mendukung rantai yang tidak Anda inginkan, karena operator node membuat pilihan untuk Anda.
Seperti yang dapat Anda pahami, dalam kepedulian terhadap privasi dan lebih luas lagi kedaulatan individu, sangat penting untuk menjalankan dan menggunakan node penuh Anda sendiri!

### Mengelabui Heuristik Analisis
Secara lebih luas, penting untuk memahami heuristik yang kita bahas di bagian sebelumnya, agar dapat lebih baik menghindari atau mengecohnya. Mengadopsi serangkaian praktik baik dapat terbukti bermanfaat, meskipun tidak mutlak diperlukan. Mereka menawarkan lapisan perlindungan tambahan yang bisa penting untuk menjaga privasi yang baik saat menggunakan Bitcoin.

Saran pertama yang bisa saya berikan adalah untuk berbaur dalam kerumunan yang paling padat. Di Bitcoin, ini berarti menggunakan pola skrip yang paling banyak diadopsi. Sebagai contoh, skrip P2WSH, yang sering digunakan untuk konfigurasi multisig SegWit V0, sangat jarang. Mereka tidak memungkinkan Anda untuk bersembunyi dalam set anonimitas yang besar. Hal yang sama berlaku untuk model lama seperti P2PKH atau P2SH. Meskipun mereka banyak hadir dalam set UTXO, mereka digunakan semakin sedikit untuk transaksi baru.

Secara umum, lebih aman untuk beralih ke standar skrip terbaru, asalkan cukup diadopsi. Jadi, jika pada tahun 2022, saya akan menyarankan untuk tidak menggunakan P2TR (Taproot) karena adopsinya yang rendah, pada tahun 2024, saya akan merekomendasikan untuk memilih jenis skrip ini, atau jika tidak, untuk skrip SegWit V0, karena jumlah transaksi yang menggunakan P2TR mulai mewakili bagian yang sangat signifikan.

![BTC204](assets/notext/46/03.webp)

Sumber: [txstats.com](https://txstats.com/d/000000054/utxo-set-repartition-by-output-type)
Tip lain untuk menjaga privasi Anda adalah mencoba untuk menghindari heuristik internal transaksi. Misalnya, saat melakukan pembayaran, Anda mungkin mencoba untuk menghindari membuat output dengan jumlah bulat, karena ini bisa menandakan bahwa output lainnya mewakili kembalian. Jika Anda perlu mengirim 100k sats ke teman, pertimbangkan untuk mentransfer jumlah yang sedikit lebih tinggi untuk menghindari heuristik ini. Demikian pula, cobalah untuk tidak membuat output kembalian yang secara tidak proporsional tinggi dibandingkan dengan pembayaran yang dilakukan, karena ini juga bisa mengungkapkan mana dari output tersebut yang mewakili kembalian.
![BTC204](assets/notext/46/04.webp)

Akhirnya, jika Anda melakukan transaksi Bitcoin secara rutin, pastikan untuk tidak selalu menyiarkannya pada waktu yang sama. Dengan menyebarkan penyiaran transaksi Anda sepanjang hari dan minggu, Anda menghindari memberi pengamat eksternal kemampuan untuk mendeteksi pola temporal berdasarkan zona waktu yang dapat meningkatkan analisis mereka.

Di luar semua praktik baik ini untuk diadopsi setiap hari, ada metode yang lebih efektif lagi untuk sepenuhnya memutuskan jejak bitcoin Anda. Di antaranya, tentu saja ada transaksi coinjoin yang akan kita pelajari lebih dalam di bagian berikutnya.

# Memahami Transaksi Coinjoin
<partId>6d0bbf16-3714-4db1-9897-2d45019f6bdc</partId>

## Apa itu Transaksi Coinjoin?
<chapterId>0862bc6b-1c48-4aa4-b76d-4f547b469008</chapterId>

Setelah mempelajari dasar-dasar perlindungan privasi, sekarang kita akan membahas teknik yang lebih canggih yang ditujukan untuk secara aktif mempertahankan privasi Anda, khususnya dengan memisahkan sejarah bitcoin Anda. Di bagian berikutnya, kita akan menjelajahi banyak teknik kecil, tetapi pertama-tama, saya ingin berbicara kepada Anda tentang coinjoin.

Coinjoin sering dianggap sebagai metode paling efektif untuk melindungi privasi pengguna Bitcoin. Tapi, apa sebenarnya transaksi coinjoin itu? Mari kita cari tahu bersama.

### Prinsip Dasar Coinjoin

Coinjoin adalah teknik yang memutus jejak bitcoin di blockchain. Ini bergantung pada transaksi kolaboratif dengan struktur khusus yang bernama sama: transaksi coinjoin.
Seperti yang telah kita lihat dalam bagian awal pelatihan ini, transaksi pada Bitcoin diketahui oleh semua pengguna melalui node mereka. Oleh karena itu, mudah untuk memverifikasi rantai tanda tangan elektronik dari setiap koin dan mengamati sejarahnya. Ini berarti bahwa semua pengguna dapat mencoba menganalisis transaksi pengguna lain. Akibatnya, anonimitas pada tingkat transaksi adalah tidak mungkin. Namun, anonimitas dipertahankan pada tingkat identifikasi individu. Berbeda dengan sistem perbankan tradisional di mana setiap akun dikaitkan dengan identitas pribadi, pada Bitcoin, dana dikaitkan dengan pasangan kunci kriptografi (atau skrip), sehingga menawarkan pengguna bentuk pseudonimitas di balik pengenal kriptografi.

Dengan demikian, kerahasiaan pada Bitcoin terkompromi ketika pengamat eksternal berhasil mengaitkan UTXO tertentu dengan pengguna yang teridentifikasi. Setelah asosiasi ini terbentuk, menjadi mungkin untuk melacak transaksi mereka dan menganalisis sejarah bitcoin mereka. Coinjoin adalah teknik yang dikembangkan secara khusus untuk memutuskan kemampuan pelacakan UTXO, guna menawarkan lapisan kerahasiaan tertentu kepada pengguna Bitcoin pada tingkat transaksi.

Coinjoin meningkatkan kerahasiaan pengguna Bitcoin dengan mempersulit analisis rantai bagi pengamat eksternal. Strukturnya memungkinkan penggabungan beberapa koin dari pengguna yang berbeda ke dalam satu transaksi, sehingga mengaburkan jejak dan membuatnya sulit untuk menentukan hubungan antara alamat input dan output.

Penting untuk dipahami bahwa tujuan transaksi coinjoin adalah untuk memutus sejarah sebuah koin. Teknik ini tidak memberikan anonimitas permanen atau secara definitif menghentikan pelacakan bitcoin, berbeda dengan apa yang mungkin dipikirkan. Coinjoin hanya bertujuan untuk memutus sejarah pada titik di mana transaksi coinjoin dilakukan. Namun, sebelum dan setelah operasi ini, koin tetap terkena risiko privasi yang sama.

### Bagaimana cara kerja coinjoin?

Prinsip dari coinjoin bergantung pada pendekatan kolaboratif: beberapa pengguna yang ingin mencampur bitcoin mereka menyetorkan jumlah yang identik dalam input dari transaksi yang sama. Jumlah-jumlah ini kemudian didistribusikan kembali dalam output dengan nilai yang sama untuk setiap pengguna.

Pada akhir transaksi, menjadi tidak mungkin untuk mengaitkan output spesifik dengan pengguna yang dikenal di input. Tidak ada hubungan langsung antara input dan output, yang memutuskan asosiasi antara pengguna dan UTXO mereka, serta sejarah setiap koin.

Mari kita ambil contoh Alice. Dia ingin mengirim sekitar 100.000 sats ke adiknya Eve untuk ulang tahunnya. Namun, Alice tidak ingin Eve dapat melacak sejarah transaksinya karena dia tidak ingin mengungkapkan berapa banyak bitcoin yang dia miliki atau bagaimana dia memperolehnya. Untuk melakukan ini, Alice memutuskan untuk memutus sejarah UTXO-nya dengan transaksi coinjoin. Dia berorganisasi dengan Bob, Charles, David, dan Frank untuk melakukan transaksi kolaboratif:
- Alice, Bob, Charles, David, dan Frank masing-masing berkomitmen UTXO sebesar 105.000 sats (dengan 5.000 sats untuk biaya penambangan) sebagai input untuk transaksi:

- Sebagai imbalan atas penggunaan input ini, masing-masing menghasilkan alamat baru untuk menciptakan lima output identik sebesar 100.000 sats masing-masing. Setiap orang mengambil satu output:

- Alice akhirnya mendapatkan UTXO sebesar 100.000 sats yang sejarahnya telah dicampur. Dia menggunakan UTXO ini dalam transaksi baru untuk mengirim jumlah tersebut ke Eve untuk ulang tahunnya:
- Jika Eve mencoba menganalisis transaksi ini untuk mengekstrak informasi, dia akan dihadapkan pada transaksi coinjoin yang melibatkan Alice, Bob, Charles, David, dan Frank. Karena tidak dapat membedakan input mana yang milik siapa karena keseragaman jumlahnya, Eve tidak dapat melacak sejarah UTXO Alice, atau menentukan berapa banyak bitcoin yang dimiliki oleh saudaranya atau bagaimana dia memperolehnya:

![BTC204](assets/notext/51/08.webp)

Dalam skenario ini, Alice menggunakan teknik coinjoin untuk meningkatkan privasinya terhadap analisis retrospektif. Memang, Alice melindungi dirinya terhadap analisis yang mungkin dilakukan oleh Eve yang akan dimulai dari transaksi tertentu untuk melacak sejarah UTXO ke belakang. Perlindungan terhadap analisis dari masa kini ke masa lalu inilah yang kami sebut sebagai anonset retrospektif. Kami akan membahas konsep ini lebih detail di bab-bab terakhir bagian ini.

Namun, coinjoin juga menawarkan kemungkinan untuk meningkatkan privasi terhadap analisis dari masa lalu ke masa kini, yang disebut sebagai anonset prospektif. Mari kita kembali ke contoh kita dimana Alice mengirim 98.000 sats ke Eve untuk ulang tahunnya, tetapi dengan membalik peran. Sekarang bayangkan bahwa Eve yang khawatir tentang privasinya. Memang, Alice mungkin tergoda untuk mengikuti koin yang dia kirim ke Eve untuk mengumpulkan informasi. Eve bisa mengkonsolidasikan UTXO yang baru saja dia terima dengan semua UTXO lainnya, yang bisa mengungkapkan kepada Alice jumlah bitcoin yang dia pegang di dompetnya. Untuk menghindari ini, Eve juga bisa memutus sejarah koin yang baru saja dia terima.
- Eve, Grace, Mallory, Oscar, dan Victor masing-masing memasukkan UTXO sebesar 98.000 sats sebagai input dalam transaksi Bitcoin:
![BTC204](assets/notext/51/09.webp)

- Sebagai imbalan atas penggunaan input ini, masing-masing menyediakan alamat baru untuk menciptakan 5 output sebesar 97.500 sats masing-masing, sama sempurna. Setiap pengguna mengambil sebuah output:

![BTC204](assets/notext/51/10.webp)

- Eve sekarang memiliki UTXO sebesar 97.500 sats dengan sejarah yang terputus. Dia dapat menggunakannya tanpa khawatir untuk transaksi masa depan. Memang, jika Alice mencoba mengikuti bitcoin yang dia kirim ke Eve, dia akan menemukan transaksi coinjoin. Dia tidak akan dapat menentukan UTXO output mana yang milik Eve. Analisis kemudian menjadi tidak mungkin:

![BTC204](assets/notext/51/11.webp)

Dalam contoh pertama, kita melihat bagaimana coinjoin dapat melindungi privasi sebuah koin terkait masa lalunya, dan dalam contoh kedua, bagaimana itu juga dapat mengamankan sejarah sebuah koin terkait masa depannya. Itulah mengapa saya menyebutkan bahwa coinjoin harus dilihat sebagai sebuah peristiwa satu kali yang membagi sejarah koin ke kedua arah:

![BTC204](assets/notext/51/02.webp)

### Mixing, coinjoins, mixer... Apa bedanya?

Istilah "mixing" terkadang digunakan untuk mendeskripsikan coinjoins, sebuah istilah yang ditolak oleh beberapa pengguna bitcoin karena mereka khawatir akan kebingungan dengan mixer kustodial. Namun, saya pikir kekhawatiran ini tidak berdasar, karena, dalam konteks matematis, coinjoin mewujudkan konsep mixing dengan tepat.
Di bidang umum matematika, pencampuran merujuk pada sifat dari sistem dinamis di mana, setelah beberapa waktu, semua bagian dari ruang awal secara teoritis dapat dicampur dengan bagian lainnya. Pencampuran mengimplikasikan bahwa posisi partikel atau keadaan sistem berkembang sedemikian rupa sehingga distribusi masa depannya independen dari distribusi awalnya, sehingga mencapai keadaan di mana karakteristik dari keadaan awal secara merata tersebar di seluruh ruang sistem. Inilah yang terjadi pada coinjoin dengan bitcoin. Jadi, menurut saya, coinjoin adalah benar-benar metode pencampuran koin.
![BTC204](assets/notext/51/12.webp)

Namun, penting untuk membedakan coinjoin dari mixer. Mixer adalah layanan di mana pengguna mengirimkan bitcoin mereka untuk dicampur. Layanan ini populer selama tahun 2010-an, tetapi penggunaannya telah menurun karena dua kelemahan utama dibandingkan dengan coinjoin:
- Mereka mengharuskan pengguna untuk menyerahkan kepemilikan dana mereka selama proses pencampuran, yang membuat mereka terpapar risiko pencurian;
- Tidak ada jaminan bahwa mixer tidak mencatat detail transaksi, atau bahkan menjual informasi ini ke perusahaan analisis rantai.
![BTC204](assets/notext/51/13.webp)

Saat ini, pengguna oleh karena itu lebih memilih coinjoin, karena memungkinkan mereka untuk mempertahankan kontrol penuh atas dana mereka sepanjang proses. Peserta dalam coinjoin tidak berisiko kehilangan bitcoin mereka oleh pihak lain yang terlibat. Mari kita jelajahi bersama bagaimana semua ini mungkin di bab berikutnya.

## Zerolink dan Chaumian Coinjoins
<chapterId>326c9654-b359-4906-b23d-d6518dd5dc3e</chapterId>

Privasi yang diberikan oleh coinjoin dimenangkan pada ukuran grup di mana bagian kita tersembunyi. Oleh karena itu, perlu untuk menemukan sebanyak mungkin peserta. Memang mungkin untuk melakukan coinjoin secara manual, dengan pengguna yang ditemukan sendiri, tetapi metode ini kompleks, dan tidak memungkinkan untuk mencapai anonset besar.

Inilah mengapa koordinator coinjoin telah berkembang di Bitcoin. Peran mereka adalah untuk menghubungkan pengguna yang berbeda dan menyampaikan informasi yang diperlukan untuk penyelesaian transaksi kolaboratif yang sukses.

![BTC204](assets/notext/52/01.webp)

Tapi bagaimana kita bisa memastikan bahwa koordinator tidak pernah memiliki kontrol atas bitcoin pengguna, dan meskipun mereka adalah orang yang membangun transaksi coinjoin, bagaimana kita bisa memastikan mereka tidak dapat menghubungkan input dan output dari pengguna, yang bisa merupakan kebocoran privasi?

### Tanda Tangan Buta Chaum

Implementasi modern dari coinjoin menggunakan tanda tangan buta David Chaum untuk menghindari kebocoran informasi. Mari kita pelajari bersama bagaimana tanda tangan buta ini bekerja.

Tanda tangan buta Chaum adalah bentuk tanda tangan digital di mana penerbit tanda tangan tidak mengetahui isi pesan yang mereka tanda tangani. Namun, tanda tangan tersebut nantinya dapat diverifikasi dengan pesan asli. Teknik ini dikembangkan oleh kriptografer David Chaum pada tahun 1983.

![BTC204](assets/notext/52/02.webp)

Ambil contoh sebuah perusahaan yang ingin mengautentikasi dokumen rahasia, seperti kontrak, tanpa mengungkapkan isinya. Perusahaan menerapkan proses penyamaran yang mengubah dokumen asli secara kriptografis dengan cara yang dapat dibalik. Dokumen yang dimodifikasi ini dikirim ke otoritas sertifikasi yang menerapkan tanda tangan buta tanpa mengetahui konten yang mendasarinya. Setelah menerima dokumen yang ditandatangani, perusahaan membuka penyamaran tanda tangan. Hasilnya adalah dokumen asli yang diautentikasi oleh tanda tangan otoritas, tanpa otoritas pernah melihat konten aslinya.
Tanda tangan buta Chaum memungkinkan sertifikasi keaslian dokumen tanpa mengetahui isinya, yang menjamin kerahasiaan data pengguna dan integritas dokumen yang ditandatangani.

### Chaumian Coinjoins
Dalam "Chaumian CoinJoins," penggunaan Tor dan tanda tangan buta David Chaum dikombinasikan untuk memastikan bahwa koordinator tidak dapat mengetahui output mana yang milik pengguna mana. Proses pembuatan transaksi coinjoin berputar di sekitar 3 langkah utama: mendaftarkan input, mendaftarkan output, dan menandatangani transaksi. Mari kita periksa proses ini melalui contoh Alice, salah satu peserta dalam coinjoin. Semua peserta lain mengikuti langkah yang sama seperti Alice, masing-masing sendiri.

**Langkah 1: Mendaftarkan input.**
- Alice mengirimkan kepada koordinator UTXO yang ingin dia gunakan sebagai input untuk transaksi, serta alamat penerima bertopeng yang ingin dia gunakan sebagai output untuk menerima bitcoinnya. Oleh karena itu, koordinator tidak dapat mengetahui alamat Alice. Dia hanya melihat versi bertopengnya:

![BTC204](assets/notext/52/03.webp)

- Koordinator memverifikasi validitas input, kemudian menandatangani alamat bertopeng Alice dengan kunci privatnya. Dia mengirimkan kembali kepada Alice tanda tangan buta:

![BTC204](assets/notext/52/04.webp)

**Langkah 2: Mendaftarkan output.**
- Alice sekarang dapat membuka topeng alamatnya yang ditandatangani oleh kunci privat koordinator. Dia membuat koneksi baru di bawah identitas Tor yang berbeda. Koordinator tidak dapat mengidentifikasi bahwa itu adalah Alice yang terhubung di bawah identitas baru ini:

![BTC204](assets/notext/52/05.webp)

- Alice mengirimkan alamat dan tanda tangan yang tidak bertopeng kepada koordinator (yang masih tidak tahu itu Alice):

![BTC204](assets/notext/52/06.webp)

**Langkah 3: Menandatangani transaksi.**
- Koordinator dengan cara yang sama mengambil output yang tidak bertopeng dari semua peserta. Berkat tanda tangan yang terkait, dia dapat memverifikasi bahwa setiap output yang diajukan secara anonim memang ditandatangani oleh kunci privatnya sebelumnya, memastikan keabsahannya. Dia kemudian siap untuk membangun transaksi coinjoin dan mengirimkannya kepada peserta untuk mereka tanda tangani:

![BTC204](assets/notext/52/07.webp)

- Alice, seperti peserta lainnya, memverifikasi bahwa input dan outputnya termasuk dengan benar dalam transaksi yang dibangun oleh koordinator. Jika semuanya memuaskan, dia mengirimkan tanda tangan yang membuka skrip inputnya kepada koordinator:

![BTC204](assets/notext/52/08.webp)

- Setelah mengumpulkan tanda tangan dari semua peserta coinjoin, koordinator dapat menyiarkan transaksi di jaringan Bitcoin, sehingga dapat ditambahkan ke dalam blok.
Dalam sistem ini, koordinator tidak dapat menghubungkan input dengan output tertentu. Selain itu, mereka tidak dapat mengambil alih dana peserta, karena mereka tidak pernah memiliki akses ke kunci privat yang diperlukan untuk membuka UTXO mereka. Sepanjang proses, dan sampai akhir langkah 3, mereka juga tidak memiliki akses ke tanda tangan. Ketika Alice dan peserta lainnya menandatangani transaksi global, setelah memastikan semuanya benar, koordinator tidak lagi dapat memodifikasi transaksi ini, termasuk output, tanpa membuatnya tidak valid. Ini oleh karena itu mencegah pencurian bitcoin oleh koordinator.
Pada akhirnya, ketika merekam hasil mereka dalam transaksi, pengguna coinjoin menginginkan jaminan serupa dengan yang diinginkan oleh warga negara yang memilih dalam sebuah pemilihan. Ada dualitas antara aspek publik dan pribadi dari tindakan-tindakan ini. Di satu sisi, ada yang ingin dijaga kerahasiaannya: untuk pemilih, mereka tidak ingin surat suara mereka dikaitkan dengan identitas mereka; untuk pengguna coinjoin, mereka tidak ingin output mereka dikaitkan dengan input mereka. Memang, jika koordinator, atau pihak lain, berhasil menetapkan hubungan antara input dan output, coinjoin kehilangan seluruh tujuannya. Seperti yang dijelaskan sebelumnya, coinjoin harus berfungsi sebagai pemutus dalam sejarah sebuah koin. Penghentian ini terjadi tepat karena ketidakmungkinan mengaitkan input tertentu dengan output tertentu dalam transaksi coinjoin (anonset prospektif) dan sebaliknya (anonset retrospektif).

Di sisi lain, ada aspek publik: pemilih ingin memastikan surat suaranya termasuk dalam kotak suara; serupa, pengguna coinjoin ingin memastikan output mereka termasuk dalam transaksi coinjoin. Memang, sangat penting bagi peserta coinjoin untuk dapat memverifikasi keberadaan output mereka sebelum menandatangani transaksi, jika tidak koordinator dapat mencuri dana tersebut.

Tepatnya 2 aspek publik dan pribadi ini, yang dimungkinkan oleh penggunaan tanda tangan buta David Chaum, yang menjamin kepada peserta Chaumian coinjoins bahwa bitcoin mereka tidak akan dicuri, dan bahwa dana mereka tidak dapat dilacak.

### Siapa yang menciptakan konsep coinjoin?

Sulit untuk menentukan dengan pasti siapa yang pertama kali memperkenalkan ide coinjoin pada Bitcoin, dan siapa yang memiliki ide menggunakan tanda tangan buta David Chaum dalam konteks ini. Seringkali dipikirkan bahwa itu adalah Gregory Maxwell yang pertama kali membicarakannya dalam [pesan di BitcoinTalk pada tahun 2013](https://bitcointalk.org/index.php?topic=279249.0):
Menggunakan Tanda Tangan Buta Chaum: Pengguna masuk dan menyediakan input (dan alamat perubahan) serta versi yang secara kriptografis dibutakan dari alamat tempat mereka ingin mengirim koin pribadi mereka; server menandatangani token dan mengembalikannya kepada pengguna. Pengguna terhubung kembali secara anonim, membuka alamat output mereka, dan mengirimkannya kembali ke server. Server dapat melihat bahwa semua output telah ditandatangani olehnya dan bahwa, akibatnya, semua output berasal dari peserta yang valid. Kemudian, orang terhubung kembali dan menandatangani.
Maxwell, G. (2013, Agustus 22). *CoinJoin: Privasi Bitcoin untuk dunia nyata*. Forum BitcoinTalk. https://bitcointalk.org/index.php?topic=279249.0

![BTC204](assets/notext/52/09.webp)

Namun, ada penyebutan lebih awal, baik untuk tanda tangan Chaum dalam konteks pencampuran, maupun untuk coinjoins. [Pada Juni 2011, Duncan Townsend mempresentasikan di BitcoinTalk](https://bitcointalk.org/index.php?topic=12751.0) sebuah mixer yang menggunakan tanda tangan Chaum dengan cara yang cukup mirip dengan Chaumian coinjoins modern.
Dalam thread yang sama, ada [pesan dari hashcoin sebagai respons kepada Duncan Townsend](https://bitcointalk.org/index.php?topic=12751.msg315793#msg315793) untuk meningkatkan mixer-nya. Proses yang dijelaskan dalam pesan ini secara tepat mewakili apa yang paling mirip dengan coinjoins. Ada juga penyebutan sistem serupa dalam [pesan dari Alex Mizrahi pada tahun 2012](https://gist.github.com/killerstorm/6f843e1d3ffc38191aebca67d483bd88#file-laundry), saat ia memberi nasihat kepada pencipta Tenebrix, salah satu altcoin pertama yang menjadi dasar untuk menciptakan Litecoin kemudian. Bahkan istilah "coinjoin" sendiri tidak ditemukan oleh Greg Maxwell, tetapi berasal dari ide oleh Peter Todd.
![BTC204](assets/notext/52/10.webp)

### Zerolink

Zerolink adalah protokol mixing yang komprehensif yang mengintegrasikan Chaumian coinjoins dan berbagai strategi untuk melindungi anonimitas pengguna terhadap beberapa bentuk analisis rantai, terutama meminimalkan kesalahan terkait manajemen dompet. Protokol ini [diperkenalkan oleh nopara73 dan TDevD pada tahun 2017](https://github.com/nopara73/ZeroLink/blob/master/README.md).

![BTC204](assets/notext/52/11.webp)

Seperti namanya, prinsip Zerolink adalah untuk melakukan transaksi coinjoin yang memastikan ketidakmungkinan melacak tautan antara input dan output. Karakteristik ini dicapai dengan memastikan bahwa semua output memiliki jumlah yang identik sempurna.

![BTC204](assets/notext/52/12.webp)
Sebuah langkah pencegahan penting oleh Zerolink melibatkan pemisahan UTXO yang tidak dicampur dari UTXO yang dicampur dengan menggunakan kumpulan kunci kriptografi yang berbeda, atau bahkan dompet terpisah. Dengan cara ini, dompet "pra-campur", yang dimaksudkan untuk koin sebelum dicampur, dibedakan dari dompet "pasca-campur", yang diperuntukkan bagi koin yang telah dicampur.
![BTC204](assets/notext/52/13.webp)

Pemisahan UTXO ini terutama berfungsi untuk mencegah asosiasi tidak sengaja antara UTXO yang dicampur dan UTXO yang tidak dicampur. Memang, jika tautan seperti itu terjadi, efektivitas coinjoin pada UTXO yang dicampur menjadi tidak berlaku tanpa pengguna menyadarinya, sehingga mengompromikan kerahasiaan UTXO yang sejarahnya mereka percaya telah diputus. Tautan ini dapat muncul baik melalui penggunaan ulang alamat pada mengamankan UTXO yang dicampur dengan yang tidak dicampur, atau dengan menerapkan Heuristik Kepemilikan Input Bersama (CIOH), jika pengguna mengonsumsi UTXO yang dicampur dan tidak dicampur sebagai input dari transaksi yang sama. Dengan memisahkan dompet pra-campuran dan pasca-campuran, asosiasi tidak sengaja ini dihindari, dan pengguna dilindungi dari kesalahan tidak sengaja.

![BTC204](assets/notext/52/14.webp)

Pemisahan ini juga menawarkan kemungkinan untuk menerapkan aturan yang berbeda antara dompet pra-campuran dan pasca-campuran pada tingkat perangkat lunak dompet. Misalnya, di dompet pasca-campur, perangkat lunak dapat melarang penggabungan UTXO menjadi input untuk mencegah penerapan CIOH yang akan mengompromikan anonset pengguna. Juga dimungkinkan untuk menstandarisasi penggunaan skrip dan opsi transaksi (seperti penandaan RBF, misalnya) untuk mencegah identifikasi oleh sidik jari dompet.

Saat ini, Whirlpool adalah satu-satunya implementasi coinjoin yang secara ketat menerapkan protokol Zerolink. Pada bab berikutnya, kita akan menjelajahi berbagai implementasi coinjoin yang ada dan kelebihan serta kekurangan masing-masing.

## Implementasi Coinjoin
<chapterId>e37ed073-9498-4e4f-820b-30951e829596</chapterId>
*Pada tahun 2024, kita menyaksikan perubahan signifikan dalam alat yang tersedia bagi pengguna yang ingin melakukan coinjoin pada Bitcoin. Saat ini, kita berada dalam periode penting, dan pasar coinjoin sedang mengalami restrukturisasi besar. Oleh karena itu, bab ini kemungkinan akan diperbarui dari waktu ke waktu.*

Untuk saat ini, terutama ada 3 implementasi coinjoin yang berbeda pada Bitcoin:
- Whirlpool;
- Wabisabi;
- JoinMarket.
Masing-masing implementasi ini bertujuan untuk memutus riwayat UTXO melalui transaksi coinjoin. Namun, mekanisme mereka bervariasi secara signifikan. Oleh karena itu, sangat penting untuk memahami bagaimana masing-masing bekerja untuk memilih opsi yang paling cocok untuk kebutuhan Anda.

### JoinMarket

JoinMarket, yang dibuat pada tahun 2015 oleh Adam Gibson dan Chris Belcher, menonjol dari implementasi coinjoin lainnya berkat model pencocokan pengguna yang unik. Sistem ini didasarkan pada pasar pertukaran P2P di mana beberapa pengguna, "pembuat," menyediakan bitcoin mereka untuk dicampur, sementara yang lain, "pengambil," menggunakan dana ini untuk melakukan coinjoin dengan imbalan biaya.

![BTC204](assets/notext/53/01.webp)

Dalam model ini, "pembuat" meninggalkan bitcoin mereka tersedia untuk "pengambil" dan menerima biaya sebagai imbalan atas layanan mereka. Di sisi lain, "pengambil" membayar untuk menggunakan bitcoin "pembuat" untuk melakukan transaksi coinjoin mereka sendiri. Biaya layanan bervariasi tergantung pada peran: "pembuat" mengumpulkan biaya untuk penawaran likuiditas mereka, sementara "pengambil" membayar biaya. Pasar ini beroperasi secara bebas tanpa syarat penggunaan.

Salah satu kelemahan utama JoinMarket adalah kompleksitas penggunaannya, yang memerlukan keakraban tertentu dengan terminal untuk memanfaatkannya secara efisien. Meskipun kompleksitas ini bukanlah penghalang bagi pengguna yang berpengalaman, ini dapat membatasi akses bagi masyarakat umum. Namun, pengenalan antarmuka web yang bernama JAM baru-baru ini telah sedikit memudahkan penggunaannya.

![BTC204](assets/notext/53/02.webp)

Sumber: [JAM](https://github.com/joinmarket-webui/jam/blob/devel/docs/assets/screenshot-dark.webp)

Namun, hambatan teknis tetap menjadi penghalang utama. Dalam ekosistem coinjoin, di mana kerahasiaan ditingkatkan oleh jumlah peserta, setiap batasan yang mengurangi aksesibilitas secara langsung mempengaruhi likuiditas yang tersedia, yang merupakan faktor penting untuk efisiensi pencampuran. Bitcoin, yang sudah merupakan ceruk dalam transaksi keuangan, melihat penggunaan coinjoin sebagai sub-niche, dan JoinMarket mewakili fraksi yang lebih khusus lagi, sehingga membatasi potensinya untuk meningkatkan anonset penggunanya.

Meskipun model pencocokan P2P inovatif untuk coinjoin, JoinMarket memiliki beberapa kelemahan signifikan, terutama dalam hal struktur transaksional. Tidak seperti implementasi lain seperti Whirlpool, JoinMarket tidak menjamin kesamaan sempurna antara output, dan mungkin untuk melacak tautan deterministik antara input dan output. Selain itu, ia kekurangan alat untuk mencegah koin yang telah dicampur bersama dari dicampur lagi, yang dapat mengompromikan kerahasiaan yang dicari oleh pengguna.
Akhirnya, meskipun konsep JoinMarket menarik, terutama bagi mereka yang tertarik dengan pasar likuiditas dinamis, kelemahan struktural dan kompleksitas teknisnya, menurut saya, membuatnya kurang menarik, baik untuk pemula maupun untuk ahli yang mencari implementasi coinjoin.
### Wabisabi
Wabisabi adalah implementasi lain dari coinjoin, dengan pendekatan yang memusatkan koordinasi transaksi. Model ini dirancang oleh Ádám Ficsór (nopara73), Yuval Kogman, Lucas Ontivero, dan István András Seres pada tahun 2021, dan diintegrasikan ke dalam perangkat lunak Wasabi 2.0 pada tahun berikutnya. Wabisabi secara tepat adalah evolusi dari model coinjoin dari perangkat lunak Wasabi yang diluncurkan pada tahun 2018.
![BTC204](assets/notext/53/03.webp)

Menuju akhir tahun 2010-an, Wasabi mengadopsi struktur transaksi untuk coinjoins-nya yang sangat berbeda dari Whirlpool. Untuk meningkatkan anonsets dari partisipannya, Wasabi menggunakan transaksi coinjoin yang sangat besar dengan mengelompokkan puluhan partisipan. Sebaliknya, Whirlpool memilih untuk melakukan banyak transaksi kecil, memungkinkan peningkatan eksponensial dalam anonsets dengan setiap siklus.

Metode pengelolaan kembalian juga membedakan kedua implementasi tersebut. Dengan Whirlpool, kembalian dikecualikan dan diisolasi dari UTXOs sebelum siklus coinjoin berkat TX0, konsep yang akan saya jelaskan lebih lanjut di bab berikutnya. Di Wasabi, di sisi lain, kembalian membentuk salah satu output dari transaksi coinjoin, yang mempertahankan tautan deterministik antara input dan output tertentu.

![BTC204](assets/notext/53/04.webp)

Dengan Wabisabi, versi 2.0 dari Wasabi menyesuaikan pendekatannya terhadap coinjoins untuk lebih mendekati model Whirlpool. Meskipun transaksi coinjoin tetap sangat besar, sekarang dimungkinkan untuk menggabungkan beberapa siklus berturut-turut, mengikuti model Whirlpool. Upaya khusus juga telah dilakukan pada pengelolaan kembalian: tidak seperti Wasabi 1.0, di mana kembalian langsung terhubung ke input pengguna, Wabisabi berusaha untuk membagi kembalian menjadi beberapa jumlah kecil, didistribusikan dalam denominasi yang sama untuk semua partisipan.

Mari kita ilustrasikan ini dengan contoh sederhana yang melibatkan hanya 2 pengguna: Alice ingin mencampur 115.000 sats dan Bob, 210.000 sats. Mengabaikan biaya, dengan Wasabi 1.0, transaksi coinjoin akan menghasilkan 3 output sebesar 100.000 sats, ditambah 1 kembalian sebesar 15.000 sats untuk Alice dan 1 kembalian sebesar 10.000 sats untuk Bob. Output kembalian akan selalu terhubung ke input:

![BTC204](assets/notext/53/05.webp)
Di bawah Wabisabi, transaksi yang sama akan menghasilkan 3 output sebesar 100.000 sats dan 5 output sebesar 5.000 sats, sehingga menyebarkan kembalian dengan cara yang tidak langsung dapat dilacak ke input tertentu:
![BTC204](assets/notext/53/06.webp)

Secara pribadi, saya merasa bahwa pengelolaan kembalian dalam Wabisabi menyajikan beberapa risiko yang dapat mengompromikan efektivitasnya dalam hal privasi:
- Ketika pengguna berkontribusi dengan UTXO yang secara signifikan lebih besar daripada partisipan lain, mereka tidak dapat dihindari akan berakhir dengan jumlah kembalian yang akan terhubung ke input mereka. Ini bertentangan dengan tujuan awal protokol, yang bertujuan untuk menghilangkan perubahan yang dapat diidentifikasi;
- Perkalian denominasi untuk memfragmentasi kembalian secara paradoks dapat merugikan efisiensi pencampuran. Proses ini dapat menyebabkan penurunan anonsets untuk output tertentu, karena mereka menjadi lebih mudah diidentifikasi.
Metode ini juga menghasilkan UTXO bernilai rendah yang menimbulkan masalah manajemen bagi pengguna. UTXO kecil ini, jika biaya menghabiskannya menjadi terlalu mahal dibandingkan dengan nilainya, dapat menjadi "debu". Fenomena ini mendorong pengguna untuk menggabungkan beberapa UTXO menjadi input dalam transaksi masa depan mereka atau untuk mengkonsolidasikannya. Dalam kedua kasus, karena COH, ini dapat menurunkan anonset yang diperoleh atau bahkan sepenuhnya membatalkan manfaat privasi yang diperoleh melalui coinjoin awal.
Berbeda dengan Whirlpool, yang menerapkan protokol ZeroLink yang menjamin pemisahan ketat antara UTXO pra-campur dan pasca-campur, Wabisabi tidak mempertahankan pemisahan ketat ini. Telah juga terjadi masalah dengan penggunaan ulang alamat oleh beberapa klien Wasabi, yang jelas sangat merugikan pengguna.

Dalam versi 2.0 Wasabi, kebijakan biaya coinjoin baru telah diterapkan. Sekarang, biaya koordinator ditetapkan sebesar 0,3% untuk UTXO lebih besar dari 0,01 bitcoin, sementara untuk UTXO lebih kecil, biaya ini sepenuhnya dihapuskan. Selain itu, remix untuk UTXO kecil ini gratis, meskipun biaya penambangan tetap menjadi tanggung jawab pengguna untuk semua transaksi, termasuk remix.

Kebijakan ini berbeda dengan Whirlpool, di mana biaya tetap, terlepas dari ukuran anonset yang diperoleh. Dengan Wasabi 2.0, meskipun biaya koordinator dihapuskan untuk UTXO kecil, pengguna masih harus membayar biaya penambangan untuk semua transaksi, termasuk remix.
Saat penulisan ini, penggunaan Wabisabi telah menjadi jauh lebih kompleks menyusul peristiwa terkini. Memang, setelah penangkapan pendiri Samourai Wallet, zkSNACKs, perusahaan yang membiayai dan mengelola pengembangan Wasabi, mengumumkan penghentian layanan koordinasi coinjoin mereka pada 1 Juni 2024. Koordinator ini, yang diatur secara default pada Wasabi, memiliki mayoritas likuiditas.

Dengan penutupan koordinator utama ini, pengguna sekarang harus terhubung ke koordinator independen baru. Perubahan ini menimbulkan kekhawatiran: di satu sisi, koordinator baru mungkin tidak memiliki likuiditas yang cukup, sehingga mengurangi efektivitas coinjoin dalam hal privasi. Di sisi lain, ada risiko bertemu dengan koordinator jahat. Situasi ini menambahkan risiko signifikan baru bagi mereka yang ingin menggunakan Wabisabi.

Di luar masalah teknis, keputusan oleh zkSNACKs, perusahaan di balik Wasabi, untuk menggunakan layanan perusahaan analisis rantai untuk menyaring peserta dalam coinjoin menimbulkan pertanyaan etis dan strategis yang serius. Ide awalnya adalah untuk mencegah penggunaan coinjoin di Wasabi oleh kriminal, langkah yang mungkin terlihat sah. Namun, ini menimbulkan paradoks: membayar biaya kepada koordinator, yang misi utamanya adalah meningkatkan privasi pengguna, hanya untuk kemudian membiayai perusahaan yang tujuannya adalah untuk mengkompromikan privasi yang sama.

Lebih mengkhawatirkan lagi adalah prinsip penyaringan, yang sangat kontras dengan filosofi Bitcoin yang bertujuan menawarkan sistem keuangan yang terbuka dan tidak dapat disensor. Meskipun mungkin terlihat dibenarkan untuk ingin mengecualikan aktivitas kriminal, penyaringan ini juga bisa mempengaruhi individu yang tindakannya, meskipun diklasifikasikan sebagai ilegal dalam beberapa konteks, bisa secara moral dibenarkan atau bermanfaat secara sosial. Contoh Edward Snowden dengan sempurna menggambarkan dikotomi ini: dianggap sebagai kriminal oleh beberapa pemerintah karena pengungkapannya, dia dilihat oleh lainnya sebagai whistleblower yang bertindak demi kepentingan publik. Kompleksitas ini menekankan potensi bahaya dari penyaringan yang, meskipun dimulai dari niat baik, pada akhirnya dapat melanggar hak dan keamanan pengguna yang sah. Saya juga bisa menyebutkan aktivis dan jurnalis yang dianiaya di bawah rezim otoriter tertentu.
Seperti yang Anda telah pahami, preferensi saya tanpa ragu bergerak menuju model Whirlpool untuk melakukan coinjoins pada Bitcoin. Sistem ini menonjol karena ketegasannya dan menawarkan jaminan superior dalam hal privasi. Ini juga satu-satunya yang mengusulkan pencampuran yang dianggap sempurna dalam konteks matematika. Menurut saya, model ini mewakili masa depan coinjoins pada Bitcoin. Oleh karena itu, saya mengundang Anda untuk menjelajahi model ini lebih dalam di bab selanjutnya.

## Cara Kerja Whirlpool
<chapterId>bdbd7109-e36d-4b4f-a3c6-928df4e9bfda</chapterId>

Whirlpool membedakan dirinya dari metode coinjoin lain dengan menggunakan transaksi "_ZeroLink_", yang memastikan bahwa secara teknis tidak mungkin ada hubungan antara semua input dan semua output. Pencampuran sempurna ini dicapai melalui struktur di mana setiap peserta berkontribusi dengan jumlah yang identik dalam input (kecuali untuk biaya penambangan), sehingga menghasilkan output dengan jumlah yang sempurna sama.

Pendekatan restriktif terhadap input memberikan transaksi coinjoin Whirlpool karakteristik unik: total ketiadaan tautan deterministik antara input dan output. Dengan kata lain, setiap output memiliki kemungkinan yang sama untuk diatribusikan kepada peserta mana pun, terkait dengan semua output lain dari transaksi tersebut.

![BTC204](assets/notext/54/01.webp)

### Cara Kerja Umum Whirlpool

Awalnya, jumlah peserta dalam setiap coinjoin Whirlpool dibatasi menjadi 5, dengan 2 peserta baru dan 3 remixer (kami akan menjelaskan konsep ini lebih lanjut). Namun, peningkatan biaya transaksi on-chain yang diamati pada tahun 2023 telah mendorong tim Samourai untuk memikirkan kembali model mereka untuk meningkatkan privasi sambil mengurangi biaya. Dengan demikian, dengan mempertimbangkan situasi pasar biaya dan jumlah peserta, koordinator kini dapat mengorganisir coinjoins yang mencakup 6, 7, atau 8 peserta. Sesi yang ditingkatkan ini ditunjuk dengan nama "_Surge Cycles_". Penting untuk dicatat bahwa, terlepas dari konfigurasinya, selalu hanya ada 2 peserta baru dalam coinjoins Whirlpool.

Dengan demikian, transaksi Whirlpool ditandai dengan jumlah input dan output yang identik, yang bisa berupa:
- 5 input dan 5 output;

![BTC204](assets/notext/54/02.webp)

- 6 input dan 6 output;

![BTC204](assets/notext/54/03.webp)

- 7 input dan 7 output;

![BTC204](assets/notext/54/04.webp)

- 8 input dan 8 output.

![BTC204](assets/notext/54/05.webp)
Model yang diusulkan oleh Whirlpool didasarkan pada transaksi coinjoin berukuran kecil. Tidak seperti Wabisabi dan JoinMarket, di mana kekuatan anonsets bergantung pada volume peserta dalam satu siklus (atau beberapa siklus), Whirlpool bertaruh pada penggabungan beberapa siklus berukuran kecil. Dalam model ini, pengguna hanya mengeluarkan biaya pada entri awal mereka ke dalam pool, memungkinkan mereka untuk berpartisipasi dalam banyak remix tanpa biaya tambahan. Ini adalah peserta baru yang menanggung biaya penambangan untuk remixer.

Dengan setiap coinjoin tambahan di mana sebuah koin berpartisipasi, bersama dengan rekan-rekannya yang ditemui di masa lalu, anonsets akan tumbuh secara eksponensial. Oleh karena itu, tujuannya adalah untuk memanfaatkan remix gratis ini yang, dengan setiap kejadian, berkontribusi untuk memperkuat kepadatan anonsets yang terkait dengan setiap koin yang dicampur.

![BTC204](assets/notext/54/06.webp)

Whirlpool dirancang dengan dua persyaratan penting dalam pikiran:
- Keterjangkauan implementasi pada perangkat mobile, mengingat Samourai Wallet terutama adalah aplikasi smartphone;
- Kecepatan siklus remixing untuk mendorong peningkatan signifikan dalam anonsets.

Imperatif-imperatif ini memandu pilihan pengembang Samourai Wallet dalam desain Whirlpool, yang membawa mereka untuk membatasi jumlah peserta per siklus. Terlalu sedikit peserta akan mengurangi efektivitas coinjoin, secara drastis mengurangi anonsets yang dihasilkan dalam setiap siklus, sementara terlalu banyak peserta akan menimbulkan masalah manajemen pada aplikasi mobile dan akan menghambat aliran siklus.

Pada akhirnya, tidak perlu memiliki jumlah peserta yang tinggi per coinjoin di Whirlpool karena anonsets dibuat melalui akumulasi beberapa siklus coinjoin. Prinsip terpenting di sini adalah homogenitas UTXOs dari semua peserta, karena ini memungkinkan campuran yang sempurna, dan dengan demikian untuk sepenuhnya mendapatkan manfaat dari siklus mixing dan remixing.

### Kolam dan biaya coinjoin

Untuk siklus berganda ini secara efektif meningkatkan anonsets dari koin yang dicampur, suatu kerangka kerja tertentu harus ditetapkan untuk membatasi jumlah UTXOs yang digunakan. Whirlpool dengan demikian mendefinisikan kolam yang berbeda.

Sebuah kolam mewakili sekelompok pengguna yang ingin mencampur bersama, yang setuju pada jumlah UTXOs yang digunakan untuk mengoptimalkan proses coinjoin sambil mempertahankan homogenitas sempurna dari koin. Setiap kolam menentukan jumlah tetap untuk UTXO, yang harus dipatuhi pengguna untuk berpartisipasi. Jadi, untuk melakukan coinjoins dengan Whirlpool, Anda perlu memilih sebuah kolam. Kolam yang tersedia saat ini adalah sebagai berikut:
- 0.5 bitcoin;
- 0.05 bitcoin;
- 0.01 bitcoin;
- 0.001 bitcoin (= 100,000 sats).

Dengan bergabung dalam sebuah kolam dengan bitcoin Anda, mereka akan dibagi untuk menghasilkan UTXOs yang sempurna homogen dengan UTXOs peserta lain dalam kolam. Setiap kolam memiliki batas maksimum; dengan demikian, untuk jumlah yang melebihi batas ini, Anda akan dipaksa baik untuk membuat dua entri terpisah dalam kolam yang sama atau beralih ke kolam lain dengan jumlah yang lebih tinggi:

| Kolam (bitcoin) | Jumlah maksimum per entri (bitcoin) |
|-----------------|-------------------------------------|
| 0.5             | 35                                  |
| 0.05            | 3.5                                 |
| 0.01            | 0.7                                 |
| 0.001           | 0.025                               |

Sebuah UTXO dianggap milik sebuah kolam ketika siap untuk diintegrasikan ke dalam coinjoin. Namun, ini tidak berarti bahwa pengguna kehilangan kepemilikan atasnya. Seperti yang telah kita lihat dalam bab-bab pertama bagian ini, melalui siklus mixing yang berbeda, Anda tetap memiliki kontrol penuh atas kunci Anda dan, akibatnya, bitcoin Anda. Inilah yang membedakan teknik coinjoin dari teknik mixing terpusat lainnya.

Untuk masuk ke kolam coinjoin, Anda harus membayar biaya layanan serta biaya penambangan. Biaya layanan ditetapkan untuk setiap kolam dan dimaksudkan untuk mengkompensasi tim yang bertanggung jawab atas pengembangan dan pemeliharaan Whirlpool.

Biaya layanan untuk menggunakan Whirlpool harus dibayar satu kali saat memasuki kolam. Setelah langkah ini selesai, Anda memiliki kemungkinan untuk berpartisipasi dalam jumlah remix tanpa batas tanpa biaya tambahan. Berikut adalah biaya tetap saat ini untuk setiap kolam:

| Kolam (bitcoin) | Biaya masuk (bitcoin)       |
|-----------------|-----------------------------|
| 0.5             | 0.0175                      |
| 0.05            | 0.00175                     |
| 0.01            | 0.0005 (50,000 sats)        |
| 0.001          | 0.00005 (5,000 sats)        |
Biaya ini pada dasarnya berfungsi sebagai tiket masuk untuk pool yang dipilih, terlepas dari jumlah yang Anda masukkan ke dalam coinjoin. Jadi, apakah Anda bergabung dengan pool 0.01 dengan tepat 0.01 BTC atau memasukinya dengan 0.5 BTC, biaya akan tetap sama dalam nilai absolut.

Sebelum melanjutkan dengan Whirlpool coinjoins, pengguna oleh karena itu memiliki pilihan antara 2 strategi:
- Memilih pool yang lebih kecil untuk meminimalkan biaya layanan, mengetahui bahwa mereka akan menerima beberapa UTXO yang lebih kecil sebagai balikannya;
- Atau lebih memilih pool yang lebih besar, setuju untuk membayar biaya yang lebih tinggi untuk mendapatkan jumlah UTXO yang lebih besar dengan nilai yang lebih tinggi.
Umumnya tidak disarankan untuk menggabungkan beberapa UTXO campuran setelah siklus coinjoin, karena ini dapat mengompromikan privasi yang diperoleh, terutama karena heuristik kepemilikan input bersama (CIOH: *Common-Input-Ownership-Heuristic*). Oleh karena itu, mungkin bijaksana untuk memilih pool yang lebih besar, meskipun berarti membayar lebih, untuk menghindari memiliki terlalu banyak UTXO dengan nilai kecil sebagai output. Pengguna harus menimbang trade-off ini untuk memilih pool yang mereka sukai.
Selain biaya layanan, biaya penambangan yang melekat pada setiap transaksi Bitcoin juga harus dipertimbangkan. Sebagai pengguna Whirlpool, Anda akan diminta untuk membayar biaya penambangan untuk transaksi persiapan (`Tx0`) serta untuk coinjoin pertama. Semua remix selanjutnya akan gratis, berkat model Whirlpool yang mengandalkan pembayaran dari peserta baru.

Memang, dalam setiap Whirlpool coinjoin, 2 pengguna di antara input adalah peserta baru. Input lainnya berasal dari remixers. Akibatnya, biaya penambangan untuk semua peserta dalam transaksi ditanggung oleh 2 peserta baru ini, yang kemudian juga akan mendapat manfaat dari remix gratis:

![BTC204](assets/en/54/07.webp)

Berkat sistem biaya ini, Whirlpool benar-benar membedakan dirinya dari implementasi coinjoin lainnya karena anonsets dari UTXO tidak proporsional dengan harga yang dibayar oleh pengguna. Dengan demikian, dimungkinkan untuk mencapai tingkat anonimitas yang cukup tinggi hanya dengan membayar biaya masuk pool dan biaya penambangan untuk 2 transaksi (the `Tx0` dan campuran awal).

Penting untuk dicatat bahwa pengguna juga harus menanggung biaya penambangan untuk menarik UTXO mereka dari pool setelah melakukan beberapa coinjoins, kecuali mereka telah memilih opsi `mix to`, yang memungkinkan menyediakan alamat eksternal yang akan langsung menerima dana sebagai output coinjoin, tanpa transaksi tambahan.

### Akun Dompet HD

Untuk melakukan coinjoin melalui Whirlpool, dompet harus menghasilkan beberapa akun yang berbeda. Ini adalah prinsip dari protokol ZeroLink. Sebuah akun, dalam konteks dompet HD (*Hierarchical Deterministic*), merupakan bagian yang sepenuhnya terisolasi dari yang lain, pemisahan ini terjadi pada tingkat kedalaman ketiga dari hierarki dompet, yaitu, pada tingkat `xpub`.

![BTC204](assets/en/54/08.webp)

Sebuah dompet HD secara teoritis dapat menghasilkan hingga `2^(32/2)` akun yang berbeda. Akun awal, yang digunakan secara default pada semua dompet Bitcoin, sesuai dengan indeks `0'`.

Untuk dompet yang disesuaikan dengan Whirlpool, 4 akun digunakan untuk memenuhi kebutuhan proses ZeroLink:
- **Akun deposit**, diidentifikasi dengan indeks `0'`;
- **Akun bank buruk** (atau "doxxic change"), diidentifikasi dengan indeks `2 147 483 644'`;
- Akun **premix**, diidentifikasi dengan indeks `2 147 483 645`;
- Akun **postmix**, diidentifikasi dengan indeks `2 147 483 646`.

Masing-masing akun ini memenuhi fungsi spesifik dalam proses coinjoin, yang akan kita jelajahi dalam bagian berikut.

Semua akun ini terhubung ke satu seed, memungkinkan pengguna untuk memulihkan akses ke semua bitcoin mereka menggunakan frasa pemulihan mereka dan, jika perlu, passphrase mereka. Namun, perlu untuk menentukan kepada perangkat lunak, selama operasi pemulihan ini, indeks akun yang berbeda yang digunakan.

Mari kita sekarang lihat tahapan yang berbeda dari coinjoin Whirlpool dalam akun-akun ini.

### TX0

Titik awal dari setiap coinjoin Whirlpool adalah akun **deposit**. Akun ini adalah yang Anda gunakan secara otomatis ketika Anda membuat dompet Bitcoin baru. Akun ini harus dikreditkan dengan bitcoin yang ingin Anda campur.

`Tx0` mewakili langkah pertama dalam proses pencampuran Whirlpool. Tujuannya adalah untuk mempersiapkan dan menyamakan UTXO untuk coinjoin, membaginya menjadi unit yang sesuai dengan jumlah kolam yang dipilih, untuk memastikan homogenitas pencampuran. UTXO yang disamakan kemudian dikirim ke akun **premix**. Sedangkan untuk selisih yang tidak dapat masuk ke kolam, dipisahkan ke akun khusus: **bad bank** (atau "doxxic change").

Transaksi awal `Tx0` ini juga berfungsi untuk menyelesaikan biaya layanan yang harus dibayar kepada koordinator coinjoin. Berbeda dengan langkah-langkah berikutnya, transaksi ini tidak kolaboratif; pengguna harus oleh karena itu menanggung seluruh biaya penambangan:

![BTC204](assets/en/54/09.webp)

Dalam contoh transaksi `Tx0` ini, input sebesar `372 000 sats` dari akun **deposit** kita dibagi menjadi beberapa UTXO output, yang didistribusikan sebagai berikut:
- Jumlah `5 000 sats` yang ditujukan untuk koordinator untuk biaya layanan, sesuai dengan masuknya ke kolam `100 000 sats`;
- 3 UTXO yang disiapkan untuk pencampuran, dialihkan ke akun **premix** kita dan didaftarkan dengan koordinator. UTXO ini disamakan pada `108 000 sats` masing-masing, untuk menutupi biaya penambangan untuk campuran awal mereka;
- Kelebihan yang tidak dapat masuk ke kolam, karena terlalu kecil, dianggap sebagai perubahan toksik. Ini dikirim ke akun khususnya. Di sini, perubahan ini berjumlah `40 000 sats`;
- Akhirnya, ada `3,000 sats` yang tidak merupakan output, tetapi merupakan biaya penambangan yang diperlukan untuk mengonfirmasi `Tx0`.
Sebagai contoh, berikut ini adalah Tx0 Whirlpool nyata (bukan dari saya): [edef60744f539483d868caff49d4848e5cc6e805d6cdc8d0f9bdbbaedcb5fc46](https://mempool.space/fr/tx/edef60744f539483d868caff49d4848e5cc6e805d6cdc8d0f9bdbbaedcb5fc46)

![BTC204](assets/notext/54/10.webp)

### Perubahan Toksik

Kelebihan yang tidak dapat diintegrasikan ke dalam kolam, di sini setara dengan `40,000 sats`, dialihkan ke akun **bad bank**, juga disebut sebagai "perubahan toksik," untuk memastikan pemisahan ketat dari UTXO lainnya di dompet.
UTXO ini berbahaya bagi privasi pengguna karena tidak hanya masih terikat pada masa lalunya, dan dengan demikian mungkin kepada identitas pemiliknya, tetapi juga ditandai sebagai milik pengguna yang telah berpartisipasi dalam coinjoin.
![BTC204](assets/notext/54/11.webp)

Jika UTXO ini digabungkan dengan output yang telah dicampur, mereka akan kehilangan semua privasi yang diperoleh selama siklus coinjoin, terutama karena CIOH (*Common-Input-Ownership-Heuristic*). Jika digabungkan dengan perubahan beracun lainnya, pengguna berisiko kehilangan privasi karena ini akan menghubungkan berbagai entri dari siklus coinjoin. Oleh karena itu, harus ditangani dengan hati-hati. Kami akan membahas lebih detail tentang pengelolaan UTXO beracun ini di bagian terakhir dari bab ini.

### Campuran Awal

Setelah `Tx0` selesai, UTXO yang diseimbangkan dikirim ke akun **premix** dompet kami, siap untuk diperkenalkan ke dalam siklus coinjoin pertama mereka, yang juga disebut "campuran awal." Jika, seperti dalam contoh kami, `Tx0` menghasilkan beberapa UTXO yang dimaksudkan untuk pencampuran, masing-masing akan diintegrasikan ke dalam campuran awal yang terpisah.

Di akhir campuran pertama ini, akun **premix** akan kosong, sementara koin kami, setelah membayar biaya penambangan untuk coinjoin pertama ini, akan disesuaikan tepat dengan jumlah yang ditentukan oleh kolam yang dipilih. Dalam contoh kami, UTXO awal kami sebesar `108,000 sats` akan dikurangi menjadi tepat `100,000 sats`.

![BTC204](assets/notext/54/12.webp)

### Remix

Setelah campuran awal, UTXO ditransfer ke akun **postmix**. Akun ini mengumpulkan baik UTXO yang sudah dicampur maupun yang menunggu untuk dicampur ulang. Ketika klien Whirlpool aktif, UTXO di akun **postmix** secara otomatis tersedia untuk pencampuran ulang dan akan dipilih secara acak untuk berpartisipasi dalam siklus baru ini.
Sebagai pengingat, remix kemudian 100% gratis: tidak diperlukan biaya layanan tambahan atau biaya penambangan. Menjaga UTXO di akun **postmix** dengan demikian mempertahankan nilai mereka yang utuh dan secara simultan meningkatkan anonset mereka. Itulah mengapa penting untuk membiarkan koin ini berpartisipasi dalam beberapa siklus coinjoin. Ini tidak membebani Anda sama sekali, dan itu meningkatkan tingkat anonimitas mereka.

Ketika Anda memutuskan untuk menghabiskan UTXO yang telah dicampur, Anda dapat melakukannya langsung dari akun **postmix** ini. Disarankan untuk menjaga UTXO yang telah dicampur di akun ini untuk mendapatkan keuntungan dari remix gratis dan untuk mencegah mereka keluar dari sirkuit Whirlpool, yang dapat menurunkan privasi mereka.

### Bagaimana cara mengelola postmix Anda dengan benar?

Setelah melakukan siklus coinjoin, strategi terbaik adalah menjaga UTXO Anda di akun **postmix**, menunggu penggunaan masa depan mereka. Bahkan disarankan untuk membiarkan mereka remix secara tak terbatas sampai Anda perlu menghabiskannya.

Beberapa pengguna mungkin mempertimbangkan untuk mentransfer bitcoin yang telah dicampur mereka ke dompet yang diamankan oleh dompet perangkat keras. Ini mungkin, tetapi penting untuk mengikuti rekomendasi Samourai Wallet dengan cermat agar tidak mengompromikan kerahasiaan yang diperoleh.

Menggabungkan UTXO adalah kesalahan yang paling sering dibuat. Perlu untuk menghindari menggabungkan UTXO yang telah dicampur dengan UTXO yang belum dicampur dalam transaksi yang sama, untuk menghindari Common-Input-Ownership-Heuristic (CIOH). Ini memerlukan pengelolaan UTXO Anda dalam dompet Anda dengan hati-hati, terutama dalam hal pelabelan.

![BTC204](assets/notext/54/13.webp)
Juga penting untuk berhati-hati dalam mengkonsolidasikan UTXO campuran di antara mereka sendiri. Konsolidasi moderat dapat dipertimbangkan jika UTXO campuran Anda memiliki anonset yang signifikan, tetapi ini akan secara tak terhindarkan menurunkan kerahasiaan koin Anda. Pastikan bahwa konsolidasi tidak terlalu signifikan atau dilakukan setelah jumlah remix yang tidak cukup, dengan risiko menetapkan tautan yang dapat ditelusuri antara UTXO Anda sebelum dan setelah siklus coinjoin. Dalam kasus keraguan tentang manipulasi ini, praktik terbaik adalah tidak mengkonsolidasikan UTXO pasca-campuran, dan mentransfer mereka satu per satu ke dompet perangkat keras Anda, menghasilkan alamat kosong baru setiap kali. Lagi, ingat untuk memberi label yang tepat pada setiap UTXO yang diterima. Juga disarankan untuk tidak mentransfer UTXO pasca-campuran Anda ke dompet yang menggunakan skrip tidak umum. Misalnya, jika Anda memasuki Whirlpool dari dompet multisig yang menggunakan skrip `P2WSH`, ada kemungkinan kecil Anda akan dicampur dengan pengguna lain yang memiliki jenis dompet yang sama secara asli. Jika Anda menarik pasca-campuran Anda ke dompet multisig yang sama, tingkat privasi bitcoin campuran Anda akan sangat berkurang. Di luar skrip, ada banyak jejak dompet lain yang dapat menipu Anda.

Seperti pada transaksi Bitcoin apa pun, juga penting untuk tidak menggunakan ulang alamat penerima. Setiap transaksi baru harus diterima di alamat kosong baru.

Solusi paling sederhana dan paling aman adalah membiarkan UTXO campuran Anda beristirahat di akun **pasca-campuran** mereka, membiarkan mereka remix dan hanya menyentuh mereka untuk dibelanjakan. Dompet Samourai dan Sparrow memiliki perlindungan tambahan terhadap semua risiko terkait analisis rantai ini. Perlindungan ini membantu Anda menghindari kesalahan.

### Bagaimana cara mengelola perubahan toksik Anda dengan tepat?

Selanjutnya, Anda harus berhati-hati dalam mengelola perubahan toksik Anda, perubahan yang tidak bisa masuk ke kolam coinjoin. UTXO toksik ini, yang dihasilkan dari penggunaan Whirlpool, menimbulkan risiko terhadap privasi Anda karena mereka menetapkan tautan antara Anda dan penggunaan coinjoin. Oleh karena itu, sangat penting untuk menanganinya dengan hati-hati dan tidak menggabungkannya dengan UTXO lain, terutama UTXO campuran.

Berikut adalah strategi yang berbeda untuk dipertimbangkan dalam menggunakannya:
- **Campurkan dalam kolam yang lebih kecil:** Jika UTXO toksik Anda cukup besar untuk masuk ke kolam yang lebih kecil sendirian, pertimbangkan untuk mencampurnya. Ini seringkali merupakan opsi terbaik. Namun, menggabungkan beberapa UTXO toksik untuk mengakses kolam tidak disarankan, karena ini dapat menghubungkan berbagai entri Anda;
- **Tandai sebagai "tidak dapat dibelanjakan":** Pendekatan lain adalah untuk tidak lagi menggunakannya, menandainya sebagai "tidak dapat dibelanjakan" di akun khusus mereka, dan hanya hodl. Ini memastikan Anda tidak secara tidak sengaja menghabiskannya. Jika nilai bitcoin meningkat, kolam baru yang lebih cocok untuk UTXO toksik Anda mungkin muncul;
- **Buat donasi:** Pertimbangkan untuk membuat donasi, bahkan yang sederhana, kepada pengembang yang bekerja pada Bitcoin dan perangkat lunak terkaitnya. Anda juga dapat mendonasikan ke organisasi yang menerima BTC. Jika mengelola UTXO toksik Anda terasa terlalu rumit, Anda dapat dengan mudah menyingkirkannya dengan membuat donasi.
- **Beli Kartu Hadiah:** Platform seperti [Bitrefill](https://www.bitrefill.com/) memungkinkan Anda untuk menukar bitcoin dengan kartu hadiah yang dapat digunakan di berbagai pedagang. Ini bisa menjadi cara untuk menyingkirkan UTXO toksik Anda tanpa kehilangan nilai terkait.
- **Konsolidasikan pada Monero:** Samourai Wallet menawarkan layanan pertukaran atomik antara BTC dan XMR. Ini ideal untuk mengelola UTXO beracun dengan mengkonsolidasikannya pada Monero, tanpa mengompromikan privasi Anda melalui KYC, sebelum mengirimkannya kembali ke Bitcoin. Namun, opsi ini bisa mahal dalam hal biaya penambangan dan premi karena kendala likuiditas.
- **Kirimkan ke Lightning Network:** Memindahkan UTXO ini ke Lightning Network untuk mendapatkan keuntungan dari biaya transaksi yang lebih rendah adalah opsi yang menarik. Namun, metode ini mungkin mengungkapkan informasi tertentu tergantung pada penggunaan Lightning Anda dan oleh karena itu harus dilakukan dengan hati-hati.

### Bagaimana cara menggunakan Whirlpool?

Menyusul penangkapan pendiri Samourai Wallet dan penyitaan server mereka pada 24 April 2024, alat Whirlpool tidak lagi berfungsi, bahkan bagi mereka yang memiliki Dojo sendiri. Sebelumnya, ini tersedia di Samourai Wallet dan Sparrow Wallet.

![BTC204](assets/notext/54/14.webp)

Namun, masih mungkin bahwa alat ini dapat diaktifkan kembali dalam beberapa minggu ke depan, tergantung pada hasil persidangan, atau diluncurkan kembali dengan cara yang berbeda. Dalam hal apapun, saya percaya bahwa pasar untuk coinjoin di Bitcoin tidak akan lama tanpa penawaran, karena ada permintaan yang jelas. Selain itu, model Whirlpool, yang paling maju dalam hal privasi, pasti akan digunakan di masa depan untuk implementasi lain.

Kami mengikuti perkembangan kasus ini serta perkembangan terkait alat yang terkait. Tenang saja, kami akan memperbarui pelatihan ini seiring dengan tersedianya informasi baru.

Dalam bab berikutnya, kita akan menemukan apa itu "anonsets", bagaimana indikator ini dihitung, dan bagaimana mereka dapat membantu kita memperkirakan efektivitas siklus coinjoin.

https://planb.network/tutorials/privacy/coinjoin-sparrow-wallet

https://planb.network/tutorials/privacy/coinjoin-samourai-wallet

https://planb.network/tutorials/privacy/coinjoin-dojo

## Set Anonimitas
<chapterId>be1093dc-1a74-40e5-9545-2b97a7d7d431</chapterId>

Setelah mempelajari cara kerja coinjoin dan tantangan yang terkait dengan pencampuran yang efektif, sekarang kita akan belajar bagaimana mengukur efektivitas ini. Bagaimana menentukan apakah proses coinjoin telah efektif dan seberapa tingkat anonimitas yang telah diperoleh sebuah koin? Inilah yang akan kita jelajahi dalam bab ini dengan set anonimitas atau "anonsets" dalam bahasa Inggris.

### Pengingat tentang Kegunaan Coinjoin
Kegunaan CoinJoin terletak pada kemampuannya untuk menghasilkan plausible deniability dengan membenamkan koin Anda dalam sebuah kelompok koin yang tidak dapat dibedakan. Tujuan dari tindakan ini adalah untuk memutuskan tautan pelacakan, baik dari masa lalu ke masa kini maupun dari masa kini ke masa lalu.
Dengan kata lain, seorang analis yang mengetahui transaksi awal Anda (`Tx0`) pada masuknya siklus CoinJoin seharusnya tidak dapat mengidentifikasi dengan pasti UTXO Anda pada keluaran siklus remix (analisis dari masuk siklus ke keluar siklus).

![BTC204](assets/en/55/01.webp)

Sebaliknya, seorang analis yang mengetahui UTXO Anda pada keluaran siklus CoinJoin seharusnya tidak dapat menentukan transaksi asli pada masuknya siklus (analisis dari keluar siklus ke masuk siklus).

![BTC204](assets/en/55/02.webp)
Untuk menilai kesulitan bagi seorang analis dalam menghubungkan masa lalu dengan masa kini dan sebaliknya, perlu untuk mengkuantifikasi ukuran kelompok koin homogen di mana koin Anda tersembunyi. Ukuran ini memberi tahu kita jumlah analisis yang memiliki probabilitas identik. Jadi, jika analisis yang benar tenggelam di antara 3 analisis lain dengan probabilitas yang sama, tingkat penyembunyian Anda sangat rendah. Namun, jika analisis yang benar berada dalam satu set dari 20.000 analisis yang semuanya sama-sama mungkin, koin Anda sangat tersembunyi dengan baik. Dan tepatnya, ukuran kelompok ini mewakili indikator yang disebut "anonsets".

### Memahami Anonsets

Anonsets berfungsi sebagai indikator untuk menilai tingkat privasi dari UTXO tertentu. Lebih spesifik lagi, mereka mengukur jumlah UTXO yang tidak dapat dibedakan dalam set yang mencakup koin yang diteliti. Kebutuhan akan set UTXO homogen berarti bahwa anonsets biasanya dihitung selama siklus CoinJoin. Penggunaan indikator ini sangat relevan untuk Whirlpool CoinJoins karena keseragamannya.

Anonsets memungkinkan, jika sesuai, untuk menilai kualitas dari CoinJoins. Ukuran anonset yang besar menandakan tingkat anonimitas yang tinggi, karena menjadi sulit untuk membedakan UTXO spesifik dalam set homogen.

Ada 2 jenis anonsets:
- **Anonset prospektif;**
- **Anonset retrospektif.**

### Anonset Prospektif

Anonset prospektif menunjukkan ukuran kelompok di mana UTXO yang diteliti tersembunyi pada saat keluar dari siklus, dengan mengetahui UTXO pada saat masuk, yaitu, jumlah koin yang tidak dapat dibedakan yang ada dalam kelompok ini. Dalam bahasa Inggris, nama indikator ini adalah "forward anonset", atau "forward-looking metrics".
Indikator ini memungkinkan pengukuran resistensi privasi koin terhadap analisis dari masa lalu ke masa kini (input ke output).

![BTC204](assets/en/55/03.webp)

Metrik ini memperkirakan sejauh mana UTXO Anda dilindungi dari upaya untuk merekonstruksi sejarahnya dari titik masuknya hingga titik keluarnya dalam proses coinjoin.

Misalnya, jika transaksi Anda berpartisipasi dalam siklus coinjoin pertamanya dan dua siklus keturunan tambahan telah selesai, anonset prospektif dari koin Anda akan menjadi `13`:

![BTC204](assets/notext/55/04.webp)

Sebagai contoh, mari kita bayangkan bahwa koin kita pada masuknya siklus coinjoin mendapat manfaat dari anonset prospektif sebesar `86,871`. Secara praktis, ini berarti ia tersembunyi di antara `86,871` koin yang tidak dapat dibedakan. Bagi pengamat eksternal yang mengetahui koin ini di awal siklus coinjoin dan mencoba melacak keluarnya, mereka akan dihadapkan pada `86,871` UTXO yang mungkin, masing-masing dengan probabilitas identik untuk menjadi koin yang dicari.

![BTC204](assets/en/55/05.webp)

### Anonset Retrospektif

Anonset retrospektif menunjukkan jumlah sumber yang mungkin untuk koin tertentu, dengan mengetahui UTXO pada saat keluar dari siklus. Indikator ini mengukur resistensi privasi koin terhadap analisis dari masa kini ke masa lalu (keluar ke masuk), yaitu, seberapa sulit bagi seorang analis untuk melacak kembali ke asal usul koin Anda, sebelum siklus coinjoin. Dalam bahasa Inggris, nama indikator ini adalah "backward anonset," atau "backward-looking metrics."

![BTC204](assets/en/55/06.webp)

Dengan mengetahui UTXO Anda pada saat keluar dari siklus, anonset retrospektif menentukan jumlah transaksi Tx0 potensial yang bisa telah membentuk masuknya Anda ke dalam siklus coinjoin. Dalam diagram di bawah ini, ini sesuai dengan jumlah semua gelembung oranye.
![BTC204](assets/notext/55/07.webp)
Sebagai contoh, mari kita bayangkan bahwa koin kita di akhir siklus coinjoin mendapatkan anonset retrospektif sebesar `42,185`. Secara praktis, ini berarti ada `42,185` sumber potensial untuk UTXO ini. Jika seorang pengamat eksternal mengidentifikasi koin ini di akhir siklus dan berusaha melacak asal-usulnya, mereka akan menghadapi `42,185` sumber yang mungkin, semua dengan kemungkinan yang sama untuk menjadi asal-usul yang dicari.

![BTC204](assets/en/55/08.webp)

### Bagaimana cara menghitung anonset secara konkret?
Memungkinkan untuk secara manual menghitung anonset seseorang menggunakan block explorer untuk set yang kecil. Namun, untuk anonset yang lebih besar, penggunaan alat khusus menjadi sangat penting. Sejauh pengetahuan saya, satu-satunya perangkat lunak yang mampu melakukan tugas ini adalah *Whirlpool Stats Tool*, sebuah alat Python yang dikembangkan oleh tim di Samourai dan OXT. Sayangnya, alat ini saat ini tidak berfungsi menyusul penangkapan pendiri Samourai dan penghentian OXT, yang digunakan untuk mengekstrak data dari blockchain.
![BTC204](assets/notext/55/09.webp)

Seperti yang telah kita lihat dalam bab ini, anonset hanya dapat dihitung jika ada homogenitas tertentu dalam struktur coinjoins. Dan tepatnya, dalam bab berikutnya, kita akan menemukan cara mengkuantifikasi homogenitas ini dalam transaksi Bitcoin, apakah itu coinjoin atau transaksi tradisional.

https://planb.network/tutorials/privacy/wst-anonsets

## Entropi
<chapterId>e4fe289d-618b-49a2-84c9-68c562e708b4</chapterId>

Seperti yang telah kita lihat dalam bagian ini tentang coinjoins, homogenitas UTXO dalam input dan output memainkan peran penting dalam meningkatkan kerahasiaan transaksi Bitcoin. Parameter ini memungkinkan plausible deniability terhadap analisis rantai. Beberapa metode dapat mengukur homogenitas ini, tetapi salah satu yang paling efektif, menurut saya, adalah penggunaan indikator yang disediakan oleh alat *Boltzmann*, yang dikembangkan oleh tim di OXT dan Samourai Wallet, khususnya entropi transaksi. Inilah yang akan kita pelajari secara detail dalam bab ini.

Berbeda dengan anonset, yang dihitung dari serangkaian transaksi, indikator yang akan kita sajikan di sini hanya berfokus pada satu transaksi, apakah itu coinjoin atau transaksi tradisional.

### Jumlah interpretasi

Indikator pertama yang dapat diamati pada transaksi Bitcoin adalah jumlah total interpretasi yang mungkin di mata pengamat eksternal yang menganalisis transaksi. Dengan mempertimbangkan nilai dari UTXO yang terlibat dalam transaksi, indikator ini menunjukkan jumlah cara input dapat dikaitkan dengan output. Dengan kata lain, ini menentukan jumlah interpretasi yang mungkin dapat dihasilkan sebuah transaksi dalam aliran bitcoin dari perspektif pengamat eksternal yang menganalisisnya.

Sebagai contoh, transaksi pembayaran sederhana dengan 1 input dan 2 output hanya akan memiliki satu interpretasi, yaitu input #0 membiayai output #0 dan output #1. Tidak ada interpretasi lain yang mungkin:

![BTC204](assets/notext/56/01.webp)

Sebaliknya, coinjoin yang terstruktur menurut model Whirlpool 5x5 menampilkan $1,496$ kombinasi yang mungkin:
![BTC204](assets/notext/56/02.webp)
Sebuah Whirlpool Surge Cycle 8x8 coinjoin menampilkan dirinya dengan $9,934,563$ interpretasi yang mungkin:

![BTC204](assets/notext/56/03.webp)

### Entropi
Dari jumlah interpretasi sebuah transaksi Bitcoin, kita dapat menghitung entropinya.

Dalam konteks umum kriptografi dan informasi, entropi adalah ukuran kuantitatif dari ketidakpastian atau ketidakterdugaan yang terkait dengan sumber data atau proses acak. Dengan kata lain, entropi adalah cara untuk mengukur seberapa sulit informasi itu untuk diprediksi atau ditebak.

Dalam konteks analisis rantai khususnya, entropi juga merupakan nama dari sebuah indikator, yang berasal dari entropi Shannon dan [ditemukan oleh LaurentMT](https://gist.github.com/LaurentMT/e758767ca4038ac40aaf), yang dapat dihitung pada sebuah transaksi Bitcoin.

Ketika sebuah transaksi menunjukkan jumlah interpretasi yang tinggi, seringkali lebih relevan untuk merujuk pada entropinya. Indikator ini memungkinkan pengukuran kurangnya pengetahuan analis tentang konfigurasi tepat dari transaksi. Dengan kata lain, semakin tinggi entropi, semakin sulit tugas mengidentifikasi aliran bitcoin antara input dan output menjadi bagi analis.

Dalam praktiknya, entropi mengungkapkan apakah, dari perspektif pengamat eksternal, sebuah transaksi menunjukkan berbagai interpretasi yang mungkin, hanya berdasarkan jumlah input dan output, tanpa mempertimbangkan pola dan heuristik eksternal atau internal lainnya. Entropi yang tinggi kemudian sinonim dengan kerahasiaan yang lebih baik untuk transaksi tersebut.

Entropi didefinisikan sebagai logaritma biner dari jumlah kombinasi yang mungkin. Berikut adalah rumus yang digunakan dengan $E$ adalah entropi dari transaksi dan $C$ adalah jumlah interpretasi yang mungkin:

$$
E = \log_2(C)
$$

Dalam matematika, logaritma biner (logaritma basis 2) sesuai dengan operasi invers dari mengeksponensikan 2. Dengan kata lain, logaritma biner dari $x$ adalah eksponen yang harus dinaikkan 2 untuk mendapatkan $x$. Indikator ini dengan demikian dinyatakan dalam bit.

Mari kita ambil contoh menghitung entropi untuk sebuah transaksi coinjoin yang terstruktur menurut model Whirlpool 5x5, yang, seperti disebutkan di bagian sebelumnya, menunjukkan jumlah interpretasi yang mungkin sebanyak $1,496$:

$$
\begin{align*}
C &= 1,496 \\
E &= \log_2(1,496) \\
E &= 10.5469 \text{ bit}
\end{align*}
$$
Dengan demikian, transaksi coinjoin ini menampilkan entropi sebesar $10.5469$ bit, yang dianggap sangat memuaskan. Semakin tinggi nilai ini, semakin banyak interpretasi yang diakui oleh transaksi, sehingga meningkatkan tingkat privasinya.
Untuk sebuah transaksi coinjoin 8x8 yang menampilkan $9,934,563$ interpretasi, entropinya akan menjadi:

$$
\begin{align*}
C &= 9,934,563 \\
E &= \log_2(9,934,563) \\
E &= 23.244 \text{ bit}
\end{align*}
$$

Mari kita ambil contoh lain dengan sebuah transaksi pembayaran standar, yang menampilkan 1 input dan 2 output: [1b1b0c3f0883a99f1161c64da19471841ed12a1f78e77fab128c69a5f578ccce](https://mempool.space/tx/1b1b0c3f0883a99f1161c64da19471841ed12a1f78e77fab128c69a5f578ccce)

![BTC204](assets/notext/56/04.webp)

Dalam kasus transaksi ini, satu-satunya interpretasi yang mungkin adalah: `(In.0) > (Out.0 ; Out.1)`. Akibatnya, entropinya ditetapkan pada $0$:
Efisiensi

Dari entropi transaksi, kita juga dapat menghitung efisiensinya dalam hal privasi. Indikator ini menilai efisiensi transaksi dengan membandingkannya dengan transaksi optimal yang dapat dibayangkan dalam konfigurasi yang identik.

Hal ini membawa kita untuk membahas konsep entropi maksimum, yang sesuai dengan entropi tertinggi yang secara teoritis dapat dicapai oleh struktur transaksi tertentu. Efisiensi transaksi kemudian dihitung dengan menghadapkan entropi maksimum ini dengan entropi aktual dari transaksi yang dianalisis.

Rumus yang digunakan adalah sebagai berikut dengan:
- $E_R$: entropi aktual dari transaksi yang dinyatakan dalam bit;
- $E_M$: entropi maksimum yang mungkin untuk struktur transaksi juga dinyatakan dalam bit;
- $Ef$: efisiensi dari transaksi dalam bit:

$$
Ef = E_R - E_M
$$

Sebagai contoh, untuk struktur coinjoin tipe Whirlpool 5x5, entropi maksimum adalah $10.5469$:

$$
\begin{align*}
E_R &= 10.5469 \\
E_M &= 10.5469 \\
Ef &= E_R - E_M \\
Ef &= 10.5469 - 10.5469 \\
Ef &= 0 \text{ bit}
\end{align*}
$$

Indikator ini juga dinyatakan sebagai persentase. Rumus yang digunakan adalah sebagai berikut dengan:
- $C_R$: jumlah interpretasi nyata yang mungkin;
- $C_M$: jumlah maksimum interpretasi yang mungkin dengan struktur yang sama;
- $Ef$: efisiensi yang dinyatakan dalam persentase:

$$
\begin{align*}
E_f &= \frac{C_R}{C_M} \\
E_f &= \frac{1\,496}{1\,496} \\
E_f &= 100\%
\end{align*}
$$

Efisiensi sebesar $100\%$ menunjukkan bahwa transaksi memaksimalkan potensinya untuk privasi berdasarkan strukturnya.

### Kepadatan Entropi

Entropi adalah indikator yang baik untuk mengukur privasi transaksi, tetapi sebagian bergantung pada jumlah input dan output dalam transaksi. Untuk membandingkan entropi dari 2 transaksi yang berbeda yang tidak memiliki jumlah input dan output yang sama, seseorang dapat menghitung kepadatan entropi. Indikator ini menawarkan perspektif tentang entropi relatif terhadap setiap input atau output dari transaksi. Kepadatan ini berguna untuk mengevaluasi dan membandingkan efisiensi transaksi dari berbagai ukuran.

Untuk menghitungnya, cukup bagi total entropi transaksi dengan total jumlah input dan output yang terlibat dalam transaksi:
- $E_D$: kepadatan entropi yang dinyatakan dalam bit;
- $E$: entropi dari transaksi yang dinyatakan dalam bit;
- $T$: total jumlah input dan output dalam transaksi:

$$
E_D = \frac{E}{T}
$$

Mari kita ambil contoh coinjoin Whirlpool 5x5:

$$
\begin{align*}
T &= 5 + 5 = 10 \\
E &= 10.5469 \\
E_D &= \frac{E}{T} \\
E_D &= \frac{10.5469}{10} \\
E_D &= 1.054 \text{ bit}
\end{align*}
$$

Mari kita juga menghitung kepadatan entropi dari coinjoin Whirlpool 8x8:

$$
\begin{align*}
T &= 8 + 8 = 16 \\
E &= 23.244 \\
E_D &= \frac{E}{T} \\
E_D &= \frac{23.244}{16} \\
E_D &= 1.453 \text{ bit}\end{align*}
$$

Dengan menganalisis kepadatan entropi dari dua jenis coinjoin ini, menjadi jelas bahwa, bahkan ketika menormalisasi entropi berdasarkan jumlah elemen, coinjoin "Surge Cycle 8x8" menghasilkan lebih banyak ketidakpastian untuk analisis.

### Skor Boltzmann
Informasi lain yang dianalisis dalam sebuah transaksi adalah skor Boltzmann dari setiap elemen relatif terhadap yang lain. Ini adalah tabel probabilitas kecocokan antara input dan output. Tabel ini menunjukkan, melalui skor Boltzmann, probabilitas bersyarat bahwa input tertentu terkait dengan output tertentu. Oleh karena itu, ini adalah ukuran kuantitatif dari probabilitas bersyarat bahwa sebuah asosiasi antara input dan output dalam sebuah transaksi terjadi, didasarkan pada rasio jumlah kejadian yang menguntungkan dari peristiwa ini dibandingkan dengan jumlah total kemungkinan kejadian, dalam satu set interpretasi.
Mengambil contoh coinjoin Whirlpool, tabel probabilitas bersyarat akan menyoroti peluang tautan antara setiap input dan output, memberikan ukuran kuantitatif dari ambiguitas asosiasi dalam transaksi:

| %       | Output 0 | Output 1 | Output 2 | Output 3 | Output 4 |
| ------- | -------- | -------- | -------- | -------- | -------- |
| Input 0 | 34%      | 34%      | 34%      | 34%      | 34%      |
| Input 1 | 34%      | 34%      | 34%      | 34%      | 34%      |
| Input 2 | 34%      | 34%      | 34%      | 34%      | 34%      |
| Input 3 | 34%      | 34%      | 34%      | 34%      | 34%      |
| Input 4 | 34%      | 34%      | 34%      | 34%      | 34%      |

Di sini, jelas bahwa setiap input memiliki peluang yang sama untuk dikaitkan dengan output mana pun, yang meningkatkan kerahasiaan transaksi.

Perhitungan skor Boltzmann melibatkan pembagian jumlah interpretasi di mana suatu peristiwa termanifestasi oleh jumlah total interpretasi yang tersedia. Jadi, untuk menentukan skor yang mengasosiasikan input #0 dengan output #3 (suatu peristiwa yang ada dalam $512$ interpretasi), prosesnya adalah sebagai berikut:

$$
\begin{align*}
\text{Interpretasi (IN.0 > OUT.3)} &= 512 \\
\text{Total Interpretasi} &= 1496 \\
\text{Skor} &= \frac{512}{1496} \\
\text{Skor} &= 34 \%
\end{align*}
$$

Jika kita mengunjungi kembali contoh coinjoin Whirlpool 8x8 Surge Cycle, tabel Boltzmann akan terlihat seperti ini:

|       | OUT.0 | OUT.1 | OUT.2 | OUT.3 | OUT.4 | OUT.5 | OUT.6 | OUT.7 |
|-------|-------|-------|-------|-------|-------|-------|-------|-------|
| IN.0  | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   |
| IN.1  | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   |
| IN.2  | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   |
| IN.3  | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   |
| IN.4  | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   |
| IN.5  | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   |
| IN.6  | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   |
| IN.7  | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   | 23%   |

Namun, dalam kasus transaksi sederhana yang melibatkan satu input dan 2 output, situasinya berbeda:

| %       | Output 0 | Output 1 |
|---------|----------|----------|
| Input 0 | 100%     | 100%     |

Di sini, kita melihat bahwa probabilitas untuk setiap output berasal dari input #0 adalah 100%. Probabilitas yang lebih rendah ini berarti privasi yang lebih besar dengan mengencerkan tautan langsung antara input dan output.

### Tautan Deterministik

Juga dimungkinkan untuk menghitung jumlah tautan deterministik dalam sebuah transaksi. Indikator ini mengungkapkan berapa banyak koneksi antara input dan output dalam transaksi yang dianalisis adalah tidak dapat disangkal, dengan probabilitas 100%. Indikator ini kemudian dapat dilengkapi dengan menghitung rasio tautan deterministik. Rasio ini memberikan perspektif tentang bobot tautan deterministik ini dalam semua tautan transaksi.

Misalnya, sebuah transaksi coinjoin tipe Whirlpool menunjukkan tidak ada tautan deterministik antara input dan output, sehingga menampilkan indikator 0 tautan dan rasio 0%. Sebaliknya, dalam transaksi pembayaran sederhana kedua yang kami periksa (dengan satu input dan 2 output), indikator memberi tahu kita bahwa ada 2 tautan deterministik dan rasionya mencapai 100%. Oleh karena itu, indikator nol menandakan privasi yang sangat baik karena tidak adanya koneksi langsung dan tidak dapat disangkal antara input dan output.

### Bagaimana Menghitung Indikator Ini?
Menghitung indikator ini secara manual menggunakan persamaan yang telah saya sediakan relatif sederhana. Kesulitan utama terletak pada menentukan jumlah interpretasi yang mungkin dari sebuah transaksi. Untuk transaksi standar, perhitungan ini dapat dilakukan dengan tangan. Namun, untuk coinjoin, tugasnya jauh lebih kompleks.

Sebelumnya, ada sebuah alat Python bernama _Boltzmann Calculator_, yang dikembangkan oleh tim di OXT dan Samourai, yang memungkinkan untuk perhitungan otomatis semua indikator ini untuk transaksi Bitcoin:

![BTC204](assets/notext/56/05.webp)

Juga dimungkinkan untuk menggunakan situs web KYCP.org untuk analisis ini:

![BTC204](assets/notext/56/06.webp)
Sayangnya, menyusul penangkapan para pendiri Samourai, alat-alat ini saat ini tidak beroperasi. Sekarang setelah kita telah membahas coinjoins secara detail, kita akan menjelajahi teknik privasi lain yang tersedia di Bitcoin di bagian terakhir dari pelatihan kita. Kita akan meneliti payjoins, jenis transaksi tertentu pseudo-coinjoins, protokol alamat statis, serta langkah-langkah yang bertujuan untuk meningkatkan privasi tidak pada level transaksi, tetapi pada jaringan node.

https://planb.network/tutorials/privacy/boltzmann-entropy

# Memahami taruhan teknik privasi lanjutan lainnya
<partId>19989ae6-d608-4acf-b698-2cf1e7e5e6ae</partId>

## Transaksi Payjoin
<chapterId>c1e90b95-f709-4574-837b-2ec26b11286f</chapterId>

Coinjoin saat ini mewakili metode paling efektif untuk memperkenalkan ketidakpastian ke dalam pelacakan koin selama analisis rantai. Seperti yang telah kita lihat di bab-bab sebelumnya, untuk mencapai pencampuran yang efektif, diperlukan agar input dan output sehomogen mungkin. Selain itu, sangat penting bagi koin untuk diintegrasikan ke dalam grup sebesar mungkin untuk memaksimalkan anonsets. Dengan demikian, agar coinjoins efektif, mereka harus melibatkan sejumlah besar koin yang seragam. Banyaknya persyaratan ini berarti bahwa transaksi coinjoin memiliki struktur yang sangat kaku: jumlahnya telah ditentukan, dan semua peserta harus mematuhinya untuk memastikan keseragaman proses. Selain itu, coinjoins memerlukan sinkronisasi antara semua peserta dan koordinator selama konstruksi transaksi.
Persyaratan ini membuat coinjoin tidak cocok untuk pembayaran langsung. Misalnya, jika Anda memiliki sepotong 1M sats dalam kolam coinjoin, menggunakannya langsung sebagai pembayaran akan rumit. Ini akan memerlukan sinkronisasi dengan peserta lain dan koordinator untuk membangun transaksi kolaboratif tepat pada saat Anda perlu melakukan pembayaran, dan jumlah pembelian harus cocok persis dengan nilai potongan Anda, yang praktis tidak dapat dicapai. Oleh karena itu, transaksi coinjoin pada dasarnya adalah transaksi kolaboratif menyapu, yang berarti bahwa umumnya pemilik input yang sama yang ditemukan di output.
Namun, akan menarik untuk memiliki struktur transaksi yang memungkinkan pembayaran praktis sambil memperkenalkan keraguan dalam analisis rantai. Inilah yang akan kita jelajahi di bab ini dan selanjutnya.

### Apa itu transaksi payjoin?

Payjoin adalah struktur transaksi Bitcoin spesifik yang meningkatkan privasi pengguna selama pengeluaran dengan berkolaborasi dengan penerima pembayaran.

LaurentMT pertama kali menyebutkan metode ini pada tahun 2015 dengan nama "transaksi steganografi", menurut dokumen yang dapat diakses [di sini](https://gist.githubusercontent.com/LaurentMT/e758767ca4038ac40aaf/raw/c8125f6a3c3d0e90246dc96d3b603690ab6f1dcc/gistfile1.txt). Teknik ini kemudian diadopsi oleh Samourai Wallet, yang pada tahun 2018, adalah klien pertama yang mengimplementasikannya dengan alat Stowaway. Konsep payjoin juga ditemukan dalam [BIP79](https://github.com/bitcoin/bips/blob/master/bip-0079.mediawiki) dan [BIP78](https://github.com/bitcoin/bips/blob/master/bip-0078.mediawiki). Beberapa istilah digunakan untuk menunjuk payjoin:
- Payjoin;
- Stowaway;
- P2EP (*Pay-to-End-Point*);
- Transaksi steganografi.
Keunikan dari payjoin terletak pada kemampuannya untuk menghasilkan sebuah transaksi yang pada pandangan pertama tampak biasa saja, namun sebenarnya merupakan mini Coinjoin antara dua orang. Untuk ini, struktur transaksi melibatkan penerima pembayaran dalam input bersama dengan pengirim sebenarnya. Penerima tersebut kemudian menyertakan pembayaran kepada diri mereka sendiri di tengah transaksi yang memungkinkan mereka dibayar.
Mari kita ambil contoh untuk lebih memahami proses ini. Alice membeli sebuah baguette seharga 4.000 sats menggunakan UTXO sebesar 10.000 sats dan memilih untuk menggunakan payjoin. Tukang roti nya, Bob, menambahkan UTXO sebesar 15.000 sats miliknya dalam input, yang ia ambil kembali secara penuh dalam output, ditambah dengan 4.000 sats dari Alice.

![BTC204](assets/notext/61/01.webp)
Dalam contoh ini, Bob tukang roti memasukkan 15.000 sats dan keluar dengan 19.000 sats, perbedaannya tepat 4.000 sats, yang merupakan harga dari baguette tersebut. Di sisi Alice, dia masuk dengan 10.000 sats dan berakhir dengan 6.000 sats di output, yang mewakili saldo -4.000 sats, yaitu harga dari baguette tersebut. Untuk menyederhanakan contoh, saya sengaja menghilangkan biaya penambangan dalam transaksi ini.

### Apa tujuan dari payjoin?

Transaksi payjoin memenuhi dua tujuan yang memungkinkan pengguna untuk meningkatkan privasi pembayaran mereka.

Pertama, payjoin bertujuan untuk menyesatkan pengamat eksternal dengan menciptakan umpan palsu dalam analisis rantai. Ini dimungkinkan berkat heuristik CIOH (*Common Input Ownership Heuristic*). Seperti yang kita lihat di bagian 3, biasanya, ketika sebuah transaksi di blockchain memiliki beberapa input, diasumsikan bahwa semua input ini milik entitas atau pengguna yang sama.

Dengan demikian, ketika seorang analis memeriksa transaksi payjoin, mereka dipimpin untuk percaya bahwa semua input berasal dari orang yang sama. Namun, persepsi ini salah, karena penerima pembayaran juga berkontribusi pada input bersama dengan pembayar sebenarnya. Analisis rantai oleh karena itu dialihkan ke interpretasi yang ternyata salah.

Mari kita kembali ke contoh transaksi payjoin kami untuk pembayaran sebuah baguette:

![BTC204](assets/notext/61/02.webp)

Melihat transaksi ini di blockchain, seorang pengamat eksternal yang mengikuti heuristik analisis rantai biasa akan menginterpretasikannya sebagai berikut: "*Alice menggabungkan 2 UTXO dalam input transaksi untuk membayar 19.000 sats kepada Bob*".

![BTC204](assets/en/61/03.webp)

Interpretasi ini jelas salah, seperti yang Anda sudah tahu, kedua UTXO dalam input tidak milik orang yang sama. Satu berasal dari Alice, pembeli baguette, dan yang lainnya dari Bob, tukang roti.

![BTC204](assets/notext/61/04.webp)

Analisis pengamat eksternal ini dengan demikian diarahkan ke kesimpulan yang salah, yang memastikan pelestarian kerahasiaan para pihak yang terlibat.

### Transaksi steganografi

Tujuan kedua dari payjoin adalah untuk menipu pengamat eksternal tentang jumlah pembayaran sebenarnya yang dilakukan. Dengan memeriksa struktur transaksi, analis mungkin percaya bahwa pembayaran setara dengan jumlah salah satu output.
Jika kita kembali ke contoh kita tentang membeli sebuah baguette, analis akan berpikir bahwa jumlah pembayaran sesuai dengan UTXO sebesar 6.000 sats atau UTXO sebesar 19.000 sats. Dalam kasus ini, analis lebih cenderung berpikir bahwa jumlah pembayaran adalah 19.000 sats, karena ada 2 UTXO dalam output, di mana setidaknya satu di antaranya lebih besar dari 6.000 sats (tidak ada alasan logis untuk menggunakan 2 UTXO untuk membayar 6.000 sats ketika satu UTXO saja sudah cukup untuk pembayaran ini). ![BTC204](assets/en/61/05.webp)

Namun pada kenyataannya, analisis ini tidak benar. Jumlah pembayaran tidak sesuai dengan salah satu output. Sebenarnya, itu adalah perbedaan antara UTXO penerima dalam output dan UTXO penerima dalam input.

![BTC204](assets/en/61/06.webp)

Dalam hal ini, transaksi payjoin masuk ke dalam ranah steganografi. Ini memungkinkan menyembunyikan jumlah sebenarnya dari sebuah transaksi dalam transaksi palsu yang bertindak sebagai pengalih perhatian.

Steganografi adalah teknik untuk menyembunyikan informasi di dalam data atau objek lain, dengan cara yang tidak memungkinkan keberadaan informasi tersembunyi itu terdeteksi. Sebagai contoh, sebuah pesan rahasia bisa disembunyikan di dalam titik pada teks yang tidak terkait, membuatnya tidak terdeteksi oleh mata telanjang (ini adalah teknik [micropoint](https://fr.wikipedia.org/wiki/Micropoint)).

Berbeda dengan enkripsi, yang membuat informasi tidak dapat dimengerti tanpa kunci dekripsi, steganografi tidak mengubah informasi. Informasi tetap terlihat. Tujuannya lebih untuk menyembunyikan keberadaan pesan rahasia itu sendiri, sedangkan enkripsi jelas menunjukkan keberadaan informasi tersembunyi, meskipun tidak dapat diakses tanpa kunci. Inilah mengapa nama awal untuk payjoin adalah "*transaksi steganografis*".

Analogi bisa dibuat antara kriptografi dan coinjoin, serta antara steganografi dan payjoin. Memang, coinjoin memiliki atribut serupa dengan enkripsi: metodenya dikenali, tetapi informasinya tidak dapat diuraikan. Sebaliknya, payjoin mirip dengan steganografi: informasinya secara teoritis dapat diakses, tetapi karena metode penyembunyiannya tidak dikenali, informasi itu menjadi tidak dapat diakses.

### Bagaimana menggunakan payjoin?

Di antara perangkat lunak yang dikenal mendukung payjoin, ada Sparrow Wallet, Wasabi Wallet, Mutiny, BitMask, BlueWallet, dan JoinMarket, serta processor pembayaran BTCPay.

![BTC204](assets/notext/61/07.webp)
Implementasi payjoin paling lanjut hanyalah Stowaway di Samourai Wallet. Namun, sejak penangkapan pendiri perangkat lunak tersebut, alat ini sekarang hanya berfungsi sebagian. Keuntungan dari Stowaway adalah bahwa itu adalah protokol yang lengkap dan sangat mudah digunakan, yang mendukung baik penerimaan maupun pengiriman payjoins. Transaksi yang ditandatangani sebagian dapat ditukar secara manual melalui pemindaian beberapa kode QR atau secara otomatis melalui Tor melalui Soroban. Ini adalah opsi komunikasi terakhir yang saat ini tidak berfungsi.
![BTC204](assets/notext/61/08.webp)

Kesulitan menggunakan payjoin terletak pada ketergantungannya pada partisipasi pedagang. Sebagai pelanggan, menggunakan payjoin tidak mungkin jika pedagang tidak mendukungnya. Ini menambah kesulitan tambahan selama pembelian: tidak hanya sulit menemukan pedagang yang menerima bitcoin, tetapi jika seseorang juga mencari mereka yang mendukung payjoins, itu menjadi lebih rumit lagi.
Solusi yang dapat digunakan adalah dengan menggunakan struktur transaksi yang memperkenalkan ambiguitas dalam analisis rantai tanpa memerlukan kerjasama dari penerima. Hal ini memungkinkan kita untuk meningkatkan privasi pembayaran kita tanpa bergantung pada partisipasi aktif dari para pedagang. Inilah yang akan kita pelajari di bab selanjutnya.
https://planb.network/tutorials/privacy/payjoin-sparrow-wallet

https://planb.network/tutorials/privacy/payjoin-samourai-wallet

## Pembayaran Mini-Coinjoins
<chapterId>300777ee-30ae-43d7-ab00-479dac3522c1</chapterId>

Ketika mencari untuk melakukan transaksi pembayaran sambil mempertahankan tingkat privasi tertentu, payjoin adalah opsi yang baik. Namun, seperti yang telah kita lihat, payjoin memerlukan keterlibatan penerima. Apa yang harus dilakukan jika penerima menolak untuk berpartisipasi dalam payjoin, atau jika Anda sederhananya lebih memilih untuk tidak melibatkan mereka? Alternatifnya adalah menggunakan transaksi Stonewall atau Stonewall x2. Mari kita lihat lebih dekat kedua jenis transaksi ini.

### Transaksi Stonewall

Stonewall adalah bentuk khusus dari transaksi Bitcoin yang bertujuan untuk meningkatkan privasi pengguna selama pengeluaran dengan meniru pseudo-coinjoin antara dua orang, tanpa benar-benar menjadi satu. Memang, transaksi ini tidak kolaboratif. Seorang pengguna dapat membangunnya sendiri, hanya melibatkan UTXO yang mereka miliki sebagai input. Anda dapat dengan demikian membuat transaksi Stonewall untuk setiap kesempatan, tanpa perlu sinkronisasi dengan pengguna lain atau penerima.

Operasi transaksi Stonewall adalah sebagai berikut: dalam input transaksi, pengirim menggunakan 2 UTXO yang milik mereka. Dalam output, transaksi menghasilkan 4 UTXO, 2 di antaranya akan berjumlah sama persis. 2 UTXO lainnya akan merupakan kembalian. Di antara 2 output dengan jumlah yang sama, hanya satu yang sebenarnya akan pergi ke penerima pembayaran.
Hanya ada 2 peran dalam transaksi Stonewall:
- Pengirim, yang melakukan pembayaran;
- Penerima, yang mungkin tidak menyadari sifat khusus dari transaksi dan hanya menunggu pembayaran dari pengirim.

Mari kita ambil contoh untuk memahami struktur transaksi ini. Alice berada di toko roti Bob untuk membeli baguette-nya, yang harganya 4,000 sats. Dia ingin membayar dengan bitcoin sambil mempertahankan tingkat privasi tertentu mengenai pembayarannya. Oleh karena itu, dia memutuskan untuk membangun transaksi Stonewall untuk pembayaran tersebut.

![BTC204](assets/notext/62/01.webp)

Menganalisis transaksi ini, kita dapat melihat bahwa Bob si tukang roti memang menerima 4,000 sats sebagai pembayaran untuk baguette. Alice menggunakan 2 UTXO sebagai input: satu sebesar 10,000 sats dan satu lagi sebesar 15,000 sats. Dalam output, dia menerima 3 UTXO: satu sebesar 4,000 sats, satu sebesar 6,000 sats, dan satu lagi sebesar 11,000 sats. Alice dengan demikian memiliki saldo bersih -4,000 sats pada transaksi ini, yang sesuai persis dengan harga baguette.

Dalam contoh ini, saya sengaja mengabaikan biaya penambangan untuk memudahkan pemahaman. Dalam kenyataannya, biaya transaksi sepenuhnya ditanggung oleh pengirim.

### Apa tujuan dari transaksi Stonewall?
Struktur Stonewall menambahkan banyak entropi ke transaksi dan mengaburkan jejak analisis rantai. Dari luar, transaksi seperti itu dapat diinterpretasikan sebagai mini-coinjoin antara dua orang. Namun pada kenyataannya, ini adalah pembayaran. Metode ini dengan demikian menghasilkan ketidakpastian dalam analisis rantai, atau bahkan mengarah ke jejak palsu.
Mari kita kembali ke contoh Alice di toko roti Bob. Transaksi di blockchain akan terlihat seperti ini:

![BTC204](assets/notext/62/02.webp)

Pengamat eksternal yang mengandalkan heuristik analisis rantai umum mungkin salah menyimpulkan bahwa "*dua orang telah melakukan small coinjoin, dengan satu UTXO masing-masing di input dan dua UTXO masing-masing di output*". Analisis transaksi ini dari luar tidak mengarah pada penerapan Common Input Ownership Heuristic (CIOH), karena keberadaan dua output dengan jumlah yang sama menunjukkan pola coinjoin. Dari sudut pandang eksternal, CIOH oleh karena itu tidak berlaku dalam kasus spesifik ini.

![BTC204](assets/notext/62/03.webp)

Interpretasi ini tidak akurat, karena, seperti yang Anda tahu, satu UTXO dikirim ke Bob si tukang roti, 2 UTXO di input berasal dari Alice, dan dia mendapatkan kembali 3 output kembalian.

![BTC204](assets/notext/62/04.webp)
Dan yang sangat menarik tentang struktur transaksi Stonewall adalah bahwa dari perspektif pengamat eksternal, itu terlihat persis seperti transaksi Stonewall x2.

### Transaksi Stonewall x2

Stonewall x2 adalah bentuk spesifik lain dari transaksi Bitcoin yang juga bertujuan untuk meningkatkan privasi pengguna selama pengeluaran, tetapi kali ini dengan berkolaborasi dengan pihak ketiga yang tidak terlibat dalam pengeluaran. Metode ini bekerja seperti pseudo-coinjoin antara dua peserta, sambil melakukan pembayaran kepada orang ketiga pada saat yang sama.

Operasi transaksi Stonewall x2 relatif sederhana: seseorang menggunakan UTXO yang mereka miliki untuk melakukan pembayaran dan meminta bantuan dari pihak ketiga yang juga berkontribusi dengan UTXO yang mereka miliki. Transaksi berakhir dengan empat output: dua di antaranya dengan jumlah yang sama, satu ditujukan untuk alamat penerima pembayaran, yang lainnya ke alamat yang dimiliki oleh kolaborator. UTXO ketiga dikirim kembali ke alamat lain dari kolaborator, memungkinkan mereka untuk memulihkan jumlah awal (tindakan netral bagi mereka, minus biaya penambangan), dan UTXO terakhir kembali ke alamat yang dimiliki oleh kita, yang merupakan kembalian dari pembayaran.

Dengan demikian, tiga peran berbeda didefinisikan dalam transaksi Stonewall x2:
- Pengirim, yang melakukan pembayaran sebenarnya;
- Penerima, yang mungkin tidak menyadari sifat spesifik dari transaksi dan hanya menunggu pembayaran dari pengirim;
- Kolaborator, yang menyediakan bitcoin untuk menimbulkan keraguan dalam analisis transaksi, sambil sepenuhnya memulihkan dana mereka di akhir (tindakan netral bagi mereka, minus biaya penambangan).

Mari kita kembali ke contoh kita dengan Alice yang berada di toko roti Bob untuk membeli baguette-nya yang harganya 4.000 sats. Dia ingin membayar dengan bitcoin sambil mempertahankan tingkat privasi tertentu atas pembayarannya. Jadi, dia memanggil temannya Charles, yang akan membantunya dalam proses ini.

![BTC204](assets/notext/62/05.webp)
Menganalisis transaksi ini, kita dapat melihat bahwa Bob sang tukang roti memang telah menerima pembayaran sebesar 4.000 sats untuk baguette tersebut. Alice menggunakan 10.000 sats sebagai input dan mendapatkan kembali 6.000 sats sebagai output, menghasilkan saldo bersih -4.000 sats, yang sesuai dengan harga baguette tersebut. Sedangkan Charles, dia menyediakan 15.000 sats sebagai input dan menerima dua output: satu sebesar 4.000 sats dan yang lainnya 11.000 sats, membuat saldo menjadi 0.
Dalam contoh ini, saya sengaja mengabaikan biaya untuk memudahkan pemahaman. Pada kenyataannya, biaya penambangan umumnya dibagi rata antara penerbit pembayaran dan kolaborator.

### Apa tujuan dari transaksi Stonewall x2?
Seperti struktur Stonewall, struktur Stonewall x2 menambahkan jumlah entropi yang signifikan ke dalam transaksi dan menyamarkan jejak analisis rantai. Dari sudut pandang eksternal, transaksi seperti itu bisa diinterpretasikan sebagai coinjoin kecil antara dua orang. Namun pada kenyataannya, ini adalah pembayaran. Metode ini, oleh karena itu, menghasilkan ketidakpastian dalam analisis rantai, bahkan mengarah pada jejak palsu.

Mari kita kembali ke contoh Alice, Bob sang Tukang Roti, dan Charles. Transaksi di blockchain akan terlihat seperti ini:

![BTC204](assets/notext/62/06.webp)

Seorang pengamat eksternal yang mengandalkan heuristik analisis rantai umum mungkin salah menyimpulkan bahwa "*Alice dan Charles telah melakukan coinjoin kecil, dengan satu UTXO masing-masing di input dan dua UTXO masing-masing di output*". Sekali lagi, analisis transaksi ini dari luar tidak mengarah pada penerapan Heuristik Kepemilikan Input Bersama (CIOH), karena keberadaan dua output dengan jumlah yang sama menunjukkan pola coinjoin. Dari sudut pandang eksternal, CIOH oleh karena itu tidak berlaku dalam kasus spesifik ini.

![BTC204](assets/notext/62/07.webp)

Interpretasi ini tidak akurat karena, seperti yang Anda tahu, satu UTXO dikirim ke Bob sang Tukang Roti, Alice hanya memiliki satu output kembalian, dan Charles memiliki dua.

![BTC204](assets/notext/62/08.webp)

Dan sekali lagi, yang menarik dengan struktur transaksi Stonewall x2 adalah bahwa dari sudut pandang pengamat eksternal, itu terlihat persis seperti transaksi Stonewall.

### Apa perbedaan antara Stonewall dan Stonewall x2?

Transaksi StonewallX2 beroperasi persis seperti transaksi Stonewall, kecuali bahwa yang pertama bersifat kolaboratif, sementara yang terakhir tidak. Seperti yang telah kita lihat, transaksi Stonewall x2 melibatkan partisipasi pihak ketiga (Charles), yang eksternal terhadap pembayaran, dan yang menyediakan bitcoinnya untuk meningkatkan kerahasiaan transaksi. Dalam transaksi Stonewall klasik, peran kolaborator diambil oleh pengirim.

![BTC204](assets/notext/62/09.webp)

Dari sudut pandang eksternal, pola transaksi oleh karena itu persis sama.

![BTC204](assets/notext/62/10.webp)

Fakta bahwa kedua struktur transaksi ini berbagi pola yang persis sama menyiratkan bahwa bahkan jika pengamat eksternal berhasil mengidentifikasi pola "Stonewall(x2)", mereka tidak akan memiliki semua informasi. Mereka tidak akan dapat menentukan mana dari dua UTXO dengan jumlah yang sama yang sesuai dengan pembayaran. Selain itu, mereka tidak akan dapat menentukan apakah dua UTXO di input berasal dari dua orang yang berbeda (Stonewall x2) atau jika mereka milik satu orang yang telah menggabungkannya (Stonewall).
Poin terakhir ini disebabkan oleh fakta bahwa transaksi Stonewall x2 mengikuti pola yang sama persis dengan transaksi Stonewall. Dari luar dan tanpa informasi tambahan tentang konteksnya, mustahil untuk membedakan transaksi Stonewall dari transaksi Stonewall x2. Namun, yang pertama bukanlah transaksi kolaboratif, sementara yang terakhir adalah. Ini menambahkan lebih banyak keraguan dalam analisis salah satu transaksi ini.
### Kapan menggunakan transaksi Stonewall dan Stonewall x2?

Logikanya harus sebagai berikut ketika ingin menggunakan alat privasi untuk transaksi:
- Sebagai prioritas, seseorang dapat memilih untuk melakukan payjoin;
- Jika pedagang tidak mendukung payjoins, seseorang dapat melakukan transaksi kolaboratif dengan orang lain di luar pembayaran menggunakan struktur Stonewall x2;
- Jika tidak ada yang ditemukan untuk melakukan transaksi Stonewall x2, seseorang dapat melakukan transaksi Stonewall sendirian, yang akan meniru perilaku transaksi Stonewall x2.

### Bagaimana cara menggunakan transaksi Stonewall dan Stonewall x2?

Transaksi Stonewall dan Stonewall x2 tersedia baik di aplikasi Samourai Wallet maupun di perangkat lunak Sparrow Wallet.

![BTC204](assets/notext/62/11.webp)

Namun, sama seperti dengan payjoins, setelah penangkapan pendiri Samourai, transaksi Stonewall x2 sekarang hanya dapat dilakukan dengan menukar PSBT secara manual antara pihak-pihak yang terlibat. Pertukaran otomatis melalui Soroban sayangnya tidak tersedia saat ini.

Juga dimungkinkan untuk secara manual melakukan jenis transaksi ini dari perangkat lunak dompet Bitcoin apa pun.

Di bab selanjutnya, kita akan mempelajari teknik privasi lain yang relatif tidak dikenal, tetapi sangat berguna sebagai tambahan dari apa yang telah kita pelajari.

https://planb.network/tutorials/privacy/stonewall

https://planb.network/tutorials/privacy/stonewall-x2

## Ricochets

<chapterId>db9a20ac-a149-443d-884b-ea6c03f28499</chapterId>

Penggunaan struktur transaksi Bitcoin yang menambahkan ambiguitas dalam analisis rantai, seperti coinjoin, sangat bermanfaat untuk perlindungan privasi. Namun, seperti yang kita bahas dalam bab tentang payjoins, transaksi coinjoin secara alami dapat diidentifikasi di rantai. Ingat analogi yang kita buat antara enkripsi dan coinjoins: ketika seseorang mengenkripsi sebuah file, pihak ketiga yang menemukan file terenkripsi ini tidak dapat mengakses isinya, tetapi dapat dengan jelas mengidentifikasi bahwa telah terjadi modifikasi file untuk menyembunyikan isinya. Hal yang sama berlaku untuk coinjoin: ketika seorang analis memeriksa transaksi coinjoin, meskipun mereka tidak dapat menetapkan hubungan langsung antara input dan output (dan sebaliknya), mereka tetap dapat mengenali bahwa transaksi yang diamati adalah coinjoin.
Tergantung pada penggunaan koin Anda setelah menjalani siklus coinjoin, fakta bahwa itu telah menjalani proses ini bisa menjadi masalah. Misalnya, jika Anda berencana untuk menjual koin Anda di platform pertukaran yang diatur, tetapi baru-baru ini telah menjalani coinjoin, alat analisis rantai platform akan mendeteksi fakta ini. Platform kemudian mungkin menolak untuk menerima UTXO Anda yang telah menjalani coinjoin, atau bahkan menuntut penjelasan dari Anda, dengan risiko memiliki akun Anda ditangguhkan atau dana Anda dibekukan. Dalam beberapa kasus, platform juga dapat melaporkan perilaku Anda ke otoritas negara (misalnya, ini adalah yang diminta TRACFIN dari Penyedia Layanan Aset Digital (PSAN) di Prancis).
![BTC204](assets/notext/63/01.webp)
Apa yang kita butuhkan untuk menghindari ini adalah sebuah alat yang mampu mengaburkan jejak masa lalu sebuah koin Bitcoin, untuk mengembalikan bentuk tertentu dari fungibilitas. Ini adalah tujuan utama dari ricochet.

![BTC204](assets/notext/63/02.webp)

### Apa itu ricochet?

Ricochet adalah teknik yang melibatkan pelaksanaan beberapa transaksi fiktif kepada diri sendiri (sweeping) untuk mensimulasikan transfer kepemilikan bitcoin. Alat ini berbeda dari struktur transaksi lain yang telah kita bahas karena tidak memungkinkan anonimitas prospektif, melainkan bentuk anonimitas retrospektif. Memang, ricochet memungkinkan pengaburan spesifik yang dapat mengkompromikan fungibilitas sebuah koin Bitcoin karena masa lalunya.

Untuk mengaburkan jejak yang ditinggalkan oleh sebuah peristiwa masa lalu pada sebuah koin, seperti siklus coinjoin, misalnya, ricochet melakukan empat transaksi berturut-turut di mana pengguna mentransfer dana kepada diri mereka sendiri di alamat yang berbeda.

![BTC204](assets/en/63/03.webp)

Setelah rangkaian transaksi ini, alat ricochet akhirnya mengarahkan bitcoin ke tujuan akhirnya, seperti platform pertukaran.

![BTC204](assets/en/63/04.webp)

Tujuannya adalah untuk menciptakan jarak yang mempengaruhi fungibilitas koin, seperti transaksi coinjoin, dan tindakan akhir pengeluaran yang dapat menolak koin ini karena masa lalunya. Dengan demikian, alat analisis rantai mungkin menyimpulkan bahwa kemungkinan telah terjadi perubahan kepemilikan setelah peristiwa tersebut, dan menganggap bahwa koin ini fungibel. Dalam kasus coinjoin, alat analisis rantai mungkin kemudian mengasumsikan bahwa bukan orang yang sama yang mengirim bitcoin dan melakukan coinjoin, dan oleh karena itu tidak perlu untuk memulai tindakan terhadap pengirim.

![BTC204](assets/notext/63/05.webp)

### Mengapa ini berhasil?
Menghadapi metode ricochet ini, seseorang mungkin membayangkan bahwa perangkat lunak analisis rantai akan memperdalam pemeriksaan mereka melebihi empat lompatan. Namun, platform ini menghadapi dilema dalam mengoptimalkan ambang deteksi. Mereka harus menetapkan batas pada jumlah lompatan setelah mereka mengakui bahwa kemungkinan telah terjadi perubahan kepemilikan dan bahwa kaitan dengan peristiwa sebelumnya (seperti coinjoin) harus diabaikan.
![BTC204](assets/en/63/06.webp)

Namun, menentukan ambang ini terbukti berisiko: setiap perluasan jumlah lompatan yang diamati secara eksponensial meningkatkan volume positif palsu, yaitu, individu yang salah ditandai sebagai peserta dalam sebuah peristiwa, ketika operasi dilakukan oleh orang lain. Skenario ini menimbulkan risiko besar bagi perusahaan-perusahaan ini, karena positif palsu mengarah pada ketidakpuasan, yang dapat mendorong pelanggan yang terpengaruh menuju kompetisi. Dalam jangka panjang, ambang deteksi yang terlalu luas menyebabkan platform kehilangan lebih banyak pelanggan daripada pesaingnya, yang dapat mengancam kelangsungan hidupnya. Oleh karena itu, rumit bagi platform ini untuk meningkatkan jumlah lompatan yang diamati, dan 4 seringkali merupakan jumlah yang cukup untuk melawan analisis mereka.

Fenomena yang diamati di sini agak analog dengan teori enam derajat pemisahan.

Teori enam derajat pemisahan menyarankan bahwa setiap orang di Bumi terhubung dengan orang lain melalui rantai kenalan yang tidak melibatkan lebih dari enam perantara. Cukup melalui serangkaian enam orang, masing-masing secara pribadi mengenal yang berikutnya, untuk mencapai individu mana pun di dunia.

Untuk transaksi Bitcoin, fenomena serupa ditemukan. Dengan melacak kembali jumlah transaksi Bitcoin yang cukup, seseorang pasti akan menemui coinjoin. Metode ricochet memanfaatkan prinsip ini dengan menggunakan jumlah lompatan yang lebih tinggi dari yang dapat secara wajar diikuti oleh platform pertukaran. Jika platform memutuskan untuk mengikuti lebih banyak transaksi, maka dimungkinkan untuk hanya menambahkan lompatan tambahan untuk menghindari langkah ini.

### Kapan dan bagaimana menggunakan ricochet?
Penggunaan paling umum untuk ricochet terjadi ketika perlu untuk menyembunyikan partisipasi sebelumnya dalam coinjoin pada UTXO yang Anda miliki. Idealnya, lebih baik menghindari transfer bitcoin yang telah mengalami coinjoin ke entitas yang diatur. Namun, dalam keadaan di mana seseorang tidak memiliki pilihan lain, terutama dalam keadaan mendesak untuk melikuidasi bitcoin menjadi mata uang fiat, ricochet menawarkan solusi yang efektif.
Metode ini efektif tidak hanya untuk coinjoins tetapi juga untuk tanda lain yang dapat mengompromikan fungibilitas sebuah koin.
Ide dari metode ricochet ini awalnya berasal dari tim di Samourai Wallet, yang mengintegrasikannya ke dalam aplikasi mereka untuk mengotomatiskan proses tersebut. Layanan ini berbayar di Samourai, karena ricochet melibatkan biaya layanan sebesar 100.000 sats, ditambah dengan biaya penambangan. Dengan demikian, penggunaannya lebih direkomendasikan untuk transfer jumlah yang signifikan.

![BTC204](assets/notext/63/07.webp)

Aplikasi Samourai menawarkan dua varian ricochet:
- Ricochet yang ditingkatkan, atau "pengiriman bertahap," yang memiliki keuntungan menyebar biaya layanan Samourai lebih dari lima transaksi berturut-turut. Opsi ini juga memastikan bahwa setiap transaksi disiarkan pada waktu yang berbeda dan dicatat dalam blok yang berbeda, yang memungkinkannya meniru perilaku perubahan kepemilikan seakurat mungkin. Meskipun lebih lambat, metode ini lebih disukai bagi mereka yang tidak terburu-buru, karena memaksimalkan efisiensi ricochet dengan memperkuat resistensinya terhadap analisis rantai;

![BTC204](assets/notext/63/08.webp)

- Ricochet klasik, yang dirancang untuk menjalankan operasi dengan cepat dengan menyiarkan semua transaksi dalam jangka waktu yang singkat. Metode ini, oleh karena itu, menawarkan privasi yang lebih rendah dan resistensi yang lebih rendah terhadap analisis dibandingkan dengan metode yang ditingkatkan. Ini hanya harus digunakan untuk pengiriman yang mendesak.

![BTC204](assets/notext/63/09.webp)

Ricochet pada dasarnya melibatkan pengiriman bitcoin kepada diri sendiri. Sangat mungkin untuk melakukan ricochet secara manual pada perangkat lunak dompet apa pun, tanpa menggunakan alat khusus. Cukup transfer koin yang sama kepada diri sendiri secara berturut-turut, menggunakan alamat kosong baru setiap kali.

Pada bab berikutnya, kami menjelajahi teknik berbeda untuk transfer properti rahasia. Metode-metode ini sangat berbeda dari yang telah kami periksa sejauh ini, baik dalam hal operasi maupun hasil.

https://planb.network/tutorials/privacy/ricochet
 
## Transfer Properti Rahasia
<chapterId>a2067036-849c-4d6b-87d2-44235cfae7a1</chapterId>

Di antara teknik privasi pada Bitcoin, juga ada transfer properti rahasia. Metode ini bertujuan untuk mentransfer kepemilikan bitcoin dari satu orang ke orang lain, dan sebaliknya, tanpa transaksi ini secara eksplisit terlihat di blockchain. Mari kita pelajari bersama teknik yang tersedia serta kelebihan dan kekurangannya.

### CoinSwap

CoinSwap didasarkan pada konsep yang relatif sederhana: menggunakan kontrak pintar untuk memfasilitasi transfer kepemilikan bitcoin antara dua pengguna, tanpa perlu kepercayaan dan tanpa transfer ini secara eksplisit terlihat di blockchain.

![BTC204](assets/notext/64/01.webp)
Mari kita bayangkan contoh sederhana dengan Alice dan Bob. Alice memiliki 1 BTC yang diamankan dengan kunci privat $A$, dan Bob juga memiliki 1, diamankan dengan kunci privat $B$. Secara teoritis, mereka bisa bertukar kunci privat mereka melalui saluran komunikasi eksternal untuk melakukan transfer rahasia.
![BTC204](assets/notext/64/02.webp)
Namun, metode naif ini menimbulkan risiko tinggi dalam hal kepercayaan. Tidak ada yang mencegah Alice menyimpan salinan kunci privat $A$ setelah pertukaran dan menggunakannya nanti untuk mencuri bitcoin, begitu kunci berada dalam kepemilikan Bob.

![BTC204](assets/notext/64/03.webp)

Selain itu, tidak ada jaminan yang mencegah Alice menerima kunci privat Bob $B$ dan tidak pernah mengirimkan kunci privatnya $A$ sebagai balasan. Pertukaran ini, oleh karena itu, bergantung pada kepercayaan berlebihan antara kedua belah pihak dan terbukti tidak efisien dalam memastikan transfer kepemilikan secara rahasia dan aman.

![BTC204](assets/notext/64/04.webp)

Untuk menyelesaikan masalah ini dan memungkinkan pertukaran antar pihak yang tidak saling percaya, kita dapat menggunakan sistem kontrak pintar. Kontrak pintar adalah program yang secara otomatis dieksekusi ketika kondisi yang telah ditentukan terpenuhi, yang, dalam kasus kita, memastikan bahwa pertukaran kepemilikan terjadi secara otomatis tanpa memerlukan kepercayaan bersama.

Untuk melakukan ini, kita dapat menggunakan HTLC (*Hash Time-Locked Contracts*) atau PTLC (*Point Time-Locked Contracts*). Kedua protokol ini berfungsi serupa dengan menggunakan sistem penguncian waktu yang menjamin pertukaran selesai dengan sukses atau sepenuhnya dibatalkan, sehingga melindungi integritas dana kedua belah pihak. Perbedaan utama antara HTLC dan PTLC adalah bahwa HTLC menggunakan hash dan preimage untuk mengamankan transaksi, sementara PTLC menggunakan Tanda Tangan Adaptor.

Dalam skenario coinswap menggunakan HTLC atau PTLC antara Alice dan Bob, pertukaran terjadi secara aman: baik berhasil, dan masing-masing menerima BTC milik yang lain, atau gagal, dan masing-masing mempertahankan BTC mereka sendiri. Dengan demikian, mustahil bagi salah satu pihak untuk menipu atau mencuri BTC dari pihak lain.

> *HTLC juga merupakan mekanisme yang digunakan untuk mengamankan pembayaran lintas saluran dwiarah dari Lightning Network.*

Penggunaan Tanda Tangan Adaptor sangat menarik dalam konteks ini, karena memungkinkan untuk menghindari skrip tradisional (ini adalah mekanisme yang kadang-kadang disebut sebagai "_scriptless scripts_"). Fitur ini membantu mengurangi biaya yang terkait dengan pertukaran. Keuntungan besar lainnya dari Tanda Tangan Adaptor adalah bahwa mereka tidak memerlukan penggunaan hash umum untuk kedua belah pihak transaksi, sehingga menghindari pengungkapan tautan langsung antara mereka dalam jenis pertukaran tertentu.
### Tanda Tangan Adaptor

Tanda Tangan Adaptor adalah metode kriptografi yang mengintegrasikan tanda tangan yang valid dengan tanda tangan tambahan, yang disebut "_tanda tangan adaptor_," untuk mengungkapkan sepotong data rahasia. Mekanisme ini dirancang sedemikian rupa sehingga mengetahui 2 dari 3 elemen berikut: tanda tangan yang valid, tanda tangan adaptor, dan rahasia, memungkinkan untuk mendeduksi elemen ketiga yang hilang. Sifat menarik dari metode ini adalah, jika kita mengetahui tanda tangan adaptor pihak lawan dan titik spesifik pada kurva elips yang terkait dengan rahasia yang digunakan untuk menghitung tanda tangan adaptor ini, kita dapat menurunkan tanda tangan adaptor kita sendiri yang akan kompatibel dengan rahasia yang sama, tanpa pernah memiliki akses langsung ke rahasia itu sendiri.

Dalam coinswap, penggunaan Tanda Tangan Adaptor memungkinkan untuk pengungkapan simultan dua informasi sensitif antar peserta, sehingga menghindari kebutuhan akan kepercayaan bersama. Mari kita ambil contoh untuk mengilustrasikan proses ini dengan Alice dan Bob, yang ingin bertukar kepemilikan 1 BTC masing-masing, tetapi tidak saling percaya. Mereka menggunakan Tanda Tangan Adaptor untuk mengeliminasi kebutuhan akan kepercayaan dalam pertukaran ini. Berikut cara mereka melakukannya:
* Alice memulai pertukaran dengan membuat transaksi $m_A$ yang mengirimkan 1 BTC ke Bob. Dia menghasilkan tanda tangan $s_A$, yang memvalidasi transaksi ini, menggunakan kunci privatnya $p_A$ ($P_A = p_A \cdot G$), sebuah nonce $n_A$ ($N_A = n_A \cdot G$), dan sebuah rahasia $t$ ($T = t \cdot G$):
$$s_A = n_A + t + H(N_A + T \parallel P_A \parallel m_A) \cdot p_A$$

* Alice menghitung tanda tangan adaptor $s_A'$ dengan mengurangkan rahasia $t$ dari tanda tangan sebenarnya $s_A$:

$$s_A' = s_A - t$$

* Alice mengirimkan kepada Bob tanda tangan adaptor $s'_A$, transaksi yang belum ditandatangani $m_A$, titik yang sesuai dengan rahasia ($T$), dan titik yang sesuai dengan nonce ($N_A$). Elemen-elemen ini merupakan apa yang disebut sebagai "*adaptor*". Penting untuk dicatat bahwa, hanya dengan informasi ini, Bob tidak dapat memulihkan BTC Alice.
* Namun, Bob memiliki kemampuan untuk memverifikasi bahwa Alice tidak mencoba mencurinya. Untuk melakukan ini, dia memeriksa apakah tanda tangan adaptor Alice $s_A'$ benar-benar sesuai dengan transaksi yang diusulkan $m_A$. Jika persamaan berikut ini benar, dia kemudian dapat yakin bahwa tanda tangan adaptor Alice valid:
$$s_A' \cdot G = N_A + H(N_A + T \parallel P_A \parallel m_A) \cdot P_A$$

* Verifikasi ini memberikan Bob jaminan yang cukup untuk melanjutkan pertukaran dengan percaya diri. Dia kemudian membuat transaksi miliknya sendiri $m_B$, yang dimaksudkan untuk mengirim 1 BTC ke Alice, dan menghasilkan tanda tangan adaptornya $s_B'$, yang juga akan dikaitkan dengan rahasia yang sama $t$. Pada titik ini, hanya Alice yang mengetahui nilai dari $t$; Bob hanya mengetahui titik yang sesuai $T$ yang telah ditransmisikan kepadanya oleh Alice:

$$s_B' = n_B + H(N_B + T \parallel P_B \parallel m_B) \cdot p_B$$

* Bob mentransmisikan kepada Alice tanda tangan adaptor $s_B'$, transaksi yang belum ditandatangani $m_B$, serta titik yang sesuai dengan rahasia ($T$) dan titik yang sesuai dengan nonce ($N_B$). Alice, yang mengetahui rahasia $t$, sekarang dapat menggabungkan tanda tangan adaptor Bob $s_B'$ dengan rahasia ini untuk menghasilkan tanda tangan yang valid $s_B$ untuk transaksi $m_B$ yang akan mentransfer BTC Bob kepadanya:

$$s_B = s_B' + t$$

$$(s_B' + t) \cdot G = N_B + T + H(N_B + T \parallel P_B \parallel m_B) \cdot P_B$$

* Alice menyiarkan transaksi yang telah ditandatangani ini $m_B$ di blockchain Bitcoin untuk memulihkan BTC yang dijanjikan oleh Bob. Ketika Bob melihat transaksi ini di blockchain, dia dapat mengekstrak tanda tangan $s_B = s_B' + t$. Dengan informasi ini, Bob kemudian dapat mengisolasi rahasia terkenal $t$ yang dia butuhkan:

$$t = (s_B' + t) - s_B' = s_B - s_B'$$

* Dan memang, rahasia $t$ ini adalah satu-satunya elemen yang hilang bagi Bob untuk menghasilkan tanda tangan yang valid $s_A$ dari tanda tangan adaptor Alice $s_A'$. Tanda tangan ini memungkinkan validasi transaksi $m_A$ yang mengirim BTC dari Alice ke Bob. Bob kemudian menghitung $s_A$ dan pada gilirannya menyiarkan transaksi $m_A$ di blockchain:

$$s_A = s_A' + t$$
$$(s_A' + t) \cdot G = N_A + T + H(N_A + T \parallel P_A \parallel m_A) \cdot P_A$$
Mari kita ringkas bagaimana Tanda Tangan Adaptor bekerja dalam sebuah coinswap. Awalnya, Alice mengirimkan Bob sebuah transaksi yang belum ditandatangani bersama dengan adaptor, yang memungkinkan Bob untuk memverifikasi bahwa rahasia yang nantinya diungkapkan akan memberinya akses ke bitcoin. Sebagai balasan, Bob mengirimkan Alice transaksi yang belum ditandatangani dan adaptor miliknya. Alice kemudian dapat menyelesaikan transaksi Bob dan memulihkan bitcoin dengan menyiarkan transaksi yang valid menggunakan rahasia tersebut. Ketika transaksi ini dipublikasikan di blockchain, Bob memiliki kemampuan untuk mengekstrak rahasia dan dengan demikian membuka transaksi Alice. Akibatnya, jika Alice memulai transfer bitcoin Bob, dia, pada gilirannya, dapat mengakses bitcoin Alice tanpa memerlukan kepercayaan bersama.
Penting untuk dicatat bahwa coinswaps pertama kali diusulkan oleh [Gregory Maxwell pada Oktober 2013 di BitcoinTalk](https://bitcointalk.org/index.php?topic=321228.0).

### Pertukaran Atomik

Mirip dengan coinswap dan menggunakan jenis kontrak pintar yang sama, juga dimungkinkan untuk melakukan pertukaran atomik. Pertukaran atomik memungkinkan pertukaran langsung berbagai cryptocurrency, seperti BTC dan XMR, antara dua pengguna tanpa memerlukan kepercayaan atau intervensi dari perantara. Pertukaran ini disebut "atomik" karena hanya memiliki dua hasil yang mungkin: baik pertukaran berhasil dan kedua belah pihak puas, atau gagal dan masing-masing mempertahankan cryptocurrency asli mereka, sehingga menghilangkan kebutuhan akan kepercayaan pada pihak lain.

![BTC204](assets/notext/64/05.webp)

Pertukaran atomik dan coinswap memiliki metode operasi yang serupa dan menawarkan keuntungan dan kerugian yang sama dalam hal privasi. Memang, dari perspektif Bitcoin, pertukaran atomik dapat dibandingkan dengan coinswap yang dilakukan dalam dua langkah. Pertama, kita menukar BTC kita dengan cryptocurrency lain, dan kemudian cryptocurrency ini dapat ditukar dengan BTC lain. Pada akhirnya, kita memulihkan BTC pengguna lain. Inilah sebabnya, dalam analisis masalah privasi, saya mengelompokkan kedua protokol ini di bawah kategori pertukaran rahasia kepemilikan.

![BTC204](assets/notext/64/06.webp)

Namun, tidak seperti coinswap, pertukaran atomik dapat memiliki ketidakseimbangan dalam hal likuiditas yang tersedia, terutama dalam pertukaran BTC/XMR. Umumnya lebih mudah untuk menukar bitcoin dengan altcoin, karena ada permintaan tinggi untuk bitcoin, yang menjaga premi rendah untuk arah konversi ini. Namun, menukar altcoin untuk mendapatkan BTC bisa lebih kompleks karena permintaan yang lebih rendah, seringkali menghasilkan premi yang sangat tinggi.

Akhirnya, ketika pertukaran atomik melibatkan bitcoin onchain dan bitcoin di jaringan Lightning, kita kemudian menyebutnya sebagai "*submarine swap*".

### Apakah Ini Benar-benar Berguna?
Transfer properti rahasia, seperti coinswaps dan pertukaran atomik, memiliki keuntungan dalam menipu heuristik analisis rantai. Metode ini dapat memberikan kesan bahwa transaksi melibatkan pengguna yang sama, meskipun kepemilikan sebenarnya telah berganti tangan. Namun, kelemahan utama dari metode ini adalah bahwa mereka sangat berisiko tanpa penggunaan teknik tambahan untuk memutus sejarah koin.

Memang, ketika Alice melakukan coinswap atau pertukaran atomik dengan Bob, dia menukar kepemilikan bitcoinnya dengan bitcoin Bob. Dalam kasus pertukaran atomik, pertukaran termasuk altcoin, tetapi prinsipnya tetap sama. Dengan demikian, Alice berakhir dengan koin $B$ dan Bob dengan koin $A$. Ini menambah keraguan dalam analisis rantai, tetapi sejarah koin tetap dapat dilacak. Jika seorang analis memeriksa koin $A$, mereka dapat melacak kembali ke aktivitas sebelumnya Alice, dan sebaliknya untuk koin $B$.
![BTC204](assets/en/64/07.webp)
Dari perspektif Alice, risikonya adalah sejarah koin $B$ bisa dianggap mencurigakan oleh beberapa entitas. Jika, misalnya, Bob mendapatkan koin $B$ dalam sebuah tindakan kriminal seperti peretasan, koin ini akan tetap terkait dengan aktivitas ilegalnya. Alice kemudian bisa menemukan dirinya dalam kepemilikan sebuah koin yang tidak bisa dia transfer di platform pertukaran yang diatur tanpa risiko memiliki dana beku, atau bahkan dituduh melakukan kejahatan Bob, meskipun dia tidak ada hubungannya dengan mereka.

![BTC204](assets/en/64/08.webp)

Dan tentu saja, metode privasi seperti coinswap atau atomic swap disukai oleh kriminal yang dana mereka dipantau oleh otoritas. Protokol ini menawarkan mereka kesempatan untuk membuang bitcoin mereka yang dipantau dengan imbalan bitcoin yang sepenuhnya fungibel. Ini juga memungkinkan mereka untuk menciptakan pengalihan, mengarahkan otoritas ke pengguna lain. Jadi, ada dua manfaat bagi individu ini.

Dengan coinjoin, bahkan jika koin Anda dicampur dengan bitcoin yang dipantau, sejarah koin tersebut diputus, yang memberikan bentuk penyangkalan yang masuk akal yang tidak ada dalam protokol transfer kepemilikan rahasia seperti coinswap atau atomic swap.

![BTC204](assets/notext/64/09.webp)
Jika Alice ingin menghindari risiko apa pun, dia harus menggunakan metode untuk memutus sejarah koin $B$, seperti menjalankannya melalui coinjoins, misalnya. Ini menimbulkan pertanyaan tentang utilitas menggabungkan transfer kepemilikan rahasia dan coinjoin. Coinjoin, dengan memutus sejarah sebuah koin, sudah memberikan tingkat privasi yang cukup untuk Alice. Jadi, menurut saya, jika Alice ingin melindungi privasinya, akan lebih bijaksana untuk langsung melanjutkan dengan coinjoin daripada terlibat dalam coinswap diikuti oleh coinjoin.
Untuk metode transfer kepemilikan rahasia benar-benar efektif dan menghindari risiko menghubungkan sejarah pengguna $A$ ke pengguna $B$, paradoksnya, penggunaannya harus dikenal luas. Jika coinswap digunakan secara massal dan otoritas menyadari praktik umum ini, maka bentuk penyangkalan yang masuk akal bisa didirikan. Namun, selama penggunaan transfer ini tetap marginal, saya percaya metode ini akan tetap terlalu berisiko bagi pengguna.

Sejauh ini, kita terutama telah mempelajari metode privasi pada tingkat transaksi itu sendiri. Dalam bab berikutnya, kita akan menjelajahi isu pada tingkat jaringan dan penyebaran transaksi.

## Privasi pada Jaringan P2P
<chapterId>04a2467b-db84-4076-a9ff-919be5135106</chapterId>

Dalam bagian 4, kita membahas pentingnya menggunakan node penuh untuk melindungi privasi transaksi Anda. Namun, penting untuk memahami bahwa node Anda sendiri bisa menjadi sasaran serangan yang berusaha mengekstrak informasi tentang aktivitas Anda. Dalam bab ini, kita akan memeriksa berbagai langkah perlindungan privasi, tidak pada tingkat transaksi itu sendiri atau aliran bitcoin, tetapi pada tingkat jaringan.

### Dandelion

Salah satu cara untuk menghindari berbagai serangan de-anonimisasi adalah menggunakan usulan Dandelion. Protokol siaran ini diformalkan dalam BIP156, tetapi belum pernah diimplementasikan pada Bitcoin.

Ide Dandelion adalah untuk meningkatkan privasi routing transaksi dalam jaringan Bitcoin untuk melawan berbagai bentuk serangan. Tujuan utamanya adalah untuk menyembunyikan node sumber yang awalnya menyiarkan transaksi di jaringan. Pengungkapan node ini bisa menghubungkan transaksi Bitcoin ke alamat IP tertentu (jika node beroperasi di clearnet), yang bisa memberikan titik masuk untuk analisis rantai.
Asosiasi antara aktivitas pada Bitcoin dan alamat IP menimbulkan risiko signifikan terhadap privasi pengguna. Memang, banyak entitas dapat dengan mudah menghubungkan alamat IP dengan identitas pribadi. Ini termasuk pemerintah dan penyedia layanan internet. Lebih lanjut, informasi ini bisa menjadi akses publik, misalnya, jika alamat IP dan data pribadi Anda terpapar karena kebocoran saat peretasan basis data situs web. Dalam operasi standar Bitcoin, transaksi yang dibuat oleh pengguna pada perangkat lunak dompet mereka ditransmisikan ke node pribadi mereka. Node ini segera menyiarkan transaksi baru ke semua peer yang terhubung dengannya.

![BTC204](assets/notext/65/01.webp)

Peer tersebut kemudian memverifikasi transaksi untuk memastikan kepatuhan terhadap aturan konsensus dan aturan standarisasi lokal. Setelah divalidasi, setiap peer secara bergantian menyiarkan transaksi ke peer-nya sendiri, dan seterusnya.

![BTC204](assets/notext/65/02.webp)

Distribusi transaksi yang menunggu integrasi ke dalam blok dilakukan secara cukup seimbang dan dapat diprediksi secara statistik. Kerentanan ini dapat dimanfaatkan oleh node mata-mata yang berkolusi, yang berkolaborasi untuk memantau dan menganalisis jaringan, guna mengidentifikasi node pertama yang menyiarkan transaksi. Jika pengamat berhasil menemukan node sumber, mereka dapat berasumsi bahwa transaksi berasal dari operator node tersebut. Jenis pengamatan ini dapat menghubungkan transaksi, yang biasanya anonim, ke alamat IP tertentu.

![BTC204](assets/notext/65/03.webp)

Tujuan dari BIP156 adalah untuk mengatasi masalah ini. Untuk melakukan ini, ia memperkenalkan fase tambahan dalam penyiaran transaksi baru untuk melestarikan anonimitas sebelum propagasi publik yang luas. Dandelion pertama menggunakan fase "batang" di mana transaksi dikirim melalui jalur acak dari node.

![BTC204](assets/notext/65/04.webp)

Transaksi kemudian disiarkan ke seluruh jaringan dalam fase "bulu".

![BTC204](assets/notext/65/05.webp)

Batang dan bulu adalah referensi ke perilaku propagasi transaksi melalui jaringan, menyerupai bentuk dandelion.

Dengan demikian, node mata-mata berpotensi melacak transaksi kembali ke node yang memulai fase bulu (siaran besar-besaran), tetapi node ini bukanlah yang pertama menyiarkan transaksi, karena menerimanya dari node terakhir di batang. Jika node mata-mata tidak dapat melacak kembali ke atas batang, mereka juga tidak dapat mengidentifikasi node sumber.

![BTC204](assets/notext/65/06.webp)
Bahkan dalam kehadiran node mata-mata selama fase batang, keraguan selalu ada karena segera setelah mereka menemui node jujur dalam grafik difusi, mata-mata tidak dapat menentukan apakah node ini adalah sumber asli atau hanya perantara.
![BTC204](assets/notext/65/07.webp)

Metode perutean ini mengaburkan jejak menuju node sumber, membuatnya sulit untuk melacak transaksi melalui jaringan kembali ke asalnya. Dandelion dengan demikian meningkatkan privasi dengan membatasi kemampuan musuh untuk deanonymize jaringan. Metode ini menjadi lebih efektif ketika transaksi melintasi selama fase "batang" sebuah node yang mengenkripsi komunikasi jaringannya, seperti dengan Tor atau P2P Transport V2.
BIP156 belum terintegrasi ke dalam Bitcoin Core dan saat ini diklasifikasikan dengan status "ditolak". Salah satu kekhawatiran utama mengenai protokol ini terletak pada fakta bahwa, selama fase batang, transaksi harus diteruskan oleh node perantara sebelum diverifikasi. Seperti yang kita lihat, dalam model normal Bitcoin, setiap node pertama-tama memverifikasi transaksi sebelum menyiarkannya ke peer-nya. Jika sebuah transaksi tidak mematuhi aturan konsensus atau aturan standarisasi lokal dari node tersebut, maka node tersebut mengabaikannya dan tidak menyiarkannya. Proses ini penting untuk melawan serangan DoS, karena hanya transaksi yang valid yang disiarkan ke seluruh jaringan. Transaksi yang tidak valid, yang mungkin dihasilkan secara massal untuk membebani jaringan, dihentikan pada node pertama yang ditemui dan tidak tersebar. Risiko utama dengan Dandelion adalah bahwa protokol baru ini dapat memperkenalkan vektor baru untuk serangan DoS dengan memungkinkan penyebaran transaksi yang tidak valid melalui bagian dari jaringan.

### P2P Transport V2

P2P Transport V2 adalah protokol jaringan lain yang dipresentasikan dalam BIP324. Ini adalah versi baru dari protokol transportasi P2P Bitcoin yang menggabungkan enkripsi oportunis untuk meningkatkan kerahasiaan dan keamanan komunikasi antar node.

Perbaikan ini bertujuan untuk menyelesaikan beberapa masalah dengan versi dasar dari protokol P2P. Di satu sisi, ini membuat data yang ditukar tidak dapat dibedakan dari jenis data lain yang beredar di Internet oleh pengamat pasif. Tujuan utamanya adalah untuk mencegah pemerintah, penyedia layanan internet, atau penyedia VPN dari memantau pengguna Bitcoin secara massal. Ini juga mempersulit tugas bagi entitas-entitas tersebut untuk menentukan apakah seorang pengguna internet juga merupakan pengguna Bitcoin, yaitu, jika mereka mengoperasikan node penuh.
P2P V2 juga berkontribusi dalam mengurangi risiko sensor dan serangan melalui deteksi pola spesifik dalam paket data. Ini mempersulit dan membuat pelaksanaan berbagai jenis serangan Sybil lebih mahal di tingkat jaringan. Serangan Sybil terjadi ketika seorang aktor menciptakan banyak identitas palsu untuk mendapatkan keuntungan yang tidak semestinya. Dalam konteks jaringan Bitcoin, ini seringkali terwujud sebagai aktor yang mengontrol sejumlah besar node penuh dan menggunakannya secara agresif untuk menggandakan koneksi. Serangan Sybil bisa pasif, bertujuan untuk mengumpulkan informasi dan mengkompromikan kerahasiaan pengguna, atau aktif, dalam bentuk serangan Eclipse. Yang terakhir mengisolasi node tertentu dari sisa jaringan, memungkinkan untuk mensensor pengguna atau mengubah data yang mereka terima. Akhirnya, P2P V2 juga membuat serangan *Man-In-The-Middle* (MITM) lebih mahal dan lebih mudah untuk dideteksi.
Enkripsi yang diterapkan oleh P2P V2 tidak termasuk autentikasi agar tidak menambah kompleksitas yang tidak perlu, dan untuk tidak mengkompromikan sifat bebas izin dari koneksi jaringan. Protokol transportasi P2P baru ini tetap menawarkan keamanan yang lebih baik terhadap serangan pasif dan membuat serangan aktif secara signifikan lebih mahal dan terdeteksi. Pengenalan aliran data pseudo-acak dalam pesan jaringan mempersulit tugas bagi penyerang yang ingin mensensor atau memanipulasi komunikasi.

Transportasi P2P V2 dimasukkan sebagai opsi (dinonaktifkan secara default) dalam versi 26.0 dari Bitcoin Core, yang dikerahkan pada Desember 2023. Kemudian diaktifkan secara default dalam versi 27.0 pada April 2024. Ini dapat dimodifikasi dengan opsi `v2transport=` dalam file konfigurasi.

### Tor

Solusi yang relatif sederhana lainnya untuk menghindari risiko kehilangan kerahasiaan bagi sebuah node di tingkat jaringan adalah dengan menjalankannya sepenuhnya di bawah Tor.
Tor adalah jaringan server relay (node) yang menyamarkan asal usul koneksi TCP di internet. Cara kerjanya adalah dengan mengenkapsulasi data dalam beberapa lapis enkripsi. Setiap node relay menghilangkan satu lapis untuk mengungkapkan alamat node berikutnya, sampai mencapai tujuan akhir. Jaringan Tor memastikan anonimitas dengan mencegah node-node perantara mengetahui baik asal maupun tujuan data, membuatnya sangat sulit bagi pengamat untuk melacak aktivitas pengguna.
![BTC204](assets/notext/65/08.webp)
Oleh karena itu, Tor tidak hanya mengenkripsi data yang dikomunikasikan tetapi juga memungkinkan penyamaran asal dan tujuan komunikasi. Dengan menggunakan Tor untuk komunikasi node pribadi kita, kita meningkatkan privasi transaksi kita: Penyedia Layanan Internet (ISP) tidak dapat mendekripsi komunikasi, dan node lain dalam jaringan Bitcoin tidak dapat mengidentifikasi alamat IP dari node sumber. Lebih lanjut, Tor juga menyembunyikan penggunaan Bitcoin Anda dari ISP.

Risiko utama yang terkait dengan metode ini adalah bahwa Tor adalah protokol yang independen dari Bitcoin. Jika Anda memiliki node Bitcoin di bawah Tor dan Tor berhenti bekerja, maka node Bitcoin Anda tidak akan lagi dapat berkomunikasi.

Juga, penting untuk dicatat bahwa komunikasi melalui Tor lebih lambat. Latensi ini terutama mengganggu selama peluncuran awal node, karena Initial Block Download (IBD) memerlukan banyak komunikasi. Akibatnya, sinkronisasi awal Anda dengan jaringan Bitcoin bisa jauh lebih lama menggunakan Tor. Juga dimungkinkan untuk melakukan IBD di clearnet, kemudian mengaktifkan Tor nanti. Meskipun metode ini mengungkapkan keberadaan node Bitcoin Anda kepada ISP Anda, itu melindungi informasi yang terkait dengan transaksi pribadi Anda setelah Anda beralih ke Tor.

Setelah menjelajahi metode privasi tingkat jaringan yang berbeda, saya juga ingin memperkenalkan dalam bab-bab mendatang dua solusi elegan untuk menghindari penggunaan alamat ulang: BIP47 dan Pembayaran Diam.

## BIP47 dan Kode Pembayaran yang Dapat Digunakan Kembali
<chapterId>ad88e076-a04b-4aec-b3b2-7b4760175504</chapterId>

Seperti yang kita lihat di bagian 3, penggunaan alamat ulang menimbulkan hambatan serius terhadap privasi pengguna pada protokol Bitcoin. Untuk mengurangi risiko ini, sangat disarankan untuk menghasilkan alamat penerimaan baru untuk setiap pembayaran baru yang diterima di dompet. Meskipun menghasilkan alamat baru saat ini disederhanakan oleh penggunaan perangkat lunak modern dan dompet deterministik hierarkis, praktik ini mungkin terasa tidak intuitif.

![BTC204](assets/notext/66/1.webp)

Misalnya, dalam sistem perbankan tradisional, kita terbiasa berbagi IBAN kita, yang selalu tetap sama. Setelah dikomunikasikan kepada seseorang, mereka dapat mengirimkan kita beberapa pembayaran tanpa harus berinteraksi dengan kita lagi. Neo-bank juga menawarkan kemungkinan modern seperti penggunaan alamat email unik di PayPal atau RevTags di Revolut. Bahkan di luar domain keuangan, pengenal sehari-hari kita seperti alamat pos, nomor telepon, dan alamat email juga unik dan permanen. Kita tidak perlu memperbaruinya dengan setiap interaksi baru.

![BTC204](assets/notext/66/2.webp)
Namun, operasi Bitcoin berbeda: sangat penting untuk menghasilkan alamat penerimaan baru untuk setiap transaksi masuk. Kompromi antara kemudahan penggunaan dan privasi ini berasal dari asal usul White Paper Bitcoin itu sendiri. Dari publikasi versi pertama dokumennya pada akhir 2008, Satoshi Nakamoto sudah memperingatkan kita tentang risiko ini:
**"*Sebagai firewall tambahan, sepasang kunci baru bisa digunakan untuk setiap transaksi untuk menjaga mereka tidak terhubung ke pemilik yang sama.*"**
Ada berbagai metode untuk menerima banyak pembayaran ke satu pengenal tanpa menyebabkan penggunaan ulang alamat. Masing-masing memiliki kompromi dan kekurangannya sendiri. Di antara metode-metode ini adalah BIP47, sebuah usulan yang dikembangkan oleh Justus Ranvier dan dipublikasikan pada tahun 2015. Usulan ini bertujuan untuk menciptakan kode pembayaran yang dapat digunakan kembali yang memungkinkan untuk transaksi multipel kepada orang yang sama sambil menghindari penggunaan ulang alamat. Pada intinya, BIP47 berusaha menawarkan sistem pembayaran yang seintuitif pengenal unik, sambil menjaga privasi transaksi.
![BTC204](assets/notext/66/3.webp)

BIP47 tidak secara langsung meningkatkan privasi pengguna, karena pembayaran BIP47 menawarkan tingkat privasi yang sama dengan transaksi Bitcoin klasik menggunakan alamat baru. Namun, ini membuat penggunaan Bitcoin menjadi lebih nyaman dan intuitif, sebuah kemudahan yang, biasanya, harus mengorbankan privasi. Berkat BIP47, kemudahan penggunaan ini mencapai tingkat privasi yang sama dengan transaksi klasik. Inilah mengapa BIP47 adalah alat yang berharga untuk pelestarian privasi.

Awalnya, BIP47 adalah usulan yang dirumuskan untuk diintegrasikan ke dalam Bitcoin Core, tetapi tidak pernah diadopsi. Beberapa perangkat lunak masih memilih untuk mengimplementasikannya sendiri di tingkat aplikasi. Dengan demikian, tim di Samourai Wallet telah mengembangkan implementasi mereka sendiri dari BIP47 yang dinamakan "PayNym".

### Prinsip Umum BIP47 dan PayNym

Tujuan dari BIP47 adalah untuk memungkinkan penerimaan banyak pembayaran tanpa menyebabkan penggunaan ulang alamat. Ini bergantung pada penggunaan kode pembayaran yang dapat digunakan kembali, yang memungkinkan pengirim yang berbeda untuk mengirim banyak pembayaran ke satu kode yang dimiliki pengguna lain. Dengan demikian, penerima tidak perlu menyediakan alamat baru yang segar untuk setiap transaksi, yang sangat memudahkan pertukaran mereka sambil menjaga privasi mereka.

![BTC204](assets/en/66/4.webp)

Seorang pengguna dapat dengan bebas membagikan kode pembayaran mereka, baik di jejaring sosial maupun di situs web mereka, tanpa risiko kehilangan privasi, tidak seperti yang akan terjadi dengan alamat penerima klasik atau kunci publik.
Untuk melakukan transaksi, kedua belah pihak harus memiliki dompet Bitcoin dengan implementasi BIP47, seperti PayNym di Samourai Wallet atau Sparrow Wallet. Penggunaan bersama kode pembayaran mereka menciptakan saluran rahasia antara mereka. Untuk membangun saluran ini secara efisien, pengirim harus melakukan transaksi spesifik di blockchain Bitcoin, yang dikenal sebagai "transaksi notifikasi" (saya akan memberi Anda lebih banyak detail tentang ini nanti).

Kombinasi kode pembayaran kedua pengguna menghasilkan rahasia bersama, yang pada gilirannya memungkinkan untuk penciptaan sejumlah besar alamat penerima Bitcoin unik (tepatnya 2^32, atau sekitar 4 miliar). Jadi, pembayaran yang dilakukan melalui BIP47 sebenarnya tidak ditujukan kepada kode pembayaran itu sendiri, tetapi kepada alamat penerima klasik yang berasal dari kode pembayaran pengguna yang terlibat.

Kode pembayaran dengan demikian berfungsi sebagai pengenal virtual yang berasal dari benih dompet. Dalam struktur derivasi hierarkis dompet, kode pembayaran ditempatkan pada level 3, yaitu, pada level akun.

![BTC204](assets/en/66/5.webp)

Tujuan derivasi untuk BIP47 diidentifikasi oleh indeks `47'` (`0x8000002F`), merujuk pada BIP47. Sebuah contoh dari jalur derivasi untuk kode pembayaran yang dapat digunakan kembali adalah sebagai berikut:
```plaintext
m/47'/0'/0'/
```

Untuk memberi Anda gambaran tentang bagaimana kode pembayaran terlihat, berikut adalah milik saya:
```plaintext
Kode ini juga dapat dikodekan dalam kode QR, untuk memfasilitasi komunikasinya, sama seperti alamat penerima klasik.

Mengenai PayNym Bots, robot-robot ini yang terkadang terlihat di Twitter, adalah representasi visual dari kode pembayaran, yang dibuat oleh Samourai Wallet. Mereka dihasilkan melalui fungsi hashing, yang memberikan mereka keunikan hampir sempurna. Mereka muncul dalam bentuk string karakter kecil yang dimulai dengan `+`:
```plaintext
+throbbingpond8B1
+twilightresonance487
+billowingfire340
```

Avatar-avatarnya juga dapat direpresentasikan dalam bentuk gambar:

![BTC204](assets/notext/66/6.webp)

Meskipun robot-robot ini tidak memiliki fungsi teknis spesifik dalam kerangka BIP47, mereka memainkan peran dalam memfasilitasi interaksi antar pengguna dengan menawarkan identitas visual yang mudah dikenali.
Dalam bagian-bagian berikut dari bab ini yang didedikasikan untuk BIP47, kita akan memeriksa secara detail cara kerjanya, dengan penekanan khusus pada metode kriptografi yang digunakan. Untuk sepenuhnya memahami penjelasan teknis ini, sangat penting untuk terlebih dahulu memahami struktur dompet HD, proses derivasi kunci, dan prinsip-prinsip dasar kriptografi berbasis kurva eliptik. Jika Anda ingin mendalami konsep-konsep ini, kursus gratis lainnya tersedia di PlanB Network: [CRYPTO 301](https://planb.network/en/courses/crypto301). Saya masih menyarankan Anda untuk mengikutinya, karena memahami cara kerja teknis BIP47 akan memudahkan Anda untuk memahami proposal serupa lainnya yang akan kita bahas di bab-bab berikutnya.
### Kode Pembayaran yang Dapat Digunakan Kembali

Seperti yang disebutkan sebelumnya, kode pembayaran yang dapat digunakan kembali terletak pada kedalaman 3 dari dompet HD, membuatnya sebanding dengan `xpub`, baik dalam posisinya dalam struktur dompet maupun dalam perannya.

Kode pembayaran 80-byte terbagi sebagai berikut:
- **Byte `0`: Versi**. Untuk versi pertama dari BIP47, byte ini diatur ke `0x01`;
- **Byte `1`: Bidang bit**. Ruang ini diperuntukkan untuk mengintegrasikan indikasi tambahan selama penggunaan spesifik. Untuk penggunaan standar dengan PayNym, byte ini didefinisikan sebagai `0x00`;
- **Byte `2`: Paritas `y`**. Byte ini adalah `0x02` atau `0x03`, menunjukkan apakah ordinat kunci publik genap atau ganjil, karena kunci publik yang dikompresi digunakan;
- **Dari byte `3` hingga byte `34`: Nilai `x`**. Byte ini mewakili absis dari kunci publik. Penggabungan `x` dan paritas `y` membentuk kunci publik yang dikompresi secara lengkap;
- **Dari byte `35` hingga byte `66`: Kode rantai**. Ruang ini berisi kode rantai yang terkait dengan kunci publik;
- **Dari byte `67` hingga byte `79`: Padding**. Ruang ini dimaksudkan untuk pengembangan masa depan yang mungkin. Untuk versi saat ini, nol sederhana ditempatkan di sini untuk mencapai ukuran 80-byte yang diperlukan untuk output `OP_RETURN`.

Berikut adalah representasi heksadesimal dari kode pembayaran yang dapat digunakan kembali saya yang sudah disajikan di bagian sebelumnya:
```plaintext
Pertama, juga diperlukan untuk menambahkan byte awalan `P` di awal untuk menunjukkan secara jelas bahwa ini adalah kode pembayaran. Byte ini diwakili oleh `0x47`:
```plaintext
0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000
```

Akhirnya, untuk memastikan integritas kode pembayaran, perhitungan checksum dilakukan menggunakan `HASH256`, yang terdiri dari penghashan ganda dengan fungsi `SHA256`. Empat byte pertama yang dihasilkan dari hash ini kemudian digabungkan ke akhir kode pembayaran:
```plaintext
0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000567080c4
```

Setelah langkah-langkah ini selesai, kode pembayaran siap. Satu-satunya hal yang tersisa adalah mengonversinya menjadi base 58 untuk mendapatkan versi akhirnya:
```plaintext
PM8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5
```

Selama proses pembuatan kode pembayaran ini, kami menggunakan kunci publik terkompresi dan kode rantai. Keduanya diturunkan dari derivasi deterministik dan hierarkis dari benih dompet. Jalur derivasi yang digunakan untuk mencapai ini adalah:
```plaintext
m/47'/0'/0'/
```
Untuk menghasilkan kunci publik terkompresi dan kode rantai yang terkait untuk kode pembayaran yang dapat digunakan kembali, kami mulai dengan menghitung kunci privat utama dari benih dompet. Kemudian kami melanjutkan untuk menurunkan sepasang kunci anak menggunakan indeks `47 + 2^31` (derivasi diperkuat). Langkah ini diikuti oleh dua derivasi berturut-turut dari pasangan anak, masing-masing menggunakan indeks `2^31` (derivasi diperkuat).

### Pertukaran Kunci Elliptic-Curve Diffie-Hellman (ECDH)
Protokol kriptografi yang menjadi inti dari BIP47 disebut dengan akronim ECDH, untuk *Elliptic-Curve Diffie-Hellman*. Metode ini merupakan varian dari pertukaran kunci Diffie-Hellman asli.
Diperkenalkan pada tahun 1976, Diffie-Hellman adalah protokol kesepakatan kunci yang memungkinkan dua pihak, masing-masing dilengkapi dengan sepasang kunci (publik dan privat), untuk menyepakati sebuah rahasia bersama, bahkan saat berkomunikasi hanya melalui saluran publik dan tidak aman.

![BTC204](assets/en/66/10.webp)

Rahasia bersama ini (di sini, kunci biru), kemudian dapat digunakan untuk operasi lain. Biasanya, rahasia bersama ini dapat digunakan untuk mengenkripsi dan mendekripsi komunikasi melalui jaringan yang tidak aman:

![BTC204](assets/notext/66/11.webp)

Untuk mencapai pertukaran ini, Diffie-Hellman menggunakan aritmetika modular untuk menghitung rahasia bersama. Berikut adalah penjelasan sederhana tentang cara kerjanya:
- Alice dan Bob sepakat pada warna umum, di sini kuning, yang merupakan data publik (penyerang mengetahui warna ini);
- Alice memilih warna rahasia, di sini merah, dan mencampurkan kedua warna untuk mendapatkan oranye;
- Bob juga memilih warna rahasia, di sini biru, dan mencampurnya dengan kuning untuk mendapatkan hijau;
- Kemudian mereka bertukar warna yang diperoleh, oranye dan hijau. Pertukaran ini dapat terjadi melalui jaringan yang tidak aman dan diamati;
- Dengan mencampur hijau Bob dengan warna rahasia miliknya, Alice menghasilkan coklat;
- Bob, melakukan hal yang sama dengan oranye Alice dan biru rahasianya, juga mendapatkan coklat.

![BTC204](assets/en/66/12.webp)

Dalam penyederhanaan ini, warna coklat mewakili rahasia bersama antara Alice dan Bob. Penting untuk dipahami bahwa, dalam kenyataannya, mustahil bagi penyerang untuk memisahkan warna oranye dan hijau untuk menemukan warna rahasia Alice atau Bob.

Sekarang, mari kita periksa bagaimana protokol ini sebenarnya bekerja, tidak dengan analogi warna, tetapi menggunakan angka nyata dan aritmetika modular!
Sebelum membahas mekanisme Diffie-Hellman, izinkan saya untuk mengingatkan Anda secara singkat tentang dua konsep matematika penting yang akan kita perlukan:

- Sebuah **bilangan prima** adalah bilangan alami yang hanya memiliki dua pembagi: $1$ dan dirinya sendiri. Misalnya, $7$ adalah bilangan prima karena hanya dapat dibagi oleh $1$ dan $7$. Di sisi lain, $8$ bukan bilangan prima karena dapat dibagi oleh $1$, $2$, $4$, dan $8$. Oleh karena itu, memiliki empat pembagi bilangan bulat positif alih-alih dua;
- **Modulo** (ditandai $mod$ atau $\%$) adalah operasi matematika yang, antara dua bilangan bulat, mengembalikan sisa dari pembagian Euklides dari yang pertama oleh yang kedua. Misalnya, $16 \bmod 5 = 1$.

**Pertukaran kunci Diffie-Hellman antara Alice dan Bob berlangsung sebagai berikut:**

- Alice dan Bob sepakat pada dua angka umum: $p$ dan $g$. $p$ adalah bilangan prima, dan semakin besar angka ini, semakin aman Diffie-Hellman akan. $g$ adalah akar primitif dari $p$. Kedua angka ini dapat dikomunikasikan secara terbuka melalui jaringan yang tidak aman. Mereka mewakili setara dengan **warna kuning** dalam penyederhanaan sebelumnya. Oleh karena itu, penting bahwa Alice dan Bob menggunakan nilai yang sama persis untuk $p$ dan $g$.
- Setelah parameter-parameter ini ditentukan, Alice dan Bob masing-masing memilih sebuah angka rahasia acak. Alice menamai angka rahasianya $a$ (setara dengan **warna merah**) dan Bob menamai angkanya $b$ (setara dengan **warna biru**). Angka-angka ini harus tetap sangat rahasia.
- Alih-alih langsung bertukar angka $a$ dan $b$, masing-masing pihak menghitung $A$ dan $B$ sebagai berikut:

$A$ sama dengan $g$ dipangkatkan dengan $a$ modulo $p$:

$$
A = g^a \bmod p
$$

$B$ sama dengan $g$ dipangkatkan dengan $b$ modulo $p$:

$$
B = g^b \bmod p
$$

- Nilai $A$ (setara dengan **warna oranye**) dan $B$ (setara dengan **warna hijau**) ditukarkan antara kedua pihak. Pertukaran ini dapat berlangsung secara terbuka melalui jaringan yang tidak aman;

- Alice, setelah menerima $B$, menghitung nilai $z$ sebagai berikut:

$z$ sama dengan $B$ dipangkatkan dengan $a$ modulo $p$:

$$
z = B^a \bmod p
$$

Untuk mengingat:

$$
B = g^b \bmod p
$$

Dengan demikian, kita peroleh:

$$
z = B^a \bmod p
$$

$$
z = (g^b)^a \bmod p
$$

Dengan menerapkan aturan eksponen:
$$
(x^n)^m = x^{nm}
$$

Kita kemudian peroleh:

$$
z = g^{ba} \bmod p
$$

- Di sisinya, Bob, setelah menerima $A$, juga menghitung nilai $z$ dengan cara berikut:

$z$ sama dengan $A$ dipangkatkan dengan $b$ modulo $p$:

$$
z = A^b \bmod p
$$

Dengan demikian, kita peroleh:

$$
z = (g^a)^b \bmod p
$$

$$
z = g^{ab} \bmod p
$$

$$
z = g^{ba} \bmod p
$$

Berkat sifat distributif operator modulo, Alice dan Bob memperoleh nilai $z$ yang sama persis. Angka ini mewakili rahasia bersama mereka, setara dengan **warna coklat** dalam penyederhanaan sebelumnya dengan pot cat. Mereka sekarang dapat menggunakan rahasia bersama ini untuk mengenkripsi komunikasi mereka secara simetris melalui jaringan yang tidak aman.

![BTC204](assets/notext/66/13.webp)

Seorang penyerang, meskipun memiliki $p$, $g$, $A$, dan $B$ (nilai-nilai publik), tidak akan dapat menghitung $a$, $b$, atau $z$ (nilai-nilai pribadi). Untuk mencapai ini, seseorang harus membalikkan eksponensiasi, sebuah operasi yang mustahil tanpa mencoba semua kemungkinan satu per satu, karena ini berarti menghitung logaritma diskrit, yaitu, kebalikan dari eksponensial dalam grup siklik terbatas.

Dengan demikian, selama nilai-nilai $a$, $b$, dan $p$ cukup besar, protokol Diffie-Hellman aman. Biasanya, dengan parameter 2048-bit (sebuah angka dengan 600 digit dalam desimal), menguji semua kemungkinan untuk $a$ dan $b$ akan tidak praktis. Sampai hari ini, dengan angka-angka tersebut, algoritma ini dianggap aman.
Ini adalah tepatnya di mana kelemahan utama dari protokol Diffie-Hellman berada. Untuk menjadi aman, algoritma harus menggunakan angka-angka besar. Itulah sebabnya, saat ini, algoritma ECDH (*Elliptic Curve Diffie-Hellman*), sebuah varian dari Diffie-Hellman yang mengandalkan kurva aljabar, lebih tepatnya sebuah kurva elips, lebih disukai. Pendekatan ini memungkinkan bekerja dengan angka-angka yang jauh lebih kecil sambil mempertahankan keamanan yang setara, sehingga mengurangi sumber daya yang diperlukan untuk perhitungan dan penyimpanan.

Prinsip umum dari algoritma tetap sama. Namun, alih-alih menggunakan angka acak $a$ dan angka $A$ yang dihitung dari $a$ melalui eksponensiasi modular, kita menggunakan sepasang kunci yang didirikan pada kurva elips. Alih-alih mengandalkan distributivitas dari operator modulo, kita menggunakan hukum grup pada kurva elips, dan lebih spesifik lagi asosiativitas dari hukum ini.

Untuk menjelaskan secara singkat prinsip kriptografi kurva elips, kunci privat diwakili oleh angka acak antara $1$ dan $n-1$, di mana $n$ mewakili urutan dari kurva. Kunci publik, di sisi lain, adalah titik spesifik pada kurva ini, diperoleh dari kunci privat melalui operasi penambahan titik dan penggandaan yang dimulai dari titik generator, sesuai dengan persamaan:
$$
K = k \cdot G
$$

Dalam rumus ini, $K$ menandakan kunci publik, $k$ kunci privat, dan $G$ titik generator.

Salah satu karakteristik esensial dari kunci-kunci ini adalah kemudahan menghitung $K$ dari $k$ dan $G$, sementara hampir mustahil untuk menemukan $k$ dari $K$ dan $G$. Asimetri ini menciptakan fungsi satu arah. Dengan kata lain, mudah untuk menghitung kunci publik jika seseorang mengetahui kunci privat, tetapi menemukan kunci privat dari kunci publik adalah mustahil. Keamanan ini masih didasarkan pada kesulitan komputasi dari logaritma diskrit.

Kita akan menggunakan properti ini untuk menyesuaikan algoritma Diffie-Hellman kita. **Prinsip operasi ECDH adalah sebagai berikut:**

- Alice dan Bob sepakat bersama pada kurva elips yang aman secara kriptografi dan parameternya. Informasi ini bersifat publik;

- Alice menghasilkan angka acak $ka$ yang akan menjadi kunci privatnya. Kunci privat ini harus tetap rahasia. Dia menentukan kunci publiknya $Ka$ dengan penambahan dan penggandaan titik pada kurva elips yang dipilih:

$$
K_a = k_a \cdot G
$$

- Bob juga menghasilkan angka acak $kb$ yang akan menjadi kunci privatnya. Dia menghitung kunci publik yang terkait $Kb$:

$$
K_b = k_b \cdot G
$$

- Alice dan Bob bertukar kunci publik mereka $Ka$ dan $Kb$ melalui jaringan publik yang tidak aman.

- Alice menghitung titik $(x,y)$ pada kurva dengan menerapkan kunci privatnya $ka$ ke kunci publik Bob $Kb$:

$$
(x,y) = k_a \cdot K_b
$$

- Bob menghitung titik $(x,y)$ pada kurva dengan menerapkan kunci privatnya $kb$ ke kunci publik Alice $Ka$:

$$
(x,y) = k_b \cdot K_a
$$

- Alice dan Bob mendapatkan titik yang sama pada kurva elips. Rahasia bersama akan menjadi koordinat x $x$ dari titik ini.

Mereka memang mendapatkan rahasia bersama yang sama karena:
(x,y) = k_a \cdot K_b = k_a \cdot (k_b \cdot G) = (k_a \cdot k_b) \cdot G = (k_b \cdot k_a) \cdot G = k_b \cdot (k_a \cdot G) = k_b \cdot K_a$$
Seorang penyerang yang mengamati jaringan publik yang tidak diamankan hanya dapat memperoleh kunci publik dari masing-masing pihak dan parameter dari kurva eliptik yang dipilih. Seperti yang telah dijelaskan sebelumnya, informasi ini saja tidak cukup untuk menentukan kunci privat. Oleh karena itu, penyerang tidak dapat menemukan rahasia bersama antara Alice dan Bob.

ECDH adalah algoritma yang memungkinkan pertukaran kunci. Seringkali digunakan bersama dengan metode kriptografi lain untuk menetapkan protokol yang lengkap. Sebagai contoh, ECDH diintegrasikan ke dalam inti dari TLS (*Transport Layer Security*), sebuah protokol enkripsi dan autentikasi yang digunakan untuk lapisan transport internet. TLS menggunakan ECDHE untuk pertukaran kunci, varian dari ECDH di mana kunci-kuncinya bersifat efemeral, untuk menyediakan kerahasiaan yang persisten. Selain itu, TLS menggunakan algoritma autentikasi seperti ECDSA, algoritma enkripsi seperti AES, dan fungsi hash seperti SHA256.

TLS secara khusus bertanggung jawab atas `s` dalam `https` serta gembok yang terlihat di bilah alamat browser Anda, simbol dari komunikasi yang dienkripsi. Dengan mengikuti kursus ini, Anda oleh karena itu menggunakan ECDH, dan sangat mungkin Anda menggunakannya setiap hari tanpa menyadarinya.

### Transaksi Notifikasi

Seperti yang kita lihat di bagian sebelumnya, ECDH adalah varian dari pertukaran Diffie-Hellman yang menggunakan pasangan kunci yang didirikan pada kurva eliptik. Secara nyaman, kita sudah memiliki banyak pasangan kunci yang mematuhi standar ini di dompet Bitcoin kita! Ide dari BIP47 adalah menggunakan pasangan kunci dari dompet hierarkis deterministik Bitcoin kedua pihak untuk menetapkan rahasia bersama dan efemeral antara mereka. Dalam konteks BIP47, ECDHE (*Elliptic Curve Diffie-Hellman Ephemeral*) digunakan sebagai gantinya.

![BTC204](assets/notext/66/14.webp)

ECDHE digunakan untuk pertama kalinya dalam BIP47 untuk mentransmisikan kode pembayaran dari pengirim ke penerima. Ini adalah **transaksi notifikasi** yang terkenal. Langkah ini penting karena agar BIP47 dapat bekerja dengan efisien, kedua pihak yang terlibat (pengirim dan penerima) harus mengetahui kode pembayaran masing-masing. Pengetahuan ini memungkinkan untuk derivasi kunci publik efemeral dan, akibatnya, alamat penerimaan kosong yang terkait.
Sebelum pertukaran ini, pengirim secara logis sudah mengetahui kode pembayaran penerima karena mereka telah mengambilnya secara off-chain, misalnya, dari situs web mereka, faktur, atau media sosial mereka. Namun, penerima mungkin belum tentu mengetahui kode pembayaran pengirim. Namun, kode ini harus ditransmisikan kepada mereka; jika tidak, mereka tidak akan dapat menurunkan kunci efemeral yang diperlukan untuk mengidentifikasi alamat tempat bitcoin mereka disimpan, atau mengakses dana mereka. Meskipun transmisi kode pengirim secara teknis dapat dilakukan secara off-chain melalui sarana komunikasi lain, ini menimbulkan masalah jika dompet perlu dipulihkan dari benih saja.
Memang, tidak seperti alamat konvensional, alamat BIP47 tidak diturunkan langsung dari seed penerima—menggunakan `xpub` akan lebih sederhana dalam kasus ini—tetapi hasil dari perhitungan yang menggabungkan kedua kode pembayaran: yang dari pengirim dan yang dari penerima. Jadi, jika penerima kehilangan dompet mereka dan mencoba untuk memulihkannya dari seed mereka, mereka akan memulihkan kode pembayaran mereka sendiri, yang secara langsung diturunkan dari seed mereka. Namun, untuk menemukan alamat efemeral, akan sangat penting bagi mereka untuk juga memiliki kode pembayaran dari semua orang yang telah mengirimkan bitcoin kepada mereka melalui BIP47. Oleh karena itu pentingnya transaksi notifikasi, yang memungkinkan menyimpan informasi ini di blockchain Bitcoin, sambil dapat menemukannya dengan sangat mudah tanpa harus mencari melalui miliaran transaksi yang dilakukan sejak peluncurannya pada tahun 2009.
![BTC204](assets/en/66/15.webp)

Oleh karena itu, akan mungkin untuk mengimplementasikan BIP47 tanpa harus menggunakan transaksi notifikasi, asalkan setiap pengguna menyimpan cadangan dari kode pembayaran rekan mereka. Namun, metode ini terbukti rumit untuk dikelola selama solusi yang sederhana, kuat, dan efisien untuk membuat, menyimpan, dan memperbarui cadangan ini belum dikembangkan. Dalam keadaan saat ini, transaksi notifikasi menjadi hampir tidak tergantikan.

Dalam bab-bab berikutnya, kita akan mempelajari protokol lain dengan tujuan serupa dengan BIP47, tetapi yang tidak memerlukan transaksi notifikasi. Alternatif ini, bagaimanapun, memperkenalkan kompromi mereka sendiri.

Selain perannya dalam mencadangkan kode pembayaran, transaksi notifikasi juga berfungsi sebagai fungsi notifikasi untuk penerima, seperti namanya. Ini memberi sinyal kepada klien penerima bahwa saluran pembayaran baru telah dibuat, dan dengan demikian menyarankan untuk memantau alamat efemeral yang dihasilkan.

### Model Privasi dari BIP47

Sebelum menjelaskan operasi teknis dari transaksi notifikasi, penting untuk membahas model privasi yang terkait dengan BIP47, yang membenarkan beberapa langkah yang diambil selama pembuatan transaksi awal ini.
Kode pembayaran, dengan sendirinya, tidak menimbulkan risiko langsung terhadap privasi. Tidak seperti model Bitcoin tradisional, yang bertujuan untuk memutuskan hubungan antara identitas pengguna dan transaksi mereka (yang bersifat publik) dengan mempertahankan anonimitas kunci dan alamat, kode pembayaran dapat secara terbuka dikaitkan dengan identitas tanpa menimbulkan ancaman.
Memang, kode pembayaran tidak digunakan untuk langsung menurunkan alamat yang menerima pembayaran BIP47. Alamat ini sebaliknya dihasilkan melalui aplikasi ECDH antara kunci yang diturunkan dari kode pembayaran kedua pihak yang terlibat.

Dengan demikian, kode pembayaran dengan sendirinya tidak langsung menyebabkan kehilangan privasi karena hanya alamat notifikasi yang diturunkan darinya. Meskipun alamat ini dapat mengungkapkan beberapa informasi, biasanya tidak memungkinkan penemuan pihak dengan siapa Anda melakukan transaksi, kecuali melalui analisis rantai yang menyeluruh. Memang, jika pengirim menggunakan UTXO yang dapat dikaitkan dengan identitas mereka untuk melakukan transaksi notifikasi, maka menjadi mungkin untuk menyimpulkan bahwa identitas mereka mungkin terkait dengan pembayaran BIP47 ke kode pembayaran Anda. Ini tidak akan mengungkapkan transaksi yang mendasarinya tetapi akan menunjukkan kemungkinan keberadaannya.

Oleh karena itu, sangat penting untuk mempertahankan pemisahan ketat antara kode pembayaran pengguna. Menuju tujuan ini, langkah komunikasi awal dari kode adalah momen kritis untuk privasi pembayaran, namun wajib untuk fungsi protokol yang tepat. Jika salah satu kode pembayaran dapat diperoleh secara publik (seperti di situs web), kode kedua, yaitu pengirim, tidak boleh dikaitkan dengan yang pertama dalam kasus apa pun.

Mari kita ambil contoh konkret: Saya ingin membuat donasi ke gerakan politik melalui BIP47:
- Organisasi telah membuat kode pembayaran mereka publik di situs web mereka atau melalui jejaring sosial mereka;
- Kode ini dengan demikian terkait dengan gerakan politik;
- Saya mengambil kode pembayaran ini;
- Sebelum melanjutkan dengan pengiriman, saya harus memastikan bahwa mereka mengetahui kode pembayaran saya sendiri, yang juga terkait dengan identitas saya karena saya menggunakannya untuk menerima transaksi di jejaring sosial saya.

Bagaimana cara mengirimkan kode saya tanpa risiko? Penggunaan sarana komunikasi konvensional dapat menyebabkan kebocoran informasi, dan akibatnya, mengaitkan saya dengan gerakan politik ini. Transaksi notifikasi menawarkan solusi berkat lapisan enkripsi yang tepatnya mencegah asosiasi antara dua kode ini. Meskipun ini bukan satu-satunya metode untuk mentransmisikan kode pembayaran pengirim secara rahasia, ini terbukti sangat efektif.

Pada diagram di bawah ini, garis oranye menunjukkan titik-titik di mana aliran informasi harus dihentikan, dan panah hitam menunjukkan koneksi yang berpotensi dapat diamati oleh pihak ketiga:
![BTC204](assets/en/66/16.webp)
Dalam kenyataannya, dalam model privasi tradisional Bitcoin, seringkali kompleks untuk sepenuhnya memisahkan aliran informasi antara pasangan kunci dan pengguna, terutama selama transaksi jarak jauh. Misalnya, dalam konteks kampanye donasi, penerima harus tak terhindarkan mengungkapkan alamat atau kunci publik melalui situs web atau jejaring sosial mereka. Penggunaan BIP47 yang benar, khususnya dengan transaksi notifikasi, memungkinkan untuk mengatasi masalah ini berkat ECDHE dan lapisan enkripsi yang akan kita pelajari lebih lanjut.

Tentu saja, model privasi klasik Bitcoin masih berlaku untuk kunci publik efemeral, yang berasal dari kombinasi dua kode pembayaran. Kedua model tersebut sebenarnya saling melengkapi. Yang ingin saya soroti di sini adalah bahwa, berbeda dengan penggunaan umum kunci publik untuk menerima bitcoin, kode pembayaran dapat dikaitkan dengan identitas tertentu, karena informasi "_Alice melakukan transaksi dengan Bob_" diputus pada tahap lain. Kode pembayaran digunakan untuk menghasilkan alamat pembayaran, tetapi hanya berdasarkan pengamatan blockchain, mustahil untuk mengaitkan transaksi pembayaran BIP47 dengan kode pembayaran yang digunakan untuk melaksanakannya, kecuali UTXO yang terlibat sudah terkait dengan identitas sebelumnya dan pengguna telah mengaitkan kode pembayaran mereka dengan identitas masing-masing.

Untuk merangkum, model privasi yang ditawarkan oleh pembayaran BIP47 dapat dianggap lebih unggul dari dasar Bitcoin, meskipun ini sama sekali tidak ajaib.

### Konstruksi Transaksi Notifikasi

Sekarang, mari kita lihat bagaimana transaksi notifikasi ini bekerja. Bayangkan Alice ingin mengirim dana ke Bob dengan BIP47. Dalam contoh saya, Alice bertindak sebagai pengirim dan Bob sebagai penerima. Yang terakhir telah mempublikasikan kode pembayarannya di situs webnya. Oleh karena itu, Alice sudah mengetahui kode pembayaran Bob.

**1- Alice menghitung rahasia bersama dengan ECDH:**

- Dia memilih pasangan kunci dari dompet HD-nya yang terletak pada cabang yang berbeda dari kode pembayarannya. Catatan, pasangan ini tidak boleh mudah dikaitkan dengan alamat notifikasi Alice, atau dengan identitas Alice (lihat bagian sebelumnya);

- Alice memilih kunci privat dari pasangan ini. Kita namakan $a$ (huruf kecil);

$$
a
$$
- Alice mengambil kunci publik yang terkait dengan alamat notifikasi Bob. Kunci ini adalah anak perempuan pertama yang berasal dari kode pembayaran Bob (indeks $/0$). Kita namakan kunci publik ini $B$ (huruf besar). Kunci privat yang terkait dengan kunci publik ini dinamakan $b$ (huruf kecil). $B$ ditentukan oleh penambahan dan penggandaan titik pada kurva elips dari $G$ (titik generator) dengan $b$ (kunci privat):
$$ B = b \cdot G $$
- Alice menghitung titik rahasia $S$ (huruf besar) pada kurva eliptik dengan penambahan dan penggandaan titik dengan menerapkan kunci privatnya $a$ dari kunci publik Bob $B$.
$$ S = a \cdot B $$

- Alice menghitung faktor penyamaran $f$ yang akan memungkinkannya untuk mengenkripsi kode pembayarannya. Untuk melakukan ini, dia akan menentukan sebuah nomor pseudo-acak dengan fungsi HMAC-SHA512. Pada input kedua dari fungsi ini, dia menggunakan nilai yang hanya bisa diambil oleh Bob: $x$ yang merupakan absis dari titik rahasia yang telah dihitung sebelumnya. Input pertama adalah $o$ yang merupakan UTXO yang dikonsumsi dalam input transaksi ini (outpoint).

$$ f = \text{HMAC-SHA512}(o, x) $$

**2- Alice mengonversi kode pembayaran pribadinya menjadi basis 2 (biner).**

**3- Dia menggunakan faktor penyamaran ini sebagai kunci untuk melakukan enkripsi simetris pada payload dari kode pembayarannya.** Algoritma enkripsi yang digunakan adalah `XOR`. Operasi yang dilakukan dapat dibandingkan dengan cipher Vernam, juga dikenal sebagai "One-Time Pad".

- Alice pertama membagi faktor penyamarannya menjadi dua: 32 byte pertama dinamakan $f1$ dan 32 byte terakhir dinamakan $f2$. Dengan demikian, kita memiliki:

$$ f = f1 || f2 $$

- Alice menghitung $x'$ yang terenkripsi dari absis kunci publik $x$ dari kode pembayarannya, dan $c'$ yang terenkripsi dari kode rantainya $c$ secara terpisah. $f1$ dan $f2$ bertindak masing-masing sebagai kunci enkripsi. Operasi yang digunakan adalah `XOR` (exclusive or).

$$ x' = x \oplus f1 $$
$$ c' = c \oplus f2 $$

- Alice menggantikan nilai nyata dari absis kunci publik $x$ dan kode rantai $c$ dalam kode pembayarannya dengan nilai yang terenkripsi $x'$ dan $c'$.
**4-** Alice saat ini memiliki kode pembayarannya dengan payload yang terenkripsi. Dia akan membangun dan menyiarkan transaksi yang melibatkan kunci publiknya $A$ sebagai input, sebuah output ke alamat notifikasi Bob, dan output `OP_RETURN` yang berisi kode pembayarannya dengan payload yang terenkripsi. **Transaksi ini adalah transaksi notifikasi**.
Sebuah `OP_RETURN` adalah opcode yang menandai output transaksi Bitcoin sebagai tidak valid. Saat ini, itu digunakan untuk menyiarkan atau mengankor informasi di blockchain Bitcoin. Hingga 80 byte data dapat disimpan, yang ditulis di rantai dan dengan demikian terlihat oleh semua pengguna lain.

Seperti yang telah kita lihat di bagian sebelumnya, ECDH digunakan untuk menghasilkan rahasia bersama antara dua pengguna yang berkomunikasi melalui jaringan yang tidak aman, yang mungkin diamati oleh penyerang. Dalam BIP47, ECDH dimanfaatkan untuk komunikasi melalui jaringan Bitcoin, yang secara alamiah adalah jaringan komunikasi transparan yang diamati oleh banyak penyerang. Rahasia bersama yang dihitung melalui pertukaran kunci ECDH kemudian digunakan untuk mengenkripsi informasi rahasia yang akan ditransmisikan: kode pembayaran pengirim (Alice).

Mari kita rekap langkah-langkah yang baru saja kita tinjau bersama untuk melakukan transaksi notifikasi:
- Alice mengambil kode pembayaran dan alamat notifikasi Bob;
- Alice memilih UTXO yang dia miliki di dompet HD-nya dengan pasangan kunci yang sesuai;
- Dia menghitung titik rahasia pada kurva eliptik menggunakan ECDH;
- Dia menggunakan titik rahasia ini untuk menghitung HMAC, yang merupakan faktor penyamaran;
- Dia menggunakan faktor penyamaran ini untuk mengenkripsi payload dari kode pembayaran pribadinya;
- Dia menggunakan output transaksi `OP_RETURN` untuk mengkomunikasikan kode pembayaran yang disamarkan kepada Bob.
![BTC204](assets/en/66/17.webp)

### Transaksi Notifikasi: Studi Konkret

Untuk memahami fungsinya lebih detail, terutama penggunaan `OP_RETURN`, mari kita periksa sebuah transaksi notifikasi secara nyata bersama-sama. Saya melakukan transaksi seperti itu di testnet, yang bisa Anda temukan [dengan mengklik di sini](https://mempool.space/fr/testnet/tx/0e2e4695a3c49272ef631426a9fd2dae6ec3a469e3a39a3db51aa476cd09de2e).

![BTC204](assets/notext/66/18.webp)

Mengamati transaksi ini, kita dapat melihat bahwa ia memiliki satu input dan 4 output:
- Output pertama adalah `OP_RETURN` yang berisi kode pembayaran saya yang disamarkan;
- Output kedua sebesar 546 sats mengarah ke alamat notifikasi penerima saya;
- Output ketiga sebesar 15.000 sats mewakili biaya layanan, karena saya menggunakan Samourai Wallet untuk membangun transaksi ini;
- Output keempat sebesar 2 juta sats mewakili kembalian, yang berarti perbedaan yang tersisa dari input saya yang kembali ke alamat lain milik saya.
Yang paling menarik untuk dipelajari adalah tentu saja output 0 yang menggunakan `OP_RETURN`. Mari kita lihat lebih dekat apa yang terkandung di dalamnya. Berikut ini adalah `scriptPubKey` dalam heksadesimal:

```text
6a4c50010002b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d800000000000000000000000000
```

Dalam skrip ini, kita dapat membedah beberapa bagian. Pertama-tama, opcode:

```text
6a4c
```

Di antara opcode, kita dapat mengenali `0x6a` yang menunjukkan `OP_RETURN` dan `0x4c` yang menunjukkan `OP_PUSHDATA1`.

Byte berikutnya setelah opcode terakhir ini menunjukkan ukuran payload yang mengikuti. Ini menunjukkan `0x50`, atau 80 byte:

```text
6a4c50
```

Kemudian, kita memiliki metadata dari kode pembayaran saya dalam teks biasa:

```text
010002
```

Koordinat x terenkripsi dari kunci publik kode pembayaran saya:

```text
b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164
```

Kode rantai terenkripsi dari kode pembayaran saya:

```text
927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d8
```

Dan akhirnya, padding untuk mencapai 80 byte, ukuran standar dari sebuah `OP_RETURN`:

```text
00000000000000000000000000
```

Untuk memahami lebih baik, berikut ini adalah kode pembayaran saya dalam teks biasa dalam base 58:

```text
Saat membandingkan kode pembayaran teks biasa saya dengan `OP_RETURN`, terlihat bahwa HRP (`0x47`) dan checksum (`0x8604e4db`) tidak ditransmisikan. Hal ini diharapkan, karena informasi-informasi tersebut ditujukan untuk manusia. Selanjutnya, kita dapat mengidentifikasi versi (`0x01`), bidang bit (`0x00`), dan paritas kunci publik (`0x02`). Dan, di akhir kode pembayaran, byte kosong (`0x00000000000000000000000000`) digunakan untuk mengisi kode hingga total 80 byte. Semua metadata ini ditransmisikan dalam teks biasa (tidak terenkripsi).

Akhirnya, dapat diamati bahwa koordinat x kunci publik (`0x77507c9c17a89cfca2d3af554745d6c2db0e7f6b2721a3941a504933103cc42a`) dan kode rantai (`0xdd94881210d6e752a9abc8a9fa0070e85184993c4f643f1121dd807dd556d1dc`) telah dienkripsi. Ini merupakan muatan dari kode pembayaran.

### Apa itu XOR?

Dalam bagian sebelumnya, kita melihat bahwa kode pembayaran ditransmisikan terenkripsi menggunakan operasi XOR. Mari kita luangkan waktu untuk memahami bagaimana operator ini bekerja, karena secara luas digunakan dalam kriptografi.

XOR adalah operator logika bitwise berdasarkan aljabar Boolean. Dengan dua operan bit, ia mengembalikan `1` jika bit dari peringkat yang sama berbeda, dan mengembalikan `0` jika bit dari peringkat yang sama sama. Berikut adalah tabel kebenaran dari XOR berdasarkan nilai operan `D` dan `E`:

| D   | E   | D XOR E |
| --- | --- | ------- |
| 0   | 0   | 0       |
| 0   | 1   | 1       |
| 1   | 0   | 1       |
| 1   | 1   | 0       |

Sebagai contoh:

$$
0110 \oplus 1110 = 1000
$$

Atau:

$$
010011 \oplus 110110 = 100101
$$

Dengan ECDH, menggunakan XOR sebagai lapisan enkripsi sangat cocok. Pertama, karena operator ini, enkripsinya simetris. Ini memungkinkan penerima untuk mendekripsi kode pembayaran dengan kunci yang sama yang digunakan untuk enkripsi. Kunci enkripsi dan dekripsi dihitung dari rahasia bersama berkat ECDH. Simetri ini diaktifkan oleh sifat komutatif dan asosiatif dari operator XOR:

- Sifat lainnya:

$$
D \oplus D = 0
$$
D ⊕ 0 = D
- Komutativitas:

$$
D \oplus E = E \oplus D
$$

- Asosiativitas:

$$
D \oplus (E \oplus Z) = (D \oplus E) \oplus Z = D \oplus E \oplus Z
$$

Jika:

$$
D \oplus E = L
$$

Maka:

$$
D \oplus L = D \oplus (D \oplus E) = D \oplus D \oplus E = 0 \oplus E = E \\
\therefore D \oplus L = E
$$

Selanjutnya, metode enkripsi ini sangat mirip dengan sandi Vernam (One-Time Pad), satu-satunya algoritma enkripsi yang diketahui hingga saat ini memiliki keamanan mutlak (atau absolut). Agar sandi Vernam memiliki karakteristik ini, kunci enkripsi harus benar-benar acak, harus berukuran sama dengan pesan, dan hanya digunakan sekali. Dalam metode enkripsi yang digunakan di sini untuk BIP47, kunci memang berukuran sama dengan pesan, faktor penyamaran persis berukuran sama dengan penggabungan koordinat x kunci publik dengan kode rantai kode pembayaran. Kunci enkripsi ini memang hanya digunakan sekali. Namun, kunci ini bukan hasil dari keacakan sempurna karena merupakan HMAC. Ini lebih bersifat pseudo-acak. Oleh karena itu, ini bukan sandi Vernam, tetapi metodenya serupa.

### Menerima Transaksi Notifikasi

Sekarang Alice telah mengirim transaksi notifikasi kepada Bob, mari kita lihat bagaimana dia menafsirkannya. Sebagai pengingat, Bob harus dapat mengakses kode pembayaran Alice. Tanpa informasi ini, seperti yang akan kita lihat di bagian berikutnya, dia tidak akan dapat menurunkan pasangan kunci yang dibuat oleh Alice, dan oleh karena itu, dia tidak akan dapat mengakses bitcoinnya yang diterima melalui BIP47. Untuk saat ini, muatan kode pembayaran Alice dienkripsi. Mari kita lihat bagaimana Bob mendekripsinya.

**1-** Bob memantau transaksi yang menciptakan output dengan alamat notifikasinya.

**2-** Ketika sebuah transaksi memiliki output pada alamat notifikasinya, Bob menganalisisnya untuk melihat apakah itu mengandung output OP_RETURN yang mengikuti standar BIP47.

**3-** Jika byte pertama dari muatan OP_RETURN adalah `0x01`, Bob mulai mencari rahasia bersama yang mungkin dengan ECDH:
- Bob memilih kunci publik dalam input transaksi. Yaitu, kunci publik Alice yang dinamakan $A$ dengan:

$$ A = a \cdot G $$

- Bob memilih kunci privat $b$ yang terkait dengan alamat notifikasi pribadinya:

$$ b $$
- Bob menghitung titik rahasia $S$ (rahasia bersama ECDH) pada kurva elips dengan menambahkan dan menggandakan titik, menerapkan kunci privat $b$ ke kunci publik Alice $A$:
$$ S = b \cdot A $$

- Bob menentukan faktor penyamaran $f$ yang akan memungkinkannya untuk mendekripsi muatan kode pembayaran Alice. Dengan cara yang sama seperti Alice sebelumnya menghitung, Bob akan menemukan $f$ dengan menerapkan HMAC-SHA512 pada $x$ koordinat x dari titik rahasia $S$, dan pada $o$ UTXO yang dikonsumsi sebagai input dalam transaksi notifikasi ini:

$$ f = \text{HMAC-SHA512}(o, x) $$

**4-** Bob menafsirkan data dalam OP_RETURN dari transaksi notifikasi sebagai kode pembayaran. Dia akan sekedar mendekripsi muatan kode pembayaran potensial ini menggunakan faktor penyamaran $f$:
- Bob membagi faktor pengaburan $f$ menjadi 2 bagian: 32 byte pertama dari $f$ akan menjadi $f1$ dan 32 byte terakhir akan menjadi $f2$;
- Bob mendekripsi koordinat x terenkripsi $x'$ dari kode pembayaran publik Alice:

$$ x = x' \oplus f1 $$

- Bob mendekripsi nilai kode rantai terenkripsi $c'$ dari kode pembayaran Alice:

$$ c = c' \oplus f2 $$

**5-** Bob memeriksa apakah nilai kunci publik dari kode pembayaran Alice memang merupakan bagian dari grup secp256k1. Jika ini kasusnya, dia menginterpretasikannya sebagai kode pembayaran yang valid. Jika tidak, dia mengabaikan transaksi ini.

Sekarang Bob mengetahui kode pembayaran Alice, dia dapat mengiriminya hingga `2^32` pembayaran, tanpa perlu melakukan transaksi pemberitahuan jenis ini lagi.

Mengapa ini bisa bekerja? Bagaimana Bob bisa menentukan faktor pengaburan yang sama seperti Alice, dan dengan demikian mendekripsi kode pembayarannya? Mari kita lihat lebih dekat peran ECDH dalam apa yang baru saja kita jelaskan.

Pertama-tama, kita berurusan dengan enkripsi simetris. Ini berarti bahwa kunci enkripsi dan kunci dekripsi adalah nilai yang sama. Kunci dalam transaksi pemberitahuan ini adalah faktor pengaburan:

$$ f = f1 || f2 $$

Oleh karena itu, Alice dan Bob harus mendapatkan nilai yang sama untuk $f$, tanpa secara langsung mengirimkannya karena penyerang bisa mencurinya dan mendekripsi informasi rahasia. Faktor pengaburan ini diperoleh dengan menerapkan HMAC-SHA512 pada 2 nilai:
- koordinat x dari titik rahasia;
- dan UTXO yang digunakan sebagai input dalam transaksi.
Bob, oleh karena itu, memerlukan dua informasi ini untuk mendekripsi muatan kode pembayaran Alice. Untuk UTXO sebagai input, Bob dapat dengan mudah mengambilnya dengan mengamati transaksi pemberitahuan. Untuk titik rahasia, Bob harus menggunakan ECDH. Seperti yang terlihat di bagian sebelumnya tentang Diffie-Hellman, hanya dengan bertukar kunci publik masing-masing dan secara rahasia menerapkan kunci privat mereka ke kunci publik orang lain, Alice dan Bob dapat menemukan titik spesifik dan rahasia pada kurva elips. Transaksi pemberitahuan bergantung pada mekanisme ini:
- Pasangan kunci Bob:

$$ B = b \cdot G $$

- Pasangan kunci Alice:

$$ A = a \cdot G $$

- Untuk titik rahasia $S (x, y)$:

$$ S = a \cdot B = a \cdot (b \cdot G) = (b \cdot a) \cdot G = b \cdot A $$

![BTC204](assets/en/66/19.webp)

Sekarang Bob mengetahui kode pembayaran Alice, dia akan dapat mendeteksi pembayaran BIP47-nya, dan dia dapat menurunkan kunci privat yang mengunci bitcoin yang diterimanya.

Mari kita rekap langkah-langkah yang baru saja kita lalui untuk menerima dan menginterpretasikan transaksi pemberitahuan:
- Bob memantau output transaksi ke alamat pemberitahuannya;
- Ketika dia mendeteksi satu, dia mengambil informasi yang terkandung dalam OP_RETURN;
- Bob memilih kunci publik dalam input dan menghitung titik rahasia menggunakan ECDH;
- Dia menggunakan titik rahasia ini untuk menghitung HMAC yang merupakan faktor pengaburan;
- Dia menggunakan faktor pengaburan ini untuk mendekripsi muatan kode pembayaran Alice yang terkandung dalam OP_RETURN.

![BTC204](assets/en/66/20.webp)

### Transaksi Pembayaran BIP47

Mari kita sekarang pelajari proses pembayaran dengan BIP47 bersama-sama. Untuk mengingatkan Anda tentang keadaan saat ini:
- Alice mengetahui kode pembayaran Bob, yang dia ambil dengan mudah dari situs webnya;
- Bob mengetahui kode pembayaran Alice berkat transaksi notifikasi;
- Alice akan melakukan pembayaran pertama kepada Bob. Dia akan dapat melakukan banyak pembayaran lain dengan cara yang sama.

Sebelum menjelaskan proses ini, saya pikir penting untuk mengingat kembali indeks yang saat ini kami kerjakan. Jalur derivasi dari sebuah kode pembayaran dijelaskan sebagai berikut: `m/47'/0'/0'`. Kedalaman berikutnya mendistribusikan indeks dengan cara ini:
- Pasangan anak normal (non-hardened) pertama adalah yang digunakan untuk menghasilkan alamat notifikasi yang kami bahas di bagian sebelumnya: `m/47'/0'/0'/0`;
- Pasangan kunci anak normal digunakan dalam ECDH untuk menghasilkan alamat penerima pembayaran BIP47 seperti yang akan kita lihat di bagian ini: dari `m/47'/0'/0'/0` hingga `m/47'/0'/0'/2 147 483 647`;
- Pasangan kunci anak yang hardened adalah kode pembayaran sementara: dari `m/47'/0'/0'/0'` hingga `m/47'/0'/0'/2 147 483 647'`.

Kapan pun Alice ingin mengirim pembayaran kepada Bob, dia menghasilkan alamat virgin unik baru, berkat lagi kepada protokol ECDH:
- Alice memilih kunci privat pertama yang berasal dari kode pembayaran pribadi yang dapat digunakan kembali:

$$ a $$

- Alice memilih kunci publik yang belum digunakan pertama yang berasal dari kode pembayaran Bob. Kunci publik ini, kita akan menyebutnya $B$. Ini dikaitkan dengan kunci privat $b$ yang hanya diketahui oleh Bob:

$$ B = b \cdot G $$

- Alice menghitung titik rahasia $S$ pada kurva elips dengan penambahan titik dan penggandaan dengan menerapkan kunci privatnya $a$ ke kunci publik Bob $B$:

$$ S = a \cdot B $$

- Dari titik rahasia ini, Alice akan menghitung rahasia bersama $s$ (huruf kecil). Untuk melakukan ini, dia memilih koordinat x dari titik rahasia $S$ yang dinamakan $Sx$, dan dia melewati nilai ini melalui fungsi hash SHA256:

$$ S = (Sx, Sy) $$
$$ s = \text{SHA256}(Sx) $$

- Alice menggunakan rahasia bersama $s$ ini untuk menghitung alamat penerima pembayaran Bitcoin. Awalnya, dia memverifikasi bahwa $s$ terkandung dalam urutan kurva secp256k1. Jika tidak, dia meningkatkan indeks kunci publik Bob untuk menghasilkan rahasia bersama lain;
- Kedua, dia menghitung kunci publik $K0$ dengan menambahkan pada kurva elips titik-titik $B$ dan $s·G$. Dengan kata lain, Alice menambahkan kunci publik yang berasal dari kode pembayaran Bob $B$ dengan titik lain yang dihitung pada kurva elips dengan penambahan titik dan penggandaan dengan rahasia bersama $s$ dari titik generator kurva secp256k1 $G$. Titik baru ini mewakili kunci publik, dan kita namakan $K0$:

$$ K0 = B + s \cdot G $$

- Dengan kunci publik $K0$ ini, Alice dapat menghasilkan alamat penerima virgin standar (misalnya, SegWit V0 dalam bech32).
Setelah Alice mendapatkan alamat penerima Bob $K0$, dia dapat melakukan transaksi Bitcoin secara standar. Untuk melakukan ini, dia memilih UTXO yang dia miliki, diamankan oleh sepasang kunci dari cabang berbeda dari dompet HD-nya, dan menghabiskannya untuk memenuhi output ke alamat Bob $K0$. Penting untuk dicatat bahwa pembayaran ini, setelah alamat dihasilkan, mengikuti proses konvensional dan tidak lagi bergantung pada kunci yang terkait dengan BIP47.
Mari kita rangkum langkah-langkah yang baru saja kita lalui bersama untuk mengirim pembayaran BIP47:
- Alice memilih kunci privat anak turunan pertama dari kode pembayaran pribadinya;
- Dia menghitung sebuah titik rahasia pada kurva elips menggunakan ECDH dari kunci publik anak turunan pertama yang belum digunakan dari kode pembayaran Bob;
- Dia menggunakan titik rahasia ini untuk menghitung sebuah rahasia bersama dengan SHA256;
- Dia menggunakan rahasia bersama ini untuk menghitung titik rahasia baru pada kurva elips;
- Dia menambahkan titik rahasia baru ini ke kunci publik Bob;
- Dia memperoleh kunci publik efemeral baru yang hanya Bob yang memiliki kunci privat yang terkait;
- Alice dapat melakukan transaksi standar kepada Bob dengan alamat penerima efemeral yang diturunkan.

![BTC204](assets/en/66/21.webp)

Jika Alice ingin melakukan pembayaran kedua, dia akan mengikuti langkah yang sama seperti sebelumnya, kecuali kali ini dia akan memilih kunci publik anak turunan kedua dari kode pembayaran Bob. Secara spesifik, dia akan menggunakan kunci yang belum digunakan berikutnya. Dia akan dengan demikian memperoleh alamat penerima baru yang dimiliki oleh Bob, yang ditandai $K1$:

![BTC204](assets/en/66/22.webp)

Dia dapat melanjutkan dengan cara ini dan menurunkan hingga `2^32` alamat yang belum digunakan yang dimiliki oleh Bob.

Dari sudut pandang eksternal, dengan mengamati blockchain, secara teoritis tidak mungkin untuk membedakan pembayaran BIP47 dari pembayaran standar. Berikut adalah contoh transaksi pembayaran BIP47 di Testnet:

```text
94b2e59510f2e1fa78411634c98a77bbb638e28fb2da00c9f359cd5fc8f87254
```

Ini terlihat seperti transaksi standar dengan input yang digunakan, output pembayaran, dan perubahan:

![BTC204](assets/notext/66/23.webp)

### Menerima Pembayaran BIP47 dan Menurunkan Kunci Privat

Alice baru saja melakukan pembayaran pertamanya ke alamat BIP47 baru yang dimiliki oleh Bob. Sekarang mari kita lihat bagaimana Bob menerima pembayaran ini. Kita juga akan melihat mengapa Alice tidak memiliki akses ke kunci privat dari alamat yang baru saja dia generate sendiri, dan bagaimana Bob mengambil kunci ini untuk menghabiskan bitcoin yang baru saja dia terima.
Segera setelah Bob menerima transaksi notifikasi dari Alice, dia menurunkan kunci publik BIP47 $K0$ bahkan sebelum dia mengirimkan pembayaran apa pun. Dia kemudian memantau pembayaran apa pun ke alamat terkait. Faktanya, dia segera menurunkan beberapa alamat yang akan dia pantau ($K0$, $K1$, $K2$, $K3$...). Berikut cara dia menurunkan kunci publik ini $K0$:
- Bob memilih kunci anak privat turunan pertama dari kode pembayarannya. Kunci privat ini dinamakan $b$. Ini terkait dengan kunci publik $B$ yang dengan itu Alice telah melakukan perhitungannya pada langkah sebelumnya:

$$ b $$

- Bob memilih kunci publik pertama Alice yang diturunkan dari kode pembayarannya. Kunci ini dinamakan $A$. Ini terkait dengan kunci privat $a$ yang dengan itu Alice telah melakukan perhitungannya, dan yang hanya Alice yang mengetahuinya. Bob dapat melakukan proses ini karena dia mengetahui kode pembayaran Alice yang ditransmisikan kepadanya dengan transaksi notifikasi:

$$ A = a \cdot G $$

- Bob menghitung titik rahasia $S$, dengan penambahan dan penggandaan titik pada kurva elips, dengan menerapkan kunci privatnya $b$ ke kunci publik Alice $A$. Di sini kita menemukan penggunaan ECDH yang menjamin bahwa titik $S$ ini akan sama untuk Bob dan Alice:

$$ S = b \cdot A $$
- Sama seperti yang dilakukan Alice, Bob mengisolasi koordinat-x dari titik ini $S$. Nilai ini kami namakan $Sx$. Dia melewati nilai ini melalui fungsi SHA256 untuk menemukan rahasia bersama $s$ (huruf kecil):
$$ s = \text{SHA256}(Sx) $$

- Sama seperti Alice, Bob menghitung titik $s·G$ pada kurva elips. Kemudian, dia menambahkan titik rahasia ini ke kunci publiknya $B$. Dia kemudian mendapatkan titik baru pada kurva elips yang dia interpretasikan sebagai kunci publik $K0$:

$$ K0 = B + s \cdot G $$

Setelah Bob memiliki kunci publik $K0$ ini, dia dapat menurunkan kunci privat terkait agar dapat menghabiskan bitcoinnya. Dia adalah satu-satunya yang dapat menghasilkan kunci privat ini:

- Bob menambahkan kunci privat anaknya $b$ yang diturunkan dari kode pembayaran pribadinya. Dia adalah satu-satunya yang dapat memperoleh nilai $b$. Kemudian, dia menambahkan $b$ dengan rahasia bersama $s$ untuk mendapatkan $k0$, kunci privat dari $K0$:

$$ k0 = b + s $$

Berkat hukum grup dari kurva elips, Bob mendapatkan tepat kunci privat yang sesuai dengan kunci publik yang digunakan oleh Alice. Dengan demikian, kita memiliki:

$$ K0 = k0 \cdot G $$
Saya akan merangkum langkah-langkah yang baru saja kita lalui bersama untuk menerima pembayaran BIP47 dan menghitung kunci privat yang sesuai:
- Bob memilih kunci privat anak turunan pertama dari kode pembayaran pribadinya;
- Dia menghitung titik rahasia pada kurva elips menggunakan ECDH dari kunci publik anak turunan pertama dari kode rantai Alice;
- Dia menggunakan titik rahasia ini untuk menghitung rahasia bersama dengan SHA256;
- Dia menggunakan rahasia bersama ini untuk menghitung titik rahasia baru pada kurva elips;
- Dia menambahkan titik rahasia baru ini ke kunci publik pribadinya;
- Dia memperoleh kunci publik efemeral baru, tempat Alice akan mengirim pembayaran pertamanya;
- Bob menghitung kunci privat yang terkait dengan kunci publik efemeral ini dengan menambahkan kunci privat anak turunan dari kode pembayarannya dan rahasia bersama.

![BTC204](assets/en/66/24.webp)

Karena Alice tidak dapat memperoleh $b$ (kunci privat Bob), dia tidak dapat menentukan $k0$ (kunci privat yang terkait dengan alamat penerimaan BIP47 Bob). Secara skematis, kita dapat merepresentasikan perhitungan rahasia bersama $S$ seperti ini:

![BTC204](assets/en/66/19.webp)

Setelah rahasia bersama ditemukan dengan ECDH, Alice dan Bob menghitung kunci publik pembayaran BIP47 $K0$, dan Bob juga menghitung kunci privat terkait $k0$:

![BTC204](assets/en/66/25.webp)

### Mengembalikan Pembayaran BIP47

Karena Bob mengetahui kode pembayaran yang dapat digunakan kembali oleh Alice, dia sudah memiliki semua informasi yang diperlukan untuk mengirimkan pengembalian dana kepadanya. Dia tidak perlu menghubungi Alice lagi untuk meminta informasi apa pun. Dia hanya perlu memberitahunya dengan transaksi notifikasi, terutama agar dia dapat mengambil alamat BIP47-nya dengan benihnya, dan kemudian dia juga dapat mengirimkan pembayaran hingga `2^32` kepadanya.

Fungsionalitas pengembalian dana spesifik untuk BIP47 dan merupakan salah satu kelebihannya dibandingkan metode lain yang akan kita pelajari di bab-bab mendatang, seperti Pembayaran Senyap.

Bob kemudian dapat mengembalikan dana kepada Alice dengan cara yang sama dia mengirimkan pembayaran kepadanya. Peran dibalik:

![BTC204](assets/en/66/26.webp)
*Terima kasih banyak kepada [Fanis Michalakis](https://x.com/FanisMichalakis) atas tinjauannya dan saran ahli yang berharga mengenai artikel yang menginspirasi penulisan bab ini!*
https://planb.network/tutorials/privacy/paynym-bip47

## Pembayaran Rahasia
<chapterId>2871d594-414e-4598-a830-91c9eb84dfb8</chapterId>
BIP47 telah dikritik karena ketidakefisiennya dalam rantai. Seperti yang dijelaskan di bab sebelumnya, ini memerlukan transaksi notifikasi untuk setiap penerima baru. Kendala ini menjadi tidak signifikan jika seseorang berencana untuk menetapkan saluran pembayaran yang berkelanjutan dengan penerima ini. Memang, satu transaksi notifikasi membuka jalan untuk jumlah pembayaran BIP47 yang hampir tak terbatas.

Namun, dalam situasi tertentu, transaksi notifikasi bisa menjadi penghalang bagi pengguna. Ambil contoh donasi satu kali kepada penerima: dengan alamat Bitcoin klasik, satu transaksi sudah cukup untuk melakukan donasi. Namun dengan BIP47, dua transaksi diperlukan: satu untuk notifikasi dan satu lagi untuk pembayaran sebenarnya. Ketika permintaan untuk ruang blok rendah dan biaya transaksi minimal, langkah tambahan ini umumnya bukan masalah. Namun, selama periode kemacetan, biaya transaksi bisa menjadi sangat mahal untuk satu pembayaran, berpotensi menggandakan biaya bagi pengguna dibandingkan dengan transaksi Bitcoin standar, yang mungkin tidak dapat diterima oleh pengguna.

Untuk situasi di mana pengguna berencana untuk melakukan hanya beberapa pembayaran ke pengenal statis, solusi lain telah dikembangkan. Di antaranya adalah Pembayaran Rahasia, yang dijelaskan dalam [BIP352](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki). Protokol ini memungkinkan penggunaan pengenal statis untuk menerima pembayaran tanpa menghasilkan penggunaan ulang alamat, dan tanpa memerlukan penggunaan transaksi notifikasi. Mari kita periksa bagaimana protokol ini bekerja.

---

*Untuk sepenuhnya memahami bab ini, sangat penting untuk familiar dengan cara kerja ECDH (Elliptic Curve Diffie-Hellman) dan derivasi kunci kriptografis dalam dompet HD. Konsep-konsep ini telah dijelaskan secara rinci di bab sebelumnya tentang BIP47. Saya tidak akan membahasnya lagi di sini. Jika Anda belum familiar dengan konsep-konsep ini, saya sarankan untuk berkonsultasi dengan bab sebelumnya sebelum melanjutkan dengan ini. Saya juga tidak akan mengulangi risiko yang terkait dengan penggunaan ulang alamat penerima, maupun pentingnya memiliki pengenal unik untuk menerima pembayaran.*

---

### Mengapa tidak memindahkan notifikasi?

Seperti yang dibahas dalam bab tentang BIP47, transaksi notifikasi terutama berfungsi dua hal:
- Ini memberitahu penerima;
- Ini mentransmisikan kode pembayaran pengirim.

Seseorang mungkin secara naif berpikir bahwa proses notifikasi ini bisa dilakukan di luar rantai. Secara teori, ini sepenuhnya bisa dilakukan: cukup bagi penerima untuk menunjukkan sarana komunikasi untuk menerima kode pembayaran BIP47 dari pengirim. Namun, pendekatan ini menyajikan dua masalah utama:
- Pertama, ini akan memindahkan proses transmisi kode ke protokol komunikasi lain. Masalah terkait biaya dan privasi pertukaran akan tetap ada, tetapi hanya dipindahkan ke protokol baru ini. Dari segi privasi, ini juga bisa menciptakan tautan antara identitas pengguna dan aktivitas onchain, yang merupakan sesuatu yang kita coba hindari dengan melakukan notifikasi langsung di blockchain. Selain itu, melakukan notifikasi di luar blockchain akan memperkenalkan risiko sensor (seperti pemblokiran dana) yang tidak ada di Bitcoin;
Selanjutnya, hal ini akan menimbulkan masalah pemulihan. Dengan BIP47, penerima harus benar-benar mengetahui kode pembayaran dari pengirim untuk mengakses dana. Hal ini berlaku pada saat penerimaan, tetapi juga dalam hal pemulihan dana melalui seed dalam kasus kehilangan dompet. Dengan notifikasi onchain, risiko ini dihindari, karena pengguna dapat menemukan dan mendekripsi transaksi notifikasi hanya dengan mengetahui seed mereka. Namun, jika notifikasi dilakukan di luar blockchain, pengguna perlu memelihara cadangan dinamis dari semua kode pembayaran yang diterima, yang tidak praktis untuk pengguna rata-rata.

Semua keterbatasan ini membuat penggunaan notifikasi onchain menjadi sangat penting dalam konteks BIP47. Namun, Silent Payments secara spesifik berusaha menghindari langkah notifikasi onchain ini karena biayanya. Oleh karena itu, solusi yang diadopsi bukanlah memindahkan notifikasi, tetapi menghilangkannya sepenuhnya. Untuk mencapai ini, kompromi harus diterima: yaitu pemindaian. Berbeda dengan BIP47, di mana pengguna tahu persis di mana menemukan dana mereka berkat transaksi notifikasi, dalam konteks Silent Payments, pengguna harus memeriksa semua transaksi Bitcoin yang ada untuk mendeteksi pembayaran apa pun yang mungkin ditujukan untuk mereka. Untuk mengurangi beban operasional ini, pencarian Silent Payments hanya terbatas pada transaksi yang kemungkinan besar mengandung pembayaran tersebut, yaitu yang mencakup setidaknya satu output Taproot P2TR. Pemindaian juga secara eksklusif berfokus pada transaksi sejak tanggal pembuatan dompet (tidak perlu memindai transaksi yang kembali ke 2009 jika dompet dibuat pada 2024).

Oleh karena itu, Anda dapat melihat mengapa BIP47 dan Silent Payments, meskipun bertujuan untuk objektif yang serupa, melibatkan kompromi yang berbeda dan **dengan demikian sebenarnya melayani kasus penggunaan yang berbeda**. Untuk pembayaran satu kali, seperti donasi sesekali, Silent Payments lebih tepat karena biayanya yang lebih rendah. Sebaliknya, untuk transaksi reguler ke penerima yang sama, seperti dalam kasus platform pertukaran atau kolam penambangan, BIP47 mungkin lebih disukai.
Mari kita jelajahi bersama cara kerja teknis Silent Payments untuk lebih memahami implikasinya. Untuk melakukan ini, saya sarankan kita mengambil pendekatan yang sama seperti dokumen penjelasan BIP352. Kami akan secara bertahap memecah perhitungan yang harus dilakukan, elemen demi elemen, membenarkan setiap penambahan baru.
### Beberapa konsep untuk dipahami

Sebelum kita mulai, penting untuk menjelaskan bahwa Silent Payments sepenuhnya mengandalkan penggunaan tipe skrip P2TR (*Pay to Taproot*). Tidak seperti BIP47, tidak perlu menurunkan alamat penerima dari kunci publik anak dengan meng-hash-nya. Memang, dalam standar P2TR, kunci publik yang dimodifikasi digunakan secara langsung dan terbuka dalam alamat. Dengan demikian, alamat penerima Taproot pada dasarnya adalah kunci publik yang disertai dengan beberapa metadata. Kunci publik yang dimodifikasi ini adalah agregasi dari dua kunci publik lainnya: satu yang memungkinkan pengeluaran langsung dan tradisional melalui tanda tangan sederhana, dan yang lainnya mewakili akar Merkle dari MAST, yang mengizinkan pengeluaran tunduk pada kepuasan salah satu kondisi yang mungkin tertera dalam pohon Merkle.

![BTC204](assets/en/67/01.webp)

Keputusan untuk membatasi Silent Payments secara eksklusif ke Taproot didorong oleh dua alasan utama:
- Pertama, ini secara signifikan memudahkan implementasi dan pembaruan masa depan dalam perangkat lunak dompet, karena hanya satu standar yang perlu diikuti;
- Kedua, pendekatan ini membantu meningkatkan set anonimitas pengguna dengan mendorong mereka untuk tidak menyebar di antara berbagai jenis skrip, yang menghasilkan sidik jari dompet yang berbeda dalam analisis rantai (untuk informasi lebih lanjut tentang konsep ini, saya mengundang Anda untuk berkonsultasi dengan bab 4 dari bagian 2).

### Turunan Naif dari kunci publik Silent Payments
Mari kita mulai dengan contoh sederhana yang akan membantu Anda memahami fungsi inti dari SP (Silent Payments). Ambil Alice dan Bob, dua pengguna Bitcoin. Alice ingin mengirim bitcoin ke Bob pada alamat penerima baru. Tiga tujuan harus dicapai dalam proses ini:
- Alice harus dapat menghasilkan alamat baru;
- Bob harus dapat mengidentifikasi pembayaran yang dikirim ke alamat spesifik ini;
- Bob harus dapat memperoleh kunci privat yang terkait dengan alamat ini untuk dapat menghabiskan dana miliknya.

Alice memiliki UTXO di dompet Bitcoinnya yang diamankan dengan pasangan kunci berikut:
- $a$: kunci privat;
- $A$: kunci publik ($A = a \cdot G$)

Bob memiliki alamat SP yang telah dia publikasikan di internet dengan:
- $b$: kunci privat;
- $B$: kunci publik ($B = b \cdot G$)
Dengan mengambil alamat Bob, Alice dapat menghitung alamat kosong baru yang milik Bob menggunakan ECDH. Mari kita sebut alamat ini $P$:
$$  P = B + \text{hash}(a \cdot B) \cdot G  $$

Dalam persamaan ini, Alice hanya menghitung hasil kali titik dari kunci privatnya $a$ dan kunci publik Bob $B$. Dia melewati hasil ini melalui fungsi hash yang diketahui semua orang. Nilai output kemudian dikalikan skalar dengan titik generator $G$ dari kurva eliptik `secp256k1`. Akhirnya, Alice menambahkan titik yang diperoleh ke kunci publik Bob $B$. Setelah Alice memiliki alamat ini $P$, dia menggunakannya sebagai output dalam transaksi, artinya dia mengirim bitcoin kepadanya.

> *Dalam konteks Silent Payments, fungsi "hash" sesuai dengan fungsi hash SHA256 yang ditandai secara khusus dengan `BIP0352/SharedSecret`, memastikan bahwa hash yang dihasilkan unik untuk protokol ini dan tidak dapat digunakan kembali dalam konteks lain, sekaligus memberikan perlindungan tambahan terhadap penggunaan kembali nonce dalam tanda tangan. Standar ini sesuai dengan yang [ditentukan dalam BIP340 untuk tanda tangan Schnorr](https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki) pada `secp256k1`.*

Berkat sifat-sifat kurva eliptik yang menjadi dasar ECDH, kita tahu bahwa:

$$  a \cdot B = b \cdot A  $$

Bob akan dapat menghitung alamat penerima tempat Alice mengirim bitcoin. Untuk melakukan ini, dia memantau semua transaksi Bitcoin yang memenuhi kriteria Silent Payments dan menerapkan perhitungan berikut ke masing-masing dari mereka untuk melihat apakah pembayaran ditujukan kepadanya (*scanning*):

$$  P' = B + \text{hash}(b \cdot A) \cdot G  $$

Ketika dia memindai transaksi Alice, dia menyadari bahwa $P'$ sama dengan $P$. Dia dengan demikian tahu bahwa pembayaran ini ditujukan kepadanya:

$$  P' = B + \text{hash}(b \cdot A) \cdot G = B + \text{hash}(a \cdot B) \cdot G = P   $$

Dari sana, Bob akan dapat menghitung kunci privat $p$ yang memungkinkan pengeluaran alamat $P$:

$$  p = (b + \text{hash}(b \cdot A)) \bmod n  $$

Seperti yang Anda lihat, untuk menghitung kunci privat ini $p$, seseorang harus memiliki kunci privat $b$. Hanya Bob yang memiliki kunci privat ini $b$. Dia akan memang menjadi satu-satunya yang dapat menghabiskan bitcoin yang dikirim ke alamat Silent Payments miliknya.

![BTC204](assets/notext/67/02.webp)
*Keterangan:*
- $B$: Kunci publik / alamat statis yang dipublikasikan oleh Bob
- $b$: Kunci privat Bob
- $A$: Kunci publik UTXO Alice yang digunakan sebagai input untuk transaksi
- $a$: Kunci privat Alice
- $G$: Titik generator dari kurva eliptik `secp256k1`
- $\text{SHA256}$: Fungsi hashing SHA256 dengan tag `BIP0352/SharedSecret`
- $s$: Rahasia ECDH yang umum
- $P$: Kunci publik / alamat unik untuk pembayaran kepada Bob

Berikut adalah pendekatan awal yang cukup naif dalam menggunakan alamat statis Bob, yang ditandai dengan $B$, untuk menurunkan alamat unik $P$ untuk mengirim bitcoin. Namun, metode ini terlalu sederhana dan memiliki beberapa kekurangan yang perlu diperbaiki. Masalah pertama adalah, dalam skema ini, Alice tidak dapat membuat beberapa output kepada Bob dalam transaksi yang sama.

### Bagaimana cara membuat beberapa output?

Dalam contoh dari bagian sebelumnya, Alice membuat satu output yang akan pergi ke Bob di alamat uniknya $P$. Dengan input yang sama dipilih, mustahil bagi Alice untuk membuat dua alamat virgin yang berbeda untuk Bob, karena metode yang digunakan akan selalu menghasilkan hasil yang sama untuk $P$, sehingga alamat yang sama. Namun, mungkin ada banyak situasi di mana Alice ingin membagi pembayarannya kepada Bob menjadi beberapa jumlah yang lebih kecil, sehingga menciptakan beberapa UTXO. Oleh karena itu, perlu untuk menemukan metode yang memungkinkan ini dilakukan.

Untuk mencapai ini, kita akan sedikit memodifikasi perhitungan yang dilakukan Alice untuk menurunkan $P$, sehingga dia dapat menghasilkan dua alamat yang berbeda untuk Bob, yaitu $P_0$ dan $P_1$.

Untuk memodifikasi perhitungan dan mendapatkan 2 alamat yang berbeda, cukup dengan menambahkan sebuah bilangan bulat yang memodifikasi hasilnya. Dengan demikian, Alice akan menambahkan $0$ dalam perhitungannya untuk mendapatkan alamat $P_0$ dan $1$ untuk mendapatkan alamat $P_1$. Mari kita sebut bilangan bulat ini $i$:

$$  P_i = B + \text{hash}(a \cdot B \text{ ‖ } i) \cdot G  $$

Proses perhitungan tetap tidak berubah dari metode sebelumnya, kecuali kali ini Alice akan menggabungkan $a \cdot B$ dengan $i$ sebelum melanjutkan ke hash. Kemudian cukup mengubah $i$ untuk memiliki alamat baru yang dimiliki oleh Bob. Sebagai contoh:

$$  P_0 = B + \text{hash}(a \cdot B \text{ ‖ } 0) \cdot G  $$

$$  P_1 = B + \text{hash}(a \cdot B \text{ ‖ } 1) \cdot G  $$
Ketika Bob memindai blockchain untuk Pembayaran Senyap yang ditujukan untuknya, dia mulai dengan menggunakan $i = 0$ untuk alamat $P_0$. Jika dia tidak menemukan pembayaran pada $P_0$, dia menyimpulkan bahwa transaksi ini tidak mengandung Pembayaran Senyap untuknya dan berhenti menganalisisnya. Namun, jika $P_0$ valid dan mengandung pembayaran untuknya, dia melanjutkan dengan $P_1$ dalam transaksi yang sama untuk memeriksa apakah Alice membuat pembayaran kedua. Jika $P_1$ ternyata tidak valid, dia menghentikan pencariannya untuk transaksi ini; jika tidak, dia terus menguji nilai $i$ yang berurutan:
$$  P_0 = B + \text{hash}(b \cdot A \text{ ‖ } 0) \cdot G  $$
$$  P_1 = B + \text{hash}(b \cdot A \text{ ‖ } 1) \cdot G  $$
Karena Bob langsung berhenti pada $i = 0$ jika $P_0$ tidak menghasilkan apa-apa, penggunaan bilangan bulat ini hampir tidak menambah beban operasional tambahan pada Bob untuk langkah pemindaian transaksi.

Bob kemudian dapat menghitung kunci privat dengan cara yang sama:

$$ 
p_0 = (b + \text{hash}(b \cdot A \text{ ‖ } 0)) \bmod n
 $$

$$ 
p_1 = (b + \text{hash}(b \cdot A \text{ ‖ } 1)) \bmod n 
 $$

![BTC204](assets/notext/67/03.webp)

*Keterangan:*
- $B$: Kunci publik / alamat statis yang dipublikasikan oleh Bob
- $b$: Kunci privat Bob
- $A$: Kunci publik UTXO Alice yang digunakan sebagai input untuk transaksi
- $a$: Kunci privat Alice
- $G$: Titik generator dari kurva eliptik `secp256k1`
- $\text{SHA256}$: Fungsi hash SHA256 dengan tag `BIP0352/SharedSecret`
- $s_0$: Rahasia ECDH bersama pertama
- $s_1$: Rahasia ECDH bersama kedua
- $P_0$: Kunci publik / alamat unik pertama untuk pembayaran kepada Bob
- $P_1$: Kunci publik / alamat unik kedua untuk pembayaran kepada Bob

Dengan metode ini, kita mulai memiliki protokol yang bagus, tetapi masih ada beberapa tantangan yang harus diatasi, terutama pencegahan penggunaan ulang alamat.

### Bagaimana cara menghindari penggunaan ulang alamat?
Seperti yang telah kita lihat di bagian sebelumnya, Alice menggunakan pasangan kunci yang mengamankan UTXO-nya, yang akan dia gunakan untuk menghitung rahasia ECDH bersama dengan Bob. Rahasia ini memungkinkan dia untuk menurunkan alamat unik $P_0$. Namun, pasangan kunci ($a$, $A$) yang digunakan oleh Alice dapat mengamankan beberapa UTXO jika dia telah menggunakan alamat ini beberapa kali. Dalam kejadian bahwa Alice melakukan dua pembayaran ke alamat statis Bob $B$ menggunakan dua UTXO yang diamankan oleh kunci yang sama $A$, ini akan mengakibatkan penggunaan ulang alamat untuk Bob.
> *Penggunaan ulang alamat adalah praktik yang sangat buruk untuk privasi pengguna. Untuk memahami mengapa, saya menyarankan Anda untuk meninjau bagian pertama dari pelatihan ini.*

Memang, karena alamat unik $P_0$ diturunkan dari $A$ dan $B$, jika Alice menurunkan alamat kedua untuk pembayaran kedua ke $B$, dengan kunci yang sama $A$, dia akan berakhir dengan alamat yang sama $P_0$. Untuk menghindari risiko ini dan mencegah penggunaan ulang alamat dalam Pembayaran Senyap, kita perlu sedikit memodifikasi perhitungan kita.

Yang kita inginkan adalah untuk setiap UTXO yang dikonsumsi oleh Alice sebagai input dari pembayaran untuk memberikan alamat unik di sisi Bob, bahkan jika beberapa UTXO diamankan oleh pasangan kunci yang sama. Oleh karena itu, cukup dengan menambahkan referensi ke UTXO dalam perhitungan alamat unik $P_0$. Referensi ini akan menjadi hash dari UTXO yang dikonsumsi sebagai input:

$$  \text{inputHash} = \text{hash}(\text{outpoint} \text{ ‖ } A)  $$

Dan referensi input ini, Alice akan menambahkannya dalam perhitungannya terhadap alamat unik $P_0$:
Selama pemindaian, Bob juga dapat menambahkan $\text{inputHash}$, karena yang perlu dia lakukan adalah mengamati transaksi untuk menemukan $\text{outpoint}$:

$$  P_0 = B + \text{hash}(\text{inputHash} \cdot b \cdot A \text{ ‖ } 0) \cdot G  $$

Ketika dia menemukan $P_0$ yang valid, dia dapat menghitung kunci privat yang sesuai $p_0$:

$$ 
p_0 = (b + \text{hash}(\text{inputHash} \cdot b \cdot A \text{ ‖ } 0)) \bmod n
 $$

![BTC204](assets/notext/67/04.webp)

*Legenda:*
- $B$: Kunci publik / alamat statis yang dipublikasikan oleh Bob
- $b$: Kunci privat Bob
- $A$: Kunci publik UTXO Alice yang digunakan sebagai input untuk transaksi
- $a$: Kunci privat Alice
- $H$: Hash dari UTXO yang digunakan sebagai input
- $G$: Titik generator dari kurva eliptik `secp256k1`
- $\text{SHA256}$: Fungsi hash SHA256 dengan tag `BIP0352/SharedSecret`
- $s_0$: Rahasia bersama ECDH pertama
- $P_0$: Kunci publik / alamat unik pertama untuk pembayaran ke Bob

Saat ini, perhitungan kita mengasumsikan bahwa Alice menggunakan satu input untuk transaksinya. Namun, dia seharusnya dapat menggunakan beberapa input. Akibatnya, di sisi Bob, untuk setiap transaksi yang mengandung beberapa input, dia secara teoritis perlu menghitung ECDH untuk setiap input untuk menentukan apakah pembayaran dimaksudkan untuknya. Metode ini tidak memuaskan, jadi kita perlu menemukan solusi untuk mengurangi beban kerja!

### Menyesuaikan kunci publik dalam input

Untuk menyelesaikan masalah ini, alih-alih menggunakan pasangan kunci yang mengamankan input spesifik di sisi Alice, kita akan menggunakan jumlah dari semua pasangan kunci yang digunakan dalam input transaksi. Jumlah ini kemudian akan dianggap sebagai pasangan kunci baru. Teknik ini dikenal sebagai "tweak".

Misalnya, bayangkan transaksi Alice memiliki 3 input, masing-masing diamankan dengan pasangan kunci yang berbeda:
- $a_0$ mengamankan input #0;
- $a_1$ mengamankan input #1;
- $a_2$ mengamankan input #2.

![BTC204](assets/notext/67/05.webp)

Mengikuti metode yang dijelaskan di atas, Alice harus memilih satu pasangan kunci di antara $a_0$, $a_1$, dan $a_2$ untuk menghitung rahasia ECDH dan menghasilkan alamat pembayaran unik $P$ dari alamat statis Bob $B$. Namun, pendekatan ini mengharuskan Bob untuk menguji setiap kemungkinan secara berurutan, dimulai dengan $a_0$, kemudian $a_1$, dan seterusnya, sampai mengidentifikasi pasangan yang menghasilkan alamat yang valid $P$. Proses ini menuntut Bob untuk melakukan perhitungan ECDH pada semua input dari semua transaksi, secara signifikan meningkatkan beban kerja pemindaian operasional.

Untuk menghindari ini, kita akan meminta Alice untuk melakukan perhitungannya dari $P$ menggunakan jumlah dari semua kunci dalam input. Mengambil contoh kita, kunci privat yang disesuaikan $a$ akan dihitung sebagai berikut:

$$  a = a_0 + a_1 + a_2  $$
Demikian pula, Alice dan Bob akan dapat menghitung kunci publik yang dimodifikasi:
$$  A = A_0 + A_1 + A_2  $$
Berkat metode ini, Bob hanya perlu menghitung jumlah kunci publik dari transaksi, kemudian menghitung rahasia ECDH dari $A$ saja, yang sangat mengurangi jumlah perhitungan yang harus dilakukan untuk langkah pemindaian. Namun, ingat dari bagian sebelumnya. Kami telah memasukkan dalam perhitungan kami hash $\text{inputHash}$ yang digunakan sebagai nonce untuk mencegah penggunaan ulang alamat:

$$  \text{inputHash} = \text{hash}(\text{outpoint} \text{ ‖ } A)  $$

Namun, jika ada beberapa input dalam sebuah transaksi, perlu ditentukan $\text{outpoint}$ mana yang dipilih dalam perhitungan ini. Menurut BIP352, kriteria pemilihan untuk $\text{outpoint}$ yang digunakan adalah memilih yang terkecil secara leksikografis, yang berarti memilih UTXO yang muncul pertama dalam urutan abjad. Metode ini menstandarkan UTXO yang dipilih dalam setiap transaksi. Misalnya, jika $\text{outpoint}$ terkecil secara leksikografis ini adalah $\text{outpoint}_L$, perhitungan $\text{inputHash}$ akan menjadi:

$$  \text{inputHash} = \text{hash}(\text{outpoint}_L \text{ ‖ } A)  $$

Perhitungan kemudian tetap identik dengan yang disajikan di bagian sebelumnya, kecuali bahwa kunci privat $a$ dan kunci publik yang sesuai $A$ bukan lagi sepasang yang mengamankan satu input, tetapi sekarang mewakili modifikasi dari semua pasangan kunci dalam input.

### Memisahkan Kunci Pengeluaran dan Pemindaian

Sejauh ini, kami telah membahas alamat statis Pembayaran Diam $B$ sebagai kunci publik unik. Ingat, kunci publik $B$ inilah yang digunakan oleh Alice untuk membuat rahasia ECDH bersama, yang pada gilirannya digunakan untuk menghitung alamat pembayaran unik $P$. Bob menggunakan kunci publik $B$ ini dan kunci privat yang sesuai $b$ untuk langkah pemindaian. Namun, dia juga akan menggunakan kunci privat $b$ untuk menghitung kunci privat $p$ yang memungkinkan pengeluaran dari alamat $P$.

Kekurangan dari metode ini adalah kunci privat $b$, yang digunakan untuk menghitung semua kunci privat untuk alamat yang menerima Pembayaran Diam, juga digunakan oleh Bob untuk memindai transaksi. Langkah ini memerlukan agar kunci $b$ tersedia pada perangkat lunak dompet yang terhubung ke internet, yang mengeksposnya ke risiko pencurian yang lebih besar dibandingkan dengan menyimpannya di dompet dingin. Idealnya, akan bermanfaat untuk dapat memanfaatkan Pembayaran Diam sambil menjaga kunci privat $b$, yang mengontrol akses ke semua kunci privat lainnya, diamankan di dompet perangkat keras. Untungnya, protokol telah disesuaikan untuk memungkinkan hal itu.
Untuk mencapai ini, BIP352 menentukan bahwa penerima menggunakan 2 pasang kunci yang berbeda:
- $B_{\text{spend}}$: untuk menghitung kunci privat dari alamat pembayaran unik;
- $B_{\text{scan}}$: untuk menemukan alamat pembayaran unik.

Dengan cara ini, Bob dapat menyimpan kunci privat $b_{\text{spend}}$ di dompet perangkat keras dan menggunakan kunci privat $b_{\text{scan}}$ pada perangkat lunak online untuk menemukan Pembayaran Diamnya, tanpa mengungkapkan $b_{\text{spend}}$. Namun, kunci publik $B_{\text{scan}}$ dan $B_{\text{spend}}$ keduanya diungkapkan secara publik, karena mereka ditemukan di alamat statis Bob $B$:
Untuk menghitung alamat pembayaran unik $P_0$ yang dimiliki oleh Bob, Alice akan melakukan perhitungan berikut:

$$  P_0 = B_{\text{spend}} + \text{hash}(\text{inputHash} \cdot a \cdot B_{\text{scan}} \text{ ‖ } 0) \cdot G  $$

Untuk menemukan pembayaran yang ditujukan kepadanya, Bob akan melakukan perhitungan berikut:

$$  P_0 = B_{\text{spend}} + \text{hash}(\text{inputHash} \cdot b_{\text{scan}} \cdot A \text{ ‖ } 0) \cdot G  $$

Seperti yang Anda lihat, sampai sejauh ini, Bob tidak perlu menggunakan $b_{\text{spend}}$ yang ada di dompet hardware-nya. Ketika dia ingin menghabiskan $P_0$, dia kemudian dapat melakukan perhitungan berikut untuk menemukan kunci privat $p_0$:

$$ p_0 = (b_{\text{spend}} + \text{hash}(\text{inputHash} \cdot b_{\text{scan}} \cdot A \text{ ‖ } 0)) \bmod n $$

![BTC204](assets/notext/67/06.webp)

*Keterangan:*
- $B_{\text{scan}}$: Kunci publik pemindaian Bob (alamat statis)
- $b_{\text{scan}}$: Kunci privat pemindaian Bob
- $B_{\text{spend}}$: Kunci publik pengeluaran Bob (alamat statis)
- $b_{\text{spend}}$: Kunci privat pengeluaran Bob
- $A$: Jumlah kunci publik dalam input (modifikasi)
- $a$: Kunci privat yang sesuai dengan kunci publik yang dimodifikasi
- $H$: Hash dari UTXO terkecil (secara leksikografis) yang digunakan dalam input
- $G$: Titik generator dari kurva eliptik `secp256k1`
- $\text{SHA256}$: Fungsi hashing SHA256 dengan tag `BIP0352/SharedSecret`
- $s_0$: Rahasia bersama ECDH pertama
- $P_0$: Kunci publik pertama / alamat pembayaran unik untuk Bob

### Menggunakan alamat SP dengan label

Dengan demikian, Bob memiliki alamat statis $B$ untuk Pembayaran Senyap sebagai berikut:

$$ B = B_{\text{scan}} \text{ ‖ } B_{\text{spend}} $$

Masalah dengan metode ini adalah tidak memungkinkan untuk memisahkan pembayaran yang berbeda yang dikirim ke alamat ini. Misalnya, jika Bob memiliki 2 klien berbeda untuk bisnisnya dan dia ingin membedakan pembayaran dari masing-masing dengan jelas, dia akan membutuhkan 2 alamat statis yang berbeda. Solusi naif, dengan pendekatan saat ini, adalah untuk Bob membuat dua dompet terpisah, masing-masing dengan alamat statisnya sendiri, atau bahkan untuk menetapkan dua alamat statis yang berbeda dalam dompet yang sama. Namun, solusi ini memerlukan pemindaian seluruh blockchain dua kali (sekali untuk setiap alamat) untuk masing-masing mendeteksi pembayaran yang ditujukan untuk setiap alamat. Pemindaian ganda ini tidak masuk akal meningkatkan beban operasional untuk Bob.
Untuk menyelesaikan masalah ini, BIP352 menggunakan sistem pelabelan yang memungkinkan adanya alamat statis yang berbeda tanpa meningkatkan beban kerja secara tidak wajar untuk menemukan Pembayaran Senyap di blockchain. Untuk melakukan ini, sebuah bilangan bulat $m$ ditambahkan ke kunci publik pengeluaran $B_{\text{spend}}$. Bilangan bulat ini dapat mengambil nilai $1$ untuk alamat statis pertama, kemudian $2$ untuk yang kedua, dan seterusnya. Kunci pengeluaran $B_{\text{spend}}$ selanjutnya akan disebut $B_m$ dan akan dibangun dengan cara berikut:
$$  B_m = B_{\text{spend}} + \text{hash}(b_{\text{scan}} \text{ ‖ } m) \cdot G  $$

Sebagai contoh, untuk kunci pengeluaran pertama dengan label $1$:

$$  B_1 = B_{\text{spend}} + \text{hash}(b_{\text{scan}} \text{ ‖ } 1) \cdot G  $$

Alamat statis yang dipublikasikan oleh Bob sekarang akan terdiri dari $B_{\text{scan}}$ dan $B_m$. Sebagai contoh, alamat statis pertama dengan label $1$ akan menjadi:

$$ B = B_{\text{scan}} \text{ ‖ } B_1 $$

> *Kita mulai hanya dari label 1 karena label 0 diperuntukkan untuk perubahan.*

Alice, dari bagiannya, akan menurunkan alamat pembayaran unik $P$ dengan cara yang sama seperti sebelumnya, tetapi menggunakan $B_1$ yang baru daripada $B_{\text{spend}}$.
$$  P_0 = B_1 + \text{hash}(\text{inputHash} \cdot a \cdot B_{\text{scan}} \text{ ‖ } 0) \cdot G  $$

Dalam kenyataannya, Alice mungkin bahkan tidak tahu bahwa Bob memiliki alamat berlabel, karena dia hanya menggunakan bagian kedua dari alamat statis yang diberikan kepadanya, yang dalam kasus ini, adalah nilai $B_1$ daripada $B_{\text{spend}}$.

Untuk memindai pembayaran, Bob akan selalu menggunakan nilai dari alamat statis awalnya dengan $B_{\text{spend}}$ dengan cara ini:

$$   P_0 = B_{\text{spend}} + \text{hash}(\text{inputHash} \cdot b_{\text{scan}} \cdot A \text{ ‖ } 0) \cdot G  $$

Kemudian, dia hanya mengurangkan nilai yang dia temukan untuk $P_0$ dari setiap output satu per satu. Dia kemudian memeriksa apakah salah satu hasil dari pengurangan ini cocok dengan nilai salah satu label yang dia gunakan di dompetnya. Jika cocok, misalnya, untuk output #4 dengan label $1$, ini berarti bahwa output ini adalah Pembayaran Senyap yang terkait dengan alamat statis berlabelnya $B_1$:

$$ Out_4 - P_0 = \text{hash}(b_{\text{scan}} \text{ ‖ } 1) \cdot G $$

Ini berhasil karena:

$$  B_1 = B_{\text{spend}} + \text{hash}(b_{\text{scan}} \text{ ‖ } 1) \cdot G  $$
Berikut adalah terjemahan dari teks yang diberikan:

Berkat metode ini, Bob dapat menggunakan berbagai alamat statis ($B_1$, $B_2$, $B_3$...), semua berasal dari alamat statis dasarnya ($B = B_{\text{scan}} \text{ ‖ } B_{\text{spend}}$), untuk memisahkan penggunaan dengan tepat.
Namun, pemisahan alamat statis ini hanya berlaku dari perspektif manajemen dompet pribadi dan tidak memungkinkan pemisahan identitas. Karena semuanya memiliki $B_{\text{scan}}$ yang sama, sangat mudah untuk mengasosiasikan semua alamat statis bersama-sama dan menyimpulkan bahwa mereka milik satu entitas.

![BTC204](assets/notext/67/07.webp)

*Keterangan:*
- $B_{\text{scan}}$: Kunci publik pemindaian Bob (alamat statis)
- $b_{\text{scan}}$: Kunci privat pemindaian Bob
- $B_{\text{spend}}$: Kunci publik pengeluaran Bob (alamat awal)
- $B_m$: Kunci publik pengeluaran berlabel Bob (alamat statis)
- $b_m$: Kunci privat pengeluaran berlabel Bob
- $A$: Jumlah kunci publik masukan (tweak)
- $a$: Kunci privat yang sesuai dengan kunci publik yang di-tweak
- $H$: Hash dari UTXO terkecil (secara leksikografis) yang digunakan sebagai masukan
- $G$: Titik generator dari kurva eliptik `secp256k1`
- $\text{SHA256}$: Fungsi hashing SHA256 dengan tag `BIP0352/SharedSecret`
- $s_0$: Rahasia ECDH bersama pertama
- $P_0$: Kunci publik / alamat unik pertama untuk pembayaran kepada Bob
- $p_0$: Kunci privat dari alamat pembayaran unik pertama kepada Bob
- $X$: Hash dari kunci privat pemindaian dengan label

### Bagaimana Cara Membangun Alamat Pembayaran Senyap?

Untuk membangun alamat Pembayaran Senyap yang khusus, seseorang harus pertama-tama menurunkan 2 pasang kunci di dompet HD Bitcoin mereka:
- Pasangan $b_{\text{scan}}$, $B_{\text{scan}}$ untuk mencari pembayaran yang ditujukan kepada kita;
- Pasangan $b_{\text{spend}}$, $B_{\text{spend}}$ untuk menghabiskan bitcoin yang telah kita terima.

Pasangan ini diturunkan mengikuti jalur ini (*Bitcoin Mainnet*):

```text
scan: m / 352' / 0' / 0' / 1' / 0
spend: m / 352' / 0' / 0' / 0' / 0
```

Setelah kedua pasang kunci ini tersedia, seseorang cukup menggabungkannya (ujung-ke-ujung) untuk membuat muatan alamat statis:

$$ B = B_{\text{scan}} \text{ ‖ } B_{\text{spend}} $$

Jika seseorang ingin menggunakan label, $B_{\text{spend}}$ digantikan dengan $B_m$:

$$ B = B_{\text{scan}} \text{ ‖ } B_m $$

Dengan label $m$:

$$  B_m = B_{\text{spend}} + \text{hash}(b_{\text{scan}} \text{ ‖ } m) \cdot G  $$

Setelah muatan ini tersedia, seseorang menambahkan HRP (*Human-Readable Part*) `sp` dan versi `q` (= versi 0). Sebuah checksum juga ditambahkan, dan alamat diformat dalam bech32m.
Sebagai contoh, berikut adalah alamat Silent Payments statis saya:
```text
sp1qqvhjvsq2vz8zwrw372vuzle7472zup2ql3pz64yn5cpkw5ngv2n6jq4nl8cgm6zmu48yk3eq33ryc7aam6jrvrg0d0uuyzecfhx2wgsumcurv77e
```
Poin penting mengenai alamat statis, yang mungkin telah Anda masukkan di bagian sebelumnya, adalah bahwa alamat-alamat ini tidak terlihat dalam transaksi Bitcoin. Hanya alamat pembayaran $P$, yang digunakan dalam output, yang muncul di blockchain dalam format Taproot standar. Dengan demikian, dari luar, mustahil untuk membedakan transaksi yang melibatkan Silent Payment dari transaksi biasa yang menggunakan output P2TR.
Sama seperti dengan BIP47, mustahil untuk menetapkan koneksi antara alamat statis $B$ dan alamat pembayaran $P$ yang berasal dari $B$. Memang, bahkan jika Eve, seorang penyerang potensial, mencoba memindai blockchain dengan alamat statis Bob $B$, dia tidak akan dapat melakukan perhitungan yang diperlukan untuk menentukan $P$. Untuk melakukan ini, dia memerlukan baik kunci pemindaian privat Bob $b_{\text{scan}}$ atau kunci privat pengirim $a$, tetapi kedua elemen ini, tentu saja, bersifat privat. Oleh karena itu, dimungkinkan untuk secara eksplisit menghubungkan alamat statis seseorang dengan bentuk identitas pribadi.

### Bagaimana cara menggunakan Silent Payments?

Usulan untuk Silent Payments relatif baru dan hanya diimplementasikan oleh sejumlah terbatas dompet sejauh ini. Sejauh pengetahuan saya, hanya ada 3 perangkat lunak yang mendukungnya:
- [CakeWallet](https://cakewallet.com/)
- [Silentium](https://app.silentium.dev/)
- [DonationWallet](https://github.com/Sosthene00/donationwallet)

Kami akan segera menawarkan tutorial terperinci tentang cara mengatur alamat statis Silent Payments Anda sendiri.

Mengingat fitur ini baru, disarankan untuk berhati-hati dan menghindari menggunakan Silent Payments untuk jumlah besar di mainnet.

*Untuk membuat bab ini tentang Silent Payments, saya menggunakan [situs penjelasan Silent Payments](https://silentpayments.xyz/) dan [dokumen penjelasan BIP352](https://github.com/bitcoin/bips/blob/master/bip-0352.mediawiki).*

# Kesimpulan
<partId>2aee56c0-b285-4799-b4f7-373a552ee2b2</partId>


## Evaluasi kursus ini 
<chapterId>195d149f-80fa-5816-8b46-995a9226d082</chapterId>
<isCourseReview>true</isCourseReview>

## Ujian Akhir
<chapterId>e803d394-e3c1-5816-a6b4-a69a2472019c</chapterId>
<isCourseExam>true</isCourseExam>

## Kata Akhir
<chapterId>cd8e5c67-50e4-4dcd-8e04-88ba5ec95305</chapterId>

Selamat telah menyelesaikan pelatihan ini tentang privasi di Bitcoin!
Kami telah membahas banyak topik lanjutan dan teknis dalam pelatihan ini, tetapi tidak wajib untuk menggunakan semua alat yang disajikan. Tujuan utama adalah untuk memberdayakan Anda dalam memilih informasi yang ingin Anda ungkapkan dan informasi yang Anda pilih untuk menjaga kerahasiaan dalam penggunaan Bitcoin Anda. Ini merupakan inti esensial dari perlindungan privasi. Untuk membuat pilihan yang tepat tentang informasi yang akan dibagikan atau disembunyikan, penting untuk menyadari implikasi dari tindakan kita. Saya berharap pelatihan ini telah membantu Anda mendapatkan pengetahuan ini.

Jika saya harus memilih bagian terpenting dari pelatihan ini, saya akan memilih bagian yang didedikasikan untuk analisis rantai. Memahami teknik yang digunakan oleh penyerang potensial Anda adalah cara terbaik untuk melindungi diri. Oleh karena itu, saran saya adalah untuk secara seksama meninjau bagian ini dan mencoba memahami semua detailnya.

Dalam pelatihan ini, kami secara eksklusif fokus pada privasi Bitcoin di rantai utama. Masalah privasi pada sistem lapis kedua, seperti Lightning Network dan sidechain, juga signifikan dan memiliki karakteristik yang sangat spesifik. Meskipun penggunaan transaksi off-chain bisa menjadi strategi efektif untuk menghindari banyak risiko pelacakan pada Bitcoin yang telah kami pelajari, ini mengekspos Anda pada risiko lain yang juga penting untuk diketahui. Itulah mengapa topik-topik ini akan dibahas dalam pelatihan khusus di masa depan di PlanB Network.

Jika Anda menikmati pelatihan ini, saya akan sangat berterima kasih jika Anda bisa membagikannya dengan teman-teman Anda dan di media sosial. Terima kasih! :)
